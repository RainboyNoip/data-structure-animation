webpackJsonpdsa([2],{2:function(e,t,n){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "./util.h"</span>\n\nvoid* SafeMalloc(size_t size) {\n    void* m;\n    <span class="keyword">if</span> ((m = malloc(size))) {\n        <span class="keyword">return</span> m;\n    } <span class="keyword">else</span> {\n        printf(<span class="string">"memory overflow\\n"</span>);\n        <span class="keyword">exit</span>(-<span class="number">1</span>);\n        <span class="keyword">return</span> <span class="number">0</span>;\n    }\n}\n\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">// }</span>\n    memcpy(a, b, size);\n}\n\nvoid MemorySwap(void *a, void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// char t;</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     t = *(char *)a;</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">//     *((char *)b + i) = t;</span>\n    <span class="comment">// }</span>\n    void *t = SafeMalloc(size);\n    memcpy(t, a, size);\n    memcpy(a, b, size);\n    memcpy(b, t, size);\n}\n\nvoid MemoryClear(void *a, size_t size) {\n    memset(a, <span class="number">0</span>, size);\n}\n\nvoid *MemoryAddress(void *a, int i, size_t size) {\n    <span class="keyword">return</span> (char *)a + i*size;\n}'},3:function(e,t,n){e.exports='<span class="comment">#ifndef UTIL_H</span>\n<span class="comment">#define UTIL_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\nvoid * SafeMalloc(size_t size);\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size);\nvoid MemorySwap(void *a, void *b, size_t size);\nvoid MemoryClear(void *a, size_t size);\n\n<span class="comment">#endif</span>'},10:function(e,t,n){t=e.exports=n(5)(),t.push([e.id,"circle.node{fill:#ccc;stroke:#000;stroke-width:1.5px}circle.node.painter-selected{fill:#000}circle.node.highlighted{stroke-dasharray:10 2;-webkit-animation:dash .4s linear infinite;animation:dash .4s linear infinite}text.edge,text.node{fill:#000;font:20px sans-serif;pointer-events:none;text-anchor:middle;text-shadow:0 1px 0 #fff,1px 0 0 #fff,0 -1px 0 #fff,-1px 0 0 #fff}path.drag,path.edge{fill:none;stroke:#000;stroke-width:4px}path.edge.painter-selected{stroke-dasharray:10 2;-webkit-animation:dash .4s linear infinite;animation:dash .4s linear infinite}path.edge.painter-selected.rev-dir{-webkit-animation-direction:reverse;animation-direction:reverse}path.edge.painter-selected.rev-dir.sam-dir{-webkit-animation-direction:alternate;animation-direction:alternate}@-webkit-keyframes dash{from{stroke-dashoffset:12}to{stroke-dashoffset:0}}@keyframes dash{from{stroke-dashoffset:12}to{stroke-dashoffset:0}}",""])},11:function(e,t,n){var a=n(1);e.exports=a.createClass({displayName:"module.exports",render:function(){var e={display:this.props.show?"block":"none"},t='<use xlink:href="#cursor">',n='<use xlink:href="#cross">',s=12,r=6,i=Math.sqrt(3),o="M"+[[0,0],[0,s],[i*s/6,-s/6],[r/2,r/2*i],[i*s/6,-s/6],[-r/2,-r/2*i],[i*s/6,-s/6]].map(function(e){return e.toString()}).join("l")+"z";return a.createElement("svg",{className:"legend",width:"210",height:"230",style:e},a.createElement("defs",null,a.createElement("path",{id:"cursor",d:o,stroke:"black",strokeWidth:"1.2",fill:"white"}),a.createElement("g",{id:"cross"},a.createElement("path",{d:"M-6,-6L6,6",stroke:"gray",strokeWidth:"2"}),a.createElement("path",{d:"M-6,6L6,-6",stroke:"gray",strokeWidth:"2"}))),a.createElement("rect",{className:"outline",stroke:"black",x:"0",y:"0",width:"200",height:"210"}),a.createElement("g",{transform:"translate(15,20)"},a.createElement("g",{transform:"translate(8,0)"},a.createElement("path",{d:"M2,0L8,0",markerEnd:"url(#arrow-end)",strokeWidth:"2",stroke:"black"}),a.createElement("path",{d:"M-2,0L-8,0",markerEnd:"url(#arrow-end)",strokeWidth:"2",stroke:"black"}),a.createElement("path",{d:"M0,2L0,8",markerEnd:"url(#arrow-end)",strokeWidth:"2",stroke:"black"}),a.createElement("path",{d:"M0,-2L0,-8",markerEnd:"url(#arrow-end)",strokeWidth:"2",stroke:"black"})),a.createElement("g",{transform:"translate(6,25)"},a.createElement("line",{x1:"0",y1:"0",x2:"10",y2:"10",stroke:"black",strokeWidth:"3"}),a.createElement("circle",{cx:"0",cy:"0",r:"6",fill:"white",stroke:"black",strokeWidth:"2"})),a.createElement("g",{transform:"translate(6,50)"},a.createElement("circle",{cx:"0",cy:"0",r:"6",className:"node"}),a.createElement("g",{transform:"translate(2,-2)",dangerouslySetInnerHTML:{__html:t}})),a.createElement("g",{transform:"translate(6,75)"},a.createElement("circle",{cx:"0",cy:"0",r:"6",className:"node",style:{opacity:"0.33"}}),a.createElement("circle",{cx:"6",cy:"0",r:"6",className:"node",style:{opacity:"0.67"}}),a.createElement("circle",{cx:"12",cy:"0",r:"6",className:"node",style:{opacity:"1"}}),a.createElement("g",{transform:"translate(12,-2)",dangerouslySetInnerHTML:{__html:t}})),a.createElement("g",{transform:"translate(6,100)"},a.createElement("circle",{cx:"0",cy:"0",r:"6",className:"node painter-selected",style:{opacity:"1"}}),a.createElement("g",{transform:"translate(0,0)",dangerouslySetInnerHTML:{__html:n}})),a.createElement("g",{transform:"translate(6,125)"},a.createElement("path",{d:"M0,0L20,0",markerEnd:"url(#arrow-end)",stroke:"black",strokeWidth:"2"}),a.createElement("circle",{r:"6",className:"node"})),a.createElement("g",{transform:"translate(0,150)"},a.createElement("g",{transform:"scale(0.5)"},a.createElement("path",{d:"M0,0L40,0",className:"edge painter-selected",markerEnd:"url(#arrow-end)",stroke:"black",strokeWidth:"2"})),a.createElement("g",{transform:"translate(10,0)",dangerouslySetInnerHTML:{__html:n}})),a.createElement("g",{transform:"translate(0,175)"},a.createElement("g",{transform:"scale(0.5)"},a.createElement("path",{d:"M0,0L40,0",className:"edge painter-selected",markerEnd:"url(#arrow-end)",stroke:"black",strokeWidth:"2"})),a.createElement("text",{x:"3",y:"5"},"a")),a.createElement("g",{transform:"translate(0,5)"},a.createElement("text",{x:"40",y:"0"},"拖动空白区平移"),a.createElement("text",{x:"40",y:"25"},"滚动鼠标轴缩放"),a.createElement("text",{x:"40",y:"50"},"双击添加结点"),a.createElement("text",{x:"40",y:"75"},"shift键拖动结点"),a.createElement("text",{x:"40",y:"100"},"退格键删除结点"),a.createElement("text",{x:"40",y:"125"},"结点上拖动添加边"),a.createElement("text",{x:"40",y:"150"},"退格键删除边"),a.createElement("text",{x:"40",y:"175"},"回车键输入权值"))))}})},12:function(e,t,n){e.exports='<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./graph.h"</span>\n\ngraph* GraphCreate(int n, size_t w_size) {\n    int i;\n    <span class="keyword">if</span> (n == <span class="number">0</span>) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    graph *g = SafeMalloc(sizeof(graph));\n    g->n = n;\n    g->w_size = w_size;\n    g->adja = SafeMalloc(n*(sizeof(graph_edge *)));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) {\n        g->adja[i] = SafeMalloc(sizeof(graph_edge));\n        g->adja[i]->next = <span class="keyword">NULL</span>;\n        g->adja[i]->w = <span class="keyword">NULL</span>;\n    }\n    <span class="keyword">return</span> g;\n}\n\nvoid GraphDestroy(graph *g) {\n    int i;\n    graph_edge *p, *e;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        e = g->adja[i];\n        <span class="keyword">while</span> (e != <span class="keyword">NULL</span>) {\n            p = e->next;\n            <span class="keyword">if</span> (e->w != <span class="keyword">NULL</span>) {\n                free(e->w);\n            }\n            free(e);\n            e = p;\n        }\n    }\n    free(g->adja);\n    free(g);\n}\n\nint GraphNodeValid(graph *g, int u) {\n    <span class="keyword">return</span> <span class="number">0</span> &lt;= u &amp;&amp; u &lt; g->n ? <span class="number">1</span> : <span class="number">0</span>;\n}\n\ngraph_edge* _GraphNewEdge(int u, int v, void *w, size_t w_size) {\n    graph_edge *e = SafeMalloc(sizeof(graph_edge));\n    e->u = u;\n    e->v = v;\n    e->w = SafeMalloc(w_size);\n    MemoryCopy(e->w, w, w_size);\n    <span class="keyword">return</span> e;\n}\n\ngraph_edge* GraphInsert(graph *g, int u, int v, void *w) {\n    graph_edge *e;\n    <span class="keyword">if</span> (!GraphNodeValid(g,u) || !GraphNodeValid(g,v)) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    e = _GraphNewEdge(u,v,w,g->w_size);\n    e->next = g->adja[u]->next;\n    g->adja[u]->next = e;\n    <span class="keyword">return</span> e;\n}'},13:function(e,t,n){e.exports='<span class="comment">#ifndef GRAPH_H</span>\n<span class="comment">#define GRAPH_H</span>\n<span class="comment">#include &lt;stddef.h></span>\n\ntypedef struct graph_edge {\n  int u;\n  int v;\n  void *w;\n  struct graph_edge *next;\n} graph_edge;\n\ntypedef struct graph {\n  int n;\n  size_t w_size;\n  graph_edge **adja;\n} graph;\n\ngraph* GraphCreate(int n, size_t w_size);\nvoid GraphDestroy(graph *g);\ngraph_edge* GraphInsert(graph *g, int u, int v, void *w);\ngraph_edge* GraphDelete(graph *g, int u, int v);\nint GraphNodeValid(graph *g, int u);\n\n<span class="comment">#endif</span>'},14:function(e,t,n){e.exports='<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./min-heap.h"</span>\n\nmin_heap* MinHeapCreate(int n, size_t item_size, int (*CompFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*)) {\n    int i;\n    min_heap* h = (min_heap*)SafeMalloc(sizeof(min_heap));\n    h-><span class="keyword">array</span> = SafeMalloc(n * sizeof(min_heap_pair));\n    h->capacity = n;\n    h->size = <span class="number">0</span>;\n    h->item_size = item_size;\n    h->Compare = CompFn;\n    h->map = SafeMalloc(n*sizeof(int));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) {\n        h-><span class="keyword">array</span>[i].item = <span class="keyword">NULL</span>;\n        h->map[i] = -<span class="number">1</span>;\n    }\n    <span class="keyword">return</span> h;\n}\n\nvoid MinHeapDestroy(min_heap *h) {\n    int i;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; h->capacity; ++i) {\n        <span class="keyword">if</span> (h-><span class="keyword">array</span>[i].item != <span class="keyword">NULL</span>) {\n            free(h-><span class="keyword">array</span>[i].item);\n        }\n    }\n    free(h-><span class="keyword">array</span>);\n    free(h->map);\n    free(h);\n}\n\nint _P(int x) {\n    <span class="keyword">return</span> x == <span class="number">0</span> ? <span class="number">0</span> : (x-<span class="number">1</span>)/<span class="number">2</span>;\n}\nint _L(int x) {\n    <span class="keyword">return</span> x*<span class="number">2</span>+<span class="number">1</span>;\n}\nint _R(int x) {\n    <span class="keyword">return</span> x*<span class="number">2</span>+<span class="number">2</span>;\n}\nvoid _Exchange(min_heap* h, int i, int j) {\n    min_heap_pair tmp;\n    tmp = h-><span class="keyword">array</span>[i];\n    h-><span class="keyword">array</span>[i] = h-><span class="keyword">array</span>[j];\n    h-><span class="keyword">array</span>[j] = tmp;\n    h->map[h-><span class="keyword">array</span>[i].key] = i;\n    h->map[h-><span class="keyword">array</span>[j].key] = j;\n}\n\nvoid _Swim(min_heap *h, int x) {\n    <span class="keyword">while</span> (x != <span class="number">0</span> &amp;&amp; h->Compare(h-><span class="keyword">array</span>[x].item, h-><span class="keyword">array</span>[_P(x)].item) &lt; <span class="number">0</span>) {\n        _Exchange(h, x, _P(x));\n        x = _P(x);\n    }\n}\n\nvoid _Sink(min_heap *h, int x) {\n    int y = -<span class="number">1</span>;\n    <span class="keyword">while</span> (x != y) {\n        y = x;\n        <span class="keyword">if</span> (_L(x) &lt; h->size &amp;&amp; h->Compare(h-><span class="keyword">array</span>[_L(x)].item, h-><span class="keyword">array</span>[x].item) &lt; <span class="number">0</span>) {\n            y = _L(x);\n        }\n        <span class="keyword">if</span> (_R(x) &lt; h->size &amp;&amp; h->Compare(h-><span class="keyword">array</span>[_R(x)].item, h-><span class="keyword">array</span>[y].item) &lt; <span class="number">0</span>) {\n            y = _R(x);\n        }\n        <span class="keyword">if</span> (y != x) {\n            _Exchange(h, x, y);\n            x = y;\n            y = -<span class="number">1</span>;\n        }\n    }\n}\n\nvoid MinHeapInsert(min_heap* h, void* item, int id) {\n    int x = h->size;\n    <span class="keyword">if</span> (x == h->capacity) {\n        <span class="keyword">return</span>;\n    }\n    h-><span class="keyword">array</span>[x].key = id;\n    h->map[id] = x;\n    <span class="keyword">if</span> (h-><span class="keyword">array</span>[x].item == <span class="keyword">NULL</span>) {\n        h-><span class="keyword">array</span>[x].item = SafeMalloc(h->item_size);\n    }\n    MemoryCopy(h-><span class="keyword">array</span>[x].item, item, h->item_size);\n    h->size++;\n    _Swim(h, x);\n}\n\nvoid* MinHeapPop(min_heap* h) {\n    void* item = SafeMalloc(h->item_size);\n    <span class="keyword">if</span> (h->size == <span class="number">0</span>) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    MemoryCopy(item, h-><span class="keyword">array</span>[<span class="number">0</span>].item, h->item_size);\n    h->map[h-><span class="keyword">array</span>[<span class="number">0</span>].key] = -<span class="number">1</span>;\n    MemoryCopy(h-><span class="keyword">array</span>[<span class="number">0</span>].item, h-><span class="keyword">array</span>[h->size-<span class="number">1</span>].item, h->item_size);\n    h-><span class="keyword">array</span>[<span class="number">0</span>].key = h-><span class="keyword">array</span>[h->size-<span class="number">1</span>].key;\n    h->map[h-><span class="keyword">array</span>[<span class="number">0</span>].key] = <span class="number">0</span>;\n    free(h-><span class="keyword">array</span>[h->size-<span class="number">1</span>].item);\n    h-><span class="keyword">array</span>[h->size-<span class="number">1</span>].item = <span class="keyword">NULL</span>;\n    h->size--;\n    _Sink(h, <span class="number">0</span>);\n    <span class="keyword">return</span> item;\n}\n\nvoid *MinHeapUpdate(min_heap *h, void *item, int id) {\n    int i;\n    int rc;\n    <span class="keyword">if</span> (id &lt; <span class="number">0</span> || id >= h->capacity) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    i = h->map[id];\n    rc = h->Compare(h-><span class="keyword">array</span>[i].item, item);\n    MemoryCopy(h-><span class="keyword">array</span>[i].item, item, h->item_size);\n    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) {\n        _Sink(h, i);\n        <span class="keyword">return</span> item;\n    } <span class="keyword">else</span> <span class="keyword">if</span> (rc > <span class="number">0</span>) {\n        _Swim(h, i);\n        <span class="keyword">return</span> item;\n    }\n    <span class="keyword">return</span> <span class="keyword">NULL</span>;\n}'},15:function(e,t,n){e.exports='<span class="comment">#ifndef MIN_HEAP_H</span>\n<span class="comment">#define MIN_HEAP_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\ntypedef struct min_heap_pair {\n    void *item;\n    int key;\n} min_heap_pair;\n\ntypedef struct min_heap {\n    int size;\n    int capacity;\n    size_t item_size;\n    min_heap_pair* <span class="keyword">array</span>;\n    int (*Compare)(<span class="keyword">const</span> void* a, <span class="keyword">const</span> void* b);\n    int* map;\n} min_heap;\n\nmin_heap* MinHeapCreate(int n, size_t item_size, int (*CompFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*));\nvoid MinHeapInsert(min_heap* h, void* item, int id);\nvoid* MinHeapPop(min_heap* h);\nvoid MinHeapDestroy(min_heap* h);\nvoid *MinHeapUpdate(min_heap *h, void *item, int id);\n\n<span class="comment">#endif</span>'},20:function(e,t,n){var a=n(10);"string"==typeof a&&(a=[[e.id,a,""]]);n(6)(a,{})},21:function(e,t,n){function a(e){this.array=[],this.cf=e,this.map=[]}a.prototype.p=function(e){return 0==e?0:Math.floor((e-1)/2)},a.prototype.l=function(e){return 2*e+1},a.prototype.r=function(e){return 2*e+2},a.prototype.ex=function(e,t){var n=this.array[e];this.array[e]=this.array[t],this.array[t]=n,this.map[this.array[e].k]=e,this.map[this.array[t].k]=t},a.prototype.swim=function(e){for(;0!=e&&this.cf(this.array[e].v,this.array[this.p(e)].v)<0;)this.ex(e,this.p(e)),e=this.p(e)},a.prototype.sink=function(e){for(var t=-1;e!==t;)t=e,void 0!==this.array[this.l(e)]&&this.cf(this.array[this.l(e)].v,this.array[e].v)<0&&(t=this.l(e)),void 0!==this.array[this.r(e)]&&this.cf(this.array[this.r(e)].v,this.array[t].v)<0&&(t=this.r(e)),t!=e&&(this.ex(e,t),e=t,t=-1)},a.prototype.insert=function(e,t){this.array.push({v:e,k:t}),this.map[t]=this.array.length-1,this.swim(this.array.length-1)},a.prototype.pop=function(){if(0!==this.array.length){var e=this.array[0];return this.ex(0,this.array.length-1),this.array.pop(),this.map[e.k]=void 0,this.sink(0),e.v}},a.prototype.update=function(e,t){if(!(0>t||t>=this.array.length)){var n=this.map[t],a=this.cf(this.array[n].v,e);this.array[n].v=e,0>a?this.sink(n):a>0&&this.swim(n)}},a.prototype.forceUpdate=function(e){var t=this.map[e];this.sink(t),this.swim(t)},e.exports=a},22:function(e,t,n){function a(e){ce=!1,W=e.container||document.body,T=N.select(e.container).append("svg").node(),q=e.weighted||!1,U=e.directional||!1,R=e.width||T.clientWidth||e.container.clientWidth,O=e.height||T.clientHeight||e.container.clientHeight,oe=e.offsetLeft||0,ie=e.offsetTop||0,Q.nodes=e.nodes||N.range(e.n||5).map(function(){return{}}),Q.edges=(e.edges||N.range(5).map(function(e){return{u:e,v:(e+1)%5}})).map(function(e){return{source:Q.nodes[e.u],target:Q.nodes[e.v],val:e.w,reflexive:e.reflexive}}),j=void 0,B=e._onSelected||void 0,_onLoad=e._onLoad||void 0,se=void 0,re=!1,N.select(T).call(ae).on("dblclick.zoom",null).on("dblclick.svg",M);var t=N.select(T).append("defs");return t.append("marker").attr("id","arrow-end").attr("viewBox","0 -5 10 10").attr("refX",7).attr("refY",0).attr("markerWidth",ee).attr("markerHeight",ee).attr("orient","auto").append("path").attr("d","M0,-5L10,0L0,5"),t.append("marker").attr("id","arrow-start").attr("viewBox","0 -5 10 10").attr("refX",3).attr("refY",0).attr("markerWidth",ee).attr("markerHeight",ee).attr("orient","auto").append("path").attr("d","M10,-5L0,0L10,5"),G=N.select(T).append("g").attr("class","svg-entry"),H=G.append("g").attr("class","base"),F=H.append("g").attr("class","edges").classed("directional",U).classed("weighted",q),$=H.append("g").attr("class","nodes"),Y=G.append("g").attr("class","text").attr("transform","translate(0,7)"),F.append("path").attr("class","drag").attr("marker-end","url(#arrow-end)").style("display","none"),N.select(window).on("keydown.window",E),te.nodes(Q.nodes).links(Q.edges).size([R,O]),d(),D(!1),te.on("end",function(){D(),te.on("end",null),_onLoad&&_onLoad()}),e.nowait&&(u(),te.on("end")()),this}function s(e,t){var n=e.x-t.x,a=e.y-t.y;return K*K>=n*n+a*a}function r(e,t){var n=Math.PI*t/180;return{x:e.x*Math.cos(n)+e.y*Math.sin(n),y:e.x*-Math.sin(n)+e.y*Math.cos(n)}}function i(e){return"translate("+e.x+","+e.y+")"}function o(e){return{x:-e.x,y:-e.y}}function c(e,t){return{x:e.x-t.x,y:e.y-t.y}}function l(e){return void 0===e.val?"":e.val}function p(e){var t=e.target.x-e.source.x,n=e.target.y-e.source.y,a=Math.sqrt(t*t+n*n),i=N.interpolate(e.source,e.target)(K/a),l=N.interpolate(e.target,e.source)(K/a),p=N.interpolate(30,0)(K/a);if(U&&q){var u=Q.edges.filter(function(t){return t.target===e.source&&(t.source===e.target||s(e.target,t.source))});return u.length>0?(e.curve=!0,i=c(r(c(i,e.source),p),o(e.source)),l=c(r(c(l,e.target),-p),o(e.target)),"M"+i.x+","+i.y+"A"+a+","+a+" 0 0,1 "+l.x+","+l.y):(e.curve=!1,"M"+i.x+","+i.y+"L"+l.x+","+l.y)}return e.curve=!1,"M"+i.x+","+i.y+"L"+l.x+","+l.y}function u(){$.selectAll(".node").data(Q.nodes).classed("painter-selected",function(e){return e===j}).attr("transform",i),Y.selectAll(".node").data(Q.nodes).attr("transform",i).text(function(e,t){return t}),F.selectAll(".edge").data(Q.edges).classed("painter-selected",function(e){return e===j}).attr("marker-end",U?"url(#arrow-end)":null).attr("marker-start",U&&q===!1?function(e){return e.reflexive?"url(#arrow-start)":null}:null).attr("d",p),q&&(F.selectAll(".edge").each(function(e){var t=this.getPointAtLength(this.getTotalLength()/2);e.x=t.x,e.y=t.y}),Y.selectAll(".edge").data(Q.edges).attr("transform",i).text(l))}function d(){$.selectAll(".node").data(Q.nodes).enter().append("circle").attr("class","node").attr("r",K).on("dblclick.node",f).call(ne).on("click.select",x).on("mousedown.node",v).on("mouseup.node",w),$.selectAll(".node").data(Q.nodes).exit().remove(),Y.selectAll(".node").data(Q.nodes).enter().append("text").attr("class","node"),Y.selectAll(".node").data(Q.nodes).exit().remove(),F.selectAll(".edge").data(Q.edges).enter().append("path").attr("class","edge").on("click.select",x),F.selectAll(".edge").data(Q.edges).exit().remove(),q?(Y.selectAll(".edge").data(Q.edges).enter().append("text").attr("class","edge"),Y.selectAll(".edge").data(Q.edges).exit().remove()):Y.selectAll(".edge").remove(),te.start()}function h(){R=T.clientWidth||W.clientWidth,O=T.clientHeight||W.clientHeight,te.size([R,O]).resume()}function f(e){N.event.stopPropagation(),N.select(this).classed("fixed",e.fixed=!1),te.resume()}function m(e){e.fixed|=2}function g(e){se&&(re?(N.select(this).classed("fixed",e.fixed=!0),e.px=N.event.x||N.event.clientX,e.py=N.event.y||N.event.clientY,te.resume()):s(N.event,e)===!1?F.select("path.drag").datum({source:e,target:{x:N.event.x||N.event.clientX,y:N.event.y||N.event.clientY}}).attr("d",p).style("display",null):F.select("path.drag").style("display","none"))}function y(e){e.fixed&=-7,F.select("path.drag").style("display","none")}function v(e){(N.event.ctrlKey===!1||void 0===N.event.ctrlKey)&&(N.event.stopPropagation(),se=e,re=N.event.shiftKey?!0:!1)}function w(e){if(se&&se!==e){var t={source:se,target:e};k(t),d()}se=void 0,re=!1}function x(e,t){j=j===e?void 0:e,t===!0&&(j=e),j&&B&&B(),te.resume()}function k(e){var t;U===!1?(t=Q.edges.filter(function(t){return t.source===e.source&&t.target===e.target||t.target===e.source&&t.source===e.target}),t.length>0?e=t[0]:Q.edges.push(e)):q?(t=Q.edges.filter(function(t){return t.source===e.source&&t.target===e.target}),t.length>0?e=t[0]:Q.edges.push(e)):(t=Q.edges.filter(function(t){return t.source===e.source&&t.target===e.target||t.target===e.source&&t.source===e.target}),t.length>0?(t[0].source===e.target&&(t[0].reflexive=!0),e=t[0]):Q.edges.push(e)),x(e,!0)}function _(){var e=void 0===j||void 0===j.val?"数字":j.val;return prompt("权值",e)}function b(e){var t=e();return""===t?void delete j.val:(t=parseFloat(t),isNaN(t)||j.val===t?void 0:(j.val=t,d(),this))}function E(){j&&(8===N.event.keyCode?(N.event.preventDefault(),S()):13===N.event.keyCode&&q&&b(_))}function S(){var e=Q.nodes.indexOf(j);return-1!==e?(Q.nodes.splice(e,1),Q.edges.filter(function(e){return e.source===j||e.target===j}).forEach(function(e){Q.edges.splice(Q.edges.indexOf(e),1)})):(e=Q.edges.indexOf(j),-1!=e&&Q.edges.splice(Q.edges.indexOf(j),1)),j=void 0,d(),this}function L(){X=N.event.translate,J=N.event.scale,G.attr("transform","translate("+N.event.translate+")scale("+N.event.scale+")")}function A(){var e=document.documentElement;return{left:(window.pageXOffset||e.scrollLeft)-(e.clientLeft||0),top:(window.pageYOffset||e.scrollTop)-(e.clientTop||0)}}function M(){if(N.event.target===this){var e=N.event.x||N.event.clientX||N.event.clientX,t=N.event.y||N.event.clientY||N.event.clientY,n=A();e+=n.left-oe,t+=n.top-ie;var a={x:(e-X[0])/J,y:(t-X[1])/J};Q.nodes.push(a),x(a),d()}}function D(e){return j&&(F.select(".painter-selected").classed("painter-selected",!1),$.select(".painter-selected").classed("painter-selected",!1),j=void 0),q&&(Q.edges.forEach(function(e){void 0===e.val&&(e.val=1)}),u()),e!==!1&&te.stop(),N.select(window).on("resize",null).on("keydown.window",null),N.select(T).on("dblclick.svg",null),$.selectAll("circle.node").on("dblclick.node",null).on("dragstart",null).on("drag",null).on("dragend",null).on("click.select",null).on("mousedown.node",null).on("mouseup.node",null),F.selectAll("path.edge").on("click.select",null),this}function C(e,t){function n(e,t){return e.source===t.target&&e.target===t.source}if(U!==e||q!==t){pd=U,U=e,q=t;var a=[];return Q.edges.forEach(function(e){U?q?((pd===!1||e.reflexive)&&a.push({source:e.target,target:e.source,val:e.val}),delete e.reflexive,a.push(e)):(delete e.reflexive,a.some(function(t){return n(e,t)})===!1&&((pd===!1||Q.edges.some(function(t){return n(e,t)})===!0)&&(e.reflexive=!0),a.push(e))):a.some(function(t){return n(e,t)})===!1&&(delete e.reflexive,a.push(e))}),Q.edges=a,F.classed("directional",U).classed("weighted",q),d(),this}}function P(){te.start(),N.select(window).on("resize",h).on("keydown.window",E),N.select(T).on("dblclick.svg",M),$.selectAll("circle.node").on("dblclick.node",f).call(ne).on("click.select",x).on("mousedown.node",v).on("mouseup.node",w),F.selectAll("path.edge").on("click.select",x)}function z(){Q.nodes.length=0,Q.edges.length=0,d()}function I(){}var N=n(4);n(20);var T,q,U,R,O,j,B,G,H,F,$,Y,W,Q={},X=[0,0],J=1,K=15,V=150,Z=-600,ee=3,te=N.layout.force().linkDistance(V).charge(Z).on("tick",u),ne=N.behavior.drag().origin(function(e){return e}).on("dragstart",m).on("drag",g).on("dragend",y),ae=N.behavior.zoom().scaleExtent([.1,10]).on("zoom",L),se=void 0,re=!1,ie=0,oe=0,ce=!1;e.exports={stop:D,convert:C,weighSelected:b,deleteSelected:S,init:a,restart:P,clear:z,random:I,directional:function(){return U},weighted:function(){return q},raw:function(){return Q},data:function(){var e=Q.edges.map(function(e){return{u:e.source.index,v:e.target.index,w:e.val}});return U||(e=e.concat(Q.edges.map(function(e){return{u:e.target.index,v:e.source.index,w:e.val}}))),U&&!q&&(e=e.concat(Q.edges.filter(function(e){return e.reflexive}).map(function(e){return{u:e.target.index,v:e.source.index,w:e.val}}))),{weighted:q,directional:U,n:Q.nodes.length,e:e}}}},36:function(e,t,n){function a(e,t){return e===x||t===k?e===t?0:-1:e===k||t===x?e===t?0:1:e-t}function s(e,t){return a(e.w,t.w)}function r(e,t){return e===k||t===k?k:e===x||t===x?e===x?t:e:e+t}function i(e,t){void 0===t?g[e].pop():g[e].push(t)}function o(e){return e>=0&&e<v.n}function c(e,t){var n,c,l,u,d,h,f;if(p(56,1),!o(e))return void p(57);for(l=new w(s),f=[],d=[],g.pns=d,p(65,1),n=0;n<v.n;++n)d[n]={i:n},d[n].w=n==e?x:k,d[n].e=void 0,l.insert(d[n],n);for(n=0;p(71,1),n<v.n;++n){if(p(72),h=l.pop(),i("hl",h.i),d[h.i].out=!0,h.e&&i("ine",h.e),p(73,1),n===v.n-1){i("hl"),p(74);break}for(u=0;p(76,1),i("se"),i("hle"),u<v.e[h.i].length;u++){var m=v.e[h.i][u];p(77,1),c=r(h.w,m.w),i("se",m),i("hle",m),p(78,1),a(d[m.v].w,c)>0&&(i("ine",m),d[m.v].w=c,d[m.v].e=m,p(84,1),l.forceUpdate(m.v),i("ine"))}i("hl")}return f}function l(e){v.n=e.n,v.e=[];for(var t=0;t<v.n;++t)v.e.push([]);e.e.forEach(function(e){v.e[e.u].push(e)})}function p(e,t,n){1===t&&(lastStatus=g.clone()),f.push({status:lastStatus,line:e,animation:n,id:m}),m++}function u(){0===f.length?0:f[f.length-1].line;p(150,1)}function d(e){return e=parseInt(e),isNaN(e)?0:e}var h=n(8),f=[],m=0,g={},y=0,v={},w=n(21),x="-",k="+";g.clone=function(){return{neg:x,pos:k,ine:h(this.ine)||[],se:h(this.se)||[],hl:h(this.hl)||[],hle:h(this.hle)||[],pns:h(this.pns)||[]}},g.init=function(e){this.se=[],this.ine=[],this.pns=[],this.hl=[],this.hle=[]},lastStatus={},e.exports={initialize:function(e){return f=[],m=0,e&&(y=0),g.init(e),lastStatus=g.clone(),this},dijkstra:c,run:function(e,t){return l(t.g),this.initialize()[e](d(t.src)),u(),{frames:f,others:{}}}}},47:function(e,t,n){t=e.exports=n(5)(),t.push([e.id,"path.ine{stroke-width:20px;stroke:#00bfff;fill:none;stroke-opacity:.5}.node.visited{fill:#00bfff}path.edge.highlighted{stroke-width:6px}",""])},77:function(e,t,n){var a=n(1);e.exports=a.createClass({displayName:"module.exports",render:function(){var e={display:this.props.show?"block":"none"};return a.createElement("svg",{className:"legend",width:"210",height:"190",style:e},a.createElement("rect",{className:"outline",stroke:"black",x:"0",y:"0",width:"200",height:"170"}),a.createElement("g",{transform:"translate(15,20)"},a.createElement("g",{transform:"translate(0,0)"},a.createElement("g",{transform:"scale(0.5)"},a.createElement("path",{d:"M0,0L50,0",className:"edge painter-selected"}))),a.createElement("g",{transform:"translate(0,25)"},a.createElement("g",{transform:"scale(0.5)"},a.createElement("path",{d:"M0,0L50,0",className:"ine"}))),a.createElement("g",{transform:"translate(6,50)"},a.createElement("circle",{cx:"0",cy:"0",r:"6",className:"node highlighted"})),a.createElement("g",{transform:"translate(6,75)"},a.createElement("circle",{cx:"0",cy:"0",r:"6",className:"node visited"})),a.createElement("g",{transform:"translate(6,100)"},a.createElement("circle",{r:"6",className:"node"}),a.createElement("path",{d:"M0,0L0,-6A6,6 0 0,1 5.19,3Z",className:"inq"})),a.createElement("g",{transform:"translate(6,125)"},a.createElement("circle",{r:"6",className:"node"}),a.createElement("text",{x:"2",y:"-2",fontSize:"10px"},"=距离")),a.createElement("g",{transform:"translate(0,5)"},a.createElement("text",{x:"40",y:"0"},"更新源"),a.createElement("text",{x:"40",y:"25"},"单源最短路径树"),a.createElement("text",{x:"40",y:"50"},"当前结点"),a.createElement("text",{x:"40",y:"75"},"已完成结点"),a.createElement("text",{x:"40",y:"100"},"可加入结点"),a.createElement("text",{x:"40",y:"125"},"到源点的距离"))))}})},78:function(e,t,n){n(139);var a=n(1),s=n(7),r=n(22),i=n(155),o=n(77),c=n(11);e.exports=a.createClass({displayName:"module.exports",getInitialState:function(){return{painting:!1,loaded:!1,text:"",demo:"",graphType:"有向图",help:!0}},componentDidMount:function(){r.init({container:this.refs.svg.getDOMNode(),offsetTop:document.querySelector(".dsa-app").offsetTop+55,offsetLeft:document.querySelector(".dsa-app").offsetLeft+80,_onLoad:this._onLoad,nodes:[{x:50,y:150,fixed:!0},{x:150,y:250,fixed:!0},{x:150,y:50,fixed:!0},{x:300,y:250,fixed:!0},{x:300,y:50,fixed:!0}],edges:[{u:0,v:1,w:5},{u:0,v:2,w:3},{u:1,v:2,w:1},{u:1,v:3,w:6},{u:1,v:4,w:4},{u:2,v:1,w:2},{u:2,v:4,w:6},{u:3,v:0,w:3},{u:3,v:4,w:7},{u:4,v:3,w:2}],directional:!0,weighted:!0,nowait:!0}),i.init(r.raw())},componentDidUpdate:function(e){this.props!==e&&void 0!==this.props.frame&&this.props.frame&&i.render(this.props.frame.status,this.props.delay,this.props.others)},render:function(){var e=this.state.painting?a.createElement(c,{show:this.state.help}):a.createElement(o,{show:this.state.help});return a.createElement("div",{className:"wrapper-code"},a.createElement("div",{className:"list"},this.getInputList()),a.createElement("div",{ref:"svg",
className:"scene"}),e)},_onLoad:function(){this.setState({loaded:!0})},_onPainting:function(){this.state.painting?r.stop():(i.clear(),s.pauseDemo(),s.waitDemo(),r.restart()),this.setState({painting:!this.state.painting,demo:""})},_onChange:function(e,t){var n={};n[e]=t.target.value,this.setState(n)},_onClick:function(e){this.setState({demo:e}),i.clear(),i.init(r.raw()),s.runDemo(e,{g:r.data(),src:this.state.text})},_onConvert:function(e,t){this.setState({graphType:e?"有向图":"无向图"}),r.convert(e,t)},_onHelp:function(){this.setState({help:!this.state.help})},getInputList:function(){if(this.state.loaded===!1)return a.createElement("input",{className:"input-button",readOnly:!0,value:"加载中",title:"加载中"});var e=this;if(this.state.painting){var t=[{onClick:this._onConvert.bind(this,!1,!0),value:"无向图"},{onClick:this._onConvert.bind(this,!0,!0),value:"有向图"},{onClick:r.clear,value:"清空"},{onClick:this._onPainting,value:"完成"},{help:this.state.help,onClick:this._onHelp,value:"帮助"}];return a.createElement("div",null,t.map(function(t,n){var s="input-group"+(t.value===e.state.graphType||t.help?" input-current":"");return a.createElement("div",{key:n,className:s},a.createElement("input",{className:"input-button",readOnly:!0,onClick:t.onClick,value:t.value,title:t.value}))}))}var t=[{button:{demo:"dijkstra",onClick:this._onClick.bind(this,"dijkstra"),value:"Dijkstra单源最短路径"},items:[{onChange:this._onChange.bind(this,"text"),value:this.state.text,placeholder:"源点"}]},{button:{demo:"",onClick:this._onPainting,value:"编辑图"}},{button:{help:this.state.help,onClick:this._onHelp,value:"帮助"}}];return a.createElement("div",null,t.map(function(t,n){var s="input-group"+(t.button.demo===e.state.demo||t.button.help?" input-current":""),r=t.items?t.items:[];return a.createElement("div",{key:n,className:s},a.createElement("input",{className:"input-button",readOnly:!0,onClick:t.button.onClick,value:t.button.value,title:t.button.value}),a.createElement("div",null,r.map(function(e,t){return a.createElement("input",{key:t,className:"input-item",onChange:e.onChange,value:e.value,title:e.value,placeholder:e.placeholder})})))}))}})},121:function(e,t,n){e.exports="CC=gcc\nCFLAGS=-c -Wall\nLDFLAGS=\nSOURCES=test.c ../common/util.c ../common/util.h ../common/graph.c ../common/graph.h ../min-heap/min-heap.c ../min-heap/min-heap.h ../stack/stack.c ../stack/stack.h ./sssp.c ./sssp.h\nOBJECTS=$(SOURCES:.c=.o)\nEXECUTABLE=a.out\n\nall: $(SOURCES) $(EXECUTABLE)\n\n$(EXECUTABLE): $(OBJECTS)\n    $(CC) $(LDFLAGS) $(OBJECTS) -o $@\n\n.cpp.o:\n    $(CC) $(CFLAGS) $&lt; -o $@\n\nclean:\n    rm -rf *.o a.out"},122:function(e,t,n){e.exports='<span class="comment">#include  &lt;stdlib.h></span>\n<span class="comment">#include "../common/graph.h"</span>\n<span class="comment">#include "../min-heap/min-heap.h"</span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "../stack/stack.h"</span>\n\ntypedef struct dijkstra_node {\n    int i;\n    void *w;\n    graph_edge *e;\n} dijkstra_node;\n\nint (*_gGraphEdgeWeightCompare)(<span class="keyword">const</span> void *, <span class="keyword">const</span> void *);\nvoid (*_gGraphEdgeWeightAdd)(<span class="keyword">const</span> void *, <span class="keyword">const</span> void *, <span class="keyword">const</span> void *);\nint _gNegInfinity = <span class="number">0</span>;\nint _gPosInfinity = <span class="number">0</span>;\n\nint _GraphDijkstraEdgeCompare(<span class="keyword">const</span> void *a, <span class="keyword">const</span> void *b) {\n    <span class="keyword">if</span> (a == &amp;_gNegInfinity || b == &amp;_gPosInfinity) {\n        <span class="keyword">return</span> a == b ? <span class="number">0</span> : -<span class="number">1</span>;\n    } <span class="keyword">else</span> <span class="keyword">if</span> (a == &amp;_gPosInfinity || b == &amp;_gNegInfinity) {\n        <span class="keyword">return</span> a == b ? <span class="number">0</span> : <span class="number">1</span>;\n    }\n    <span class="keyword">return</span> _gGraphEdgeWeightCompare(a, b);\n}\n\nint _GraphDijkstraNodeCompare(<span class="keyword">const</span> void *a, <span class="keyword">const</span> void *b) {\n    <span class="keyword">return</span> _GraphDijkstraEdgeCompare(((dijkstra_node *)a)->w, ((dijkstra_node *)b)->w);\n}\n\n<span class="keyword">const</span> void *_GraphDijkstraWeightAdd(<span class="keyword">const</span> void *a, <span class="keyword">const</span> void *b, <span class="keyword">const</span> void *c) {\n    <span class="keyword">if</span> (a == &amp;_gPosInfinity || b == &amp;_gPosInfinity) {\n        <span class="keyword">return</span> &amp;_gPosInfinity;\n    } <span class="keyword">else</span> <span class="keyword">if</span> (a == &amp;_gNegInfinity || b == &amp;_gNegInfinity) {\n        <span class="keyword">return</span> a == &amp;_gNegInfinity ? b : a;\n    }\n    _gGraphEdgeWeightAdd(a, b, c);\n    <span class="keyword">return</span> c;\n}\n\nstack *GraphDijkstra(\n    graph *g,\n    int src,\n    int dest,\n    int (*CompFn)(<span class="keyword">const</span> void *, <span class="keyword">const</span> void *),\n    void (*AddFn)(<span class="keyword">const</span> void *, <span class="keyword">const</span> void *, <span class="keyword">const</span> void *)\n) {\n    int i;\n    void *w;\n    <span class="keyword">const</span> void *rw;\n    min_heap *mh;\n    graph_edge *e;\n    dijkstra_node *dns;\n    dijkstra_node *dn;\n    stack *s;\n    <span class="keyword">if</span> (!GraphNodeValid(g, src) || !GraphNodeValid(g, dest)) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    w = SafeMalloc(g->w_size);\n    _gGraphEdgeWeightCompare = CompFn;\n    _gGraphEdgeWeightAdd = AddFn;\n    mh = MinHeapCreate(g->n, sizeof(dijkstra_node), _GraphDijkstraNodeCompare);\n    s = StackCreate(g->n, sizeof(graph_edge));\n    dns = SafeMalloc(g->n*sizeof(dijkstra_node));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        dns[i].i = i;\n        dns[i].w = (i == src ? &amp;_gNegInfinity : &amp;_gPosInfinity);\n        dns[i].e = <span class="keyword">NULL</span>;\n        MinHeapInsert(mh, &amp;dns[i], i);\n    }\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        dn = MinHeapPop(mh);\n        <span class="keyword">if</span> (i == g->n-<span class="number">1</span>) {\n          <span class="keyword">break</span>;\n        }\n        <span class="keyword">for</span> (e = g->adja[dn->i]->next; e != <span class="keyword">NULL</span>; e = e->next) {\n            rw = _GraphDijkstraWeightAdd(dn->w, e->w, w);\n            <span class="keyword">if</span> (_GraphDijkstraEdgeCompare(dns[e->v].w, rw) > <span class="number">0</span>) {\n               <span class="keyword">if</span> (dns[e->v].w == &amp;_gPosInfinity) {\n                   dns[e->v].w = SafeMalloc(g->w_size);\n               }\n               MemoryCopy(dns[e->v].w, w, g->w_size);\n               dns[e->v].e = e;\n               MinHeapUpdate(mh, &amp;dns[e->v], e->v);\n            }\n        }\n        free(dn);\n    }\n    i = dest;\n    <span class="keyword">while</span> (i != src) {\n      StackPush(s, dns[i].e);\n      i = dns[i].e->u;\n    }\n    MinHeapDestroy(mh);\n    free(w);\n    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; g->n; ++i) {\n      <span class="keyword">if</span> (dns[i].w != &amp;_gPosInfinity) {\n        free(dns[i].w);\n      }\n    }\n    free(dns);\n    <span class="keyword">return</span> s;\n}'},123:function(e,t,n){e.exports='<span class="comment">#ifndef DIJKSTRA_H</span>\n<span class="comment">#define DIJKSTRA_H</span>\n\n<span class="comment">#include "../common/graph.h"</span>\n<span class="comment">#include "../stack/stack.h"</span>\n\nstack *GraphDijkstra(\n    graph *g,\n    int src,\n    int dest,\n    int (*CompFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*),\n    void (*AddFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*, <span class="keyword">const</span> void *)\n);\n\n<span class="comment">#endif</span>'},124:function(e,t,n){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/graph.h"</span>\n<span class="comment">#include "./sssp.h"</span>\n<span class="comment">#include "../stack/stack.h"</span>\n\nint Compare(<span class="keyword">const</span> void *a, <span class="keyword">const</span> void *b) {\n    <span class="keyword">return</span> *(int *)a - *(int *)b;\n}\n\nvoid Add(<span class="keyword">const</span> void *a, <span class="keyword">const</span> void *b, <span class="keyword">const</span> void *c) {\n    *(int *)c = *(int *)a + *(int *)b;\n}\n\nint main(int argc, char <span class="keyword">const</span> *argv[])\n{\n    int n, m, i, u, v, w;\n    graph *g;\n    stack *s;\n    graph_edge *e;\n    int sum = <span class="number">0</span>;\n    <span class="keyword">while</span> (scanf(<span class="string">"%d%d"</span>, &amp;n,&amp;m) != EOF) {\n        g = GraphCreate(n, sizeof(int));\n        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++i) {\n            scanf(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);\n            GraphInsert(g, u, v, &amp;w);\n        }\n        s = GraphDijkstra(g, <span class="number">0</span>, n-<span class="number">1</span>, Compare, Add);\n        sum = <span class="number">0</span>;\n        <span class="keyword">while</span> (!StackIsEmpty(s)) {\n            e = StackPeak(s);\n            StackPop(s);\n            printf (<span class="string">"u = %d, v = %d, w = %d\\n"</span>, e->u, e->v, *(int *)(e->w));\n            sum += *(int *)(e->w);\n        }\n        printf(<span class="string">"sum = %d\\n"</span>, sum);\n        StackDestroy(s);\n        GraphDestroy(g);\n    }\n    <span class="keyword">return</span> <span class="number">0</span>;\n}'},139:function(e,t,n){var a=n(47);"string"==typeof a&&(a=[[e.id,a,""]]);n(6)(a,{})},155:function(e,t,n){function a(e){return"translate("+E.nodes[e].x+","+E.nodes[e].y+")"}function s(){function e(e){return e.i}function t(e){return a(e.i)}function n(e){return(i.indexOf(e.w)+1)/i.length*A}function s(e,t){return k.pns[t]&&k.pns[t].out===!0}var r=k.pns.filter(function(e){return!isNaN(e.w)&&e.out!==!0}),i=S.set(r.map(function(e){return e.w})).values().map(parseFloat).sort(S.descending);gnodes.selectAll("path.inq").data(r,e).enter().append("path").attr("class","inq").attr("d",function(e){return M({endAngle:0})}).attr("transform",t).each(function(e){this._current={endAngle:0}}),gnodes.selectAll("path.inq").data(r,e).transition().duration(_).attr("transform",t).attrTween("d",function(e,t){var a=S.interpolate(this._current,{endAngle:n(e,t)});return this._current=a(0),function(e){return M(a(e))}}),gnodes.selectAll("path.inq").data(r,e).exit().remove(),gnodes.selectAll("circle.node").classed("visited",s),x.selectAll("text.node").classed("visited",s),gprimtext.selectAll("text.dist").data(k.pns,e).enter().append("text").attr("class","dist").attr("transform",t),gprimtext.selectAll("text.dist").data(k.pns,e).attr("transform",t).text(function(e){return e.w===k.neg?"=0":e.w===k.pos?"+∞":"="+e.w}),gprimtext.selectAll("text.dist").data(k.pns,e).exit().remove(),gnodes.selectAll("circle.node").classed("highlighted",function(e,t){return t===k.hl[0]})}function r(e){return e.u+"-"+e.v}function i(e,t,n){return n===!0?t.u===e.source.index&&t.v===e.target.index:n===!1?t.v===e.source.index&&t.u===e.target.index:t.u===e.source.index&&t.v===e.target.index||t.v===e.source.index&&t.u===e.target.index}function o(e){var t=E.edges.filter(function(t){return i(t,e)})[0];return{source:t.source.index===e.u?t.source:t.target,target:t.target.index===e.v?t.target:t.source,curve:t.curve}}function c(e,t){var n=Math.PI*t/180;return{x:e.x*Math.cos(n)+e.y*Math.sin(n),y:e.x*-Math.sin(n)+e.y*Math.cos(n)}}function l(e){return{x:-e.x,y:-e.y}}function p(e,t){return{x:e.x-t.x,y:e.y-t.y}}function u(e){return function(t){var n=o(t),a=n.source.x-n.target.x,s=n.target.y-n.source.y,r=Math.sqrt(a*a+s*s),i="exit"===e?S.interpolate(n.target,n.source):S.interpolate(n.source,n.target),u=n.source;if(n.curve){var d="exit"===e?S.interpolate(0,30):S.interpolate(30,0);return function(e){var t=d(e),n=p(c(p(i(e),u),t),l(u));return"M"+u.x+","+u.y+"A"+r+","+r+" 0 0,1 "+n.x+","+n.y}}return function(e){var t=i(e);return"M"+u.x+","+u.y+"L"+t.x+","+t.y}}}function d(e){var t=gedges.classed("directional")?!0:void 0;return k.se.concat(k.pns.filter(function(e){return e.w!==k.neg&&e.out!==!0}).map(function(e){return e.e})).some(function(n){return n&&i(e,n,t)})}function h(e){return gedges.classed("directional")?!1:k.se.concat(k.pns.filter(function(e){return e.w!==k.neg&&e.out!==!0}).map(function(e){return e.e})).some(function(t){return t&&i(e,t,!1)})}function f(){gedges.selectAll("path.edge").classed("painter-selected",d).classed("rev-dir",h).classed("highlighted",function(e){var t=gedges.classed("directional")?!0:void 0;return k.hle.some(function(n){return n&&i(e,n,t)})}),gedges.selectAll("path.ine").data(k.ine,r).enter().insert("path",":first-child").attr("class","ine").transition().duration(_).attrTween("d",u("update")),gedges.selectAll("path.ine").data(k.ine,r).exit().transition().duration(_).attrTween("d",u("exit")).remove()}function m(e,t,n){k=e,_=t,b=n}function g(e,t,n){m(e,t,n),s(),f()}function y(e){E=e,w=S.select("g.base"),x=S.select("g.text"),gnodes=S.select("g.nodes"),gedges=S.select("g.edges"),S.selectAll("g.prim").remove(),gprimtext=x.append("g").attr("class","prim").attr("transform","translate(15,-15)")}function v(){gnodes.selectAll("path.inq").remove(),gedges.selectAll("path.edge").attr("class","edge"),gedges.selectAll("path.ine").remove(),gnodes.selectAll("circle.node").attr("class","node"),x.selectAll("text.node").attr("class","node"),gprimtext.remove()}var w,x,k,_,b,E,S=n(4),L=(n(9),15),A=2*Math.PI,M=S.svg.arc().innerRadius(0).outerRadius(L).startAngle(0);e.exports={init:y,render:g,clear:v}}});