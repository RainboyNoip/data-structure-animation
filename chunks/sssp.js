webpackJsonpdsa([2],{1:function(e,n,t){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "./util.h"</span>\n\nvoid* SafeMalloc(size_t size) {\n    void* m;\n    <span class="keyword">if</span> ((m = malloc(size))) {\n        <span class="keyword">return</span> m;\n    } <span class="keyword">else</span> {\n        printf(<span class="string">"memory overflow\\n"</span>);\n        <span class="keyword">exit</span>(-<span class="number">1</span>);\n        <span class="keyword">return</span> <span class="number">0</span>;\n    }\n}\n\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">// }</span>\n    memcpy(a, b, size);\n}\n\nvoid MemorySwap(void *a, void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// char t;</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     t = *(char *)a;</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">//     *((char *)b + i) = t;</span>\n    <span class="comment">// }</span>\n    void *t = SafeMalloc(size);\n    memcpy(t, a, size);\n    memcpy(a, b, size);\n    memcpy(b, t, size);\n}\n\nvoid MemoryClear(void *a, size_t size) {\n    memset(a, <span class="number">0</span>, size);\n}\n\nvoid *MemoryAddress(void *a, int i, size_t size) {\n    <span class="keyword">return</span> (char *)a + i*size;\n}'},2:function(e,n,t){e.exports='<span class="comment">#ifndef UTIL_H</span>\n<span class="comment">#define UTIL_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\nvoid * SafeMalloc(size_t size);\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size);\nvoid MemorySwap(void *a, void *b, size_t size);\nvoid MemoryClear(void *a, size_t size);\n\n<span class="comment">#endif</span>'},10:function(e,n,t){n=e.exports=t(8)(),n.push([e.id,"circle.node{fill:#ccc;stroke:#000;stroke-width:1.5px}circle.node.painter-selected{fill:#000}circle.node.highlighted{stroke-dasharray:10 2;-webkit-animation:dash .4s linear infinite;animation:dash .4s linear infinite}text.edge,text.node{fill:#000;font:20px sans-serif;pointer-events:none;text-anchor:middle;text-shadow:0 1px 0 #fff,1px 0 0 #fff,0 -1px 0 #fff,-1px 0 0 #fff}path.drag,path.edge{fill:none;stroke:#000;stroke-width:4px}path.edge.painter-selected{stroke-dasharray:10 2;-webkit-animation:dash .4s linear infinite;animation:dash .4s linear infinite}path.edge.painter-selected.rev-dir{-webkit-animation-direction:reverse;animation-direction:reverse}path.edge.painter-selected.rev-dir.sam-dir{-webkit-animation-direction:alternate;animation-direction:alternate}@-webkit-keyframes dash{from{stroke-dashoffset:12}to{stroke-dashoffset:0}}@keyframes dash{from{stroke-dashoffset:12}to{stroke-dashoffset:0}}",""])},11:function(e,n,t){e.exports='<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./graph.h"</span>\n\ngraph* GraphCreate(int n, size_t w_size) {\n    int i;\n    <span class="keyword">if</span> (n == <span class="number">0</span>) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    graph *g = SafeMalloc(sizeof(graph));\n    g->n = n;\n    g->w_size = w_size;\n    g->adja = SafeMalloc(n*(sizeof(graph_edge *)));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) {\n        g->adja[i] = SafeMalloc(sizeof(graph_edge));\n        g->adja[i]->next = <span class="keyword">NULL</span>;\n        g->adja[i]->w = <span class="keyword">NULL</span>;\n    }\n    <span class="keyword">return</span> g;\n}\n\nvoid GraphDestroy(graph *g) {\n    int i;\n    graph_edge *p, *e;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        e = g->adja[i];\n        <span class="keyword">while</span> (e != <span class="keyword">NULL</span>) {\n            p = e->next;\n            <span class="keyword">if</span> (e->w != <span class="keyword">NULL</span>) {\n                free(e->w);\n            }\n            free(e);\n            e = p;\n        }\n    }\n    free(g->adja);\n    free(g);\n}\n\nint GraphNodeValid(graph *g, int u) {\n    <span class="keyword">return</span> <span class="number">0</span> &lt;= u &amp;&amp; u &lt; g->n ? <span class="number">1</span> : <span class="number">0</span>;\n}\n\ngraph_edge* _GraphNewEdge(int u, int v, void *w, size_t w_size) {\n    graph_edge *e = SafeMalloc(sizeof(graph_edge));\n    e->u = u;\n    e->v = v;\n    e->w = SafeMalloc(w_size);\n    MemoryCopy(e->w, w, w_size);\n    <span class="keyword">return</span> e;\n}\n\ngraph_edge* GraphInsert(graph *g, int u, int v, void *w) {\n    graph_edge *e;\n    <span class="keyword">if</span> (!GraphNodeValid(g,u) || !GraphNodeValid(g,v)) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    e = _GraphNewEdge(u,v,w,g->w_size);\n    e->next = g->adja[u]->next;\n    g->adja[u]->next = e;\n    <span class="keyword">return</span> e;\n}'},12:function(e,n,t){e.exports='<span class="comment">#ifndef GRAPH_H</span>\n<span class="comment">#define GRAPH_H</span>\n<span class="comment">#include &lt;stddef.h></span>\n\ntypedef struct graph_edge {\n  int u;\n  int v;\n  void *w;\n  struct graph_edge *next;\n} graph_edge;\n\ntypedef struct graph {\n  int n;\n  size_t w_size;\n  graph_edge **adja;\n} graph;\n\ngraph* GraphCreate(int n, size_t w_size);\nvoid GraphDestroy(graph *g);\ngraph_edge* GraphInsert(graph *g, int u, int v, void *w);\ngraph_edge* GraphDelete(graph *g, int u, int v);\nint GraphNodeValid(graph *g, int u);\n\n<span class="comment">#endif</span>'},13:function(e,n,t){e.exports='<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./min-heap.h"</span>\n\nmin_heap* MinHeapCreate(int n, size_t item_size, int (*CompFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*)) {\n    int i;\n    min_heap* h = (min_heap*)SafeMalloc(sizeof(min_heap));\n    h-><span class="keyword">array</span> = SafeMalloc(n * sizeof(min_heap_pair));\n    h->capacity = n;\n    h->size = <span class="number">0</span>;\n    h->item_size = item_size;\n    h->Compare = CompFn;\n    h->map = SafeMalloc(n*sizeof(int));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) {\n        h-><span class="keyword">array</span>[i].item = <span class="keyword">NULL</span>;\n        h->map[i] = -<span class="number">1</span>;\n    }\n    <span class="keyword">return</span> h;\n}\n\nvoid MinHeapDestroy(min_heap *h) {\n    int i;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; h->capacity; ++i) {\n        <span class="keyword">if</span> (h-><span class="keyword">array</span>[i].item != <span class="keyword">NULL</span>) {\n            free(h-><span class="keyword">array</span>[i].item);\n        }\n    }\n    free(h-><span class="keyword">array</span>);\n    free(h->map);\n    free(h);\n}\n\nint _P(int x) {\n    <span class="keyword">return</span> x == <span class="number">0</span> ? <span class="number">0</span> : (x-<span class="number">1</span>)/<span class="number">2</span>;\n}\nint _L(int x) {\n    <span class="keyword">return</span> x*<span class="number">2</span>+<span class="number">1</span>;\n}\nint _R(int x) {\n    <span class="keyword">return</span> x*<span class="number">2</span>+<span class="number">2</span>;\n}\nvoid _Exchange(min_heap* h, int i, int j) {\n    min_heap_pair tmp;\n    tmp = h-><span class="keyword">array</span>[i];\n    h-><span class="keyword">array</span>[i] = h-><span class="keyword">array</span>[j];\n    h-><span class="keyword">array</span>[j] = tmp;\n    h->map[h-><span class="keyword">array</span>[i].key] = i;\n    h->map[h-><span class="keyword">array</span>[j].key] = j;\n}\n\nvoid _Swim(min_heap *h, int x) {\n    <span class="keyword">while</span> (x != <span class="number">0</span> &amp;&amp; h->Compare(h-><span class="keyword">array</span>[x].item, h-><span class="keyword">array</span>[_P(x)].item) &lt; <span class="number">0</span>) {\n        _Exchange(h, x, _P(x));\n        x = _P(x);\n    }\n}\n\nvoid _Sink(min_heap *h, int x) {\n    int y = -<span class="number">1</span>;\n    <span class="keyword">while</span> (x != y) {\n        y = x;\n        <span class="keyword">if</span> (_L(x) &lt; h->size &amp;&amp; h->Compare(h-><span class="keyword">array</span>[_L(x)].item, h-><span class="keyword">array</span>[x].item) &lt; <span class="number">0</span>) {\n            y = _L(x);\n        }\n        <span class="keyword">if</span> (_R(x) &lt; h->size &amp;&amp; h->Compare(h-><span class="keyword">array</span>[_R(x)].item, h-><span class="keyword">array</span>[y].item) &lt; <span class="number">0</span>) {\n            y = _R(x);\n        }\n        <span class="keyword">if</span> (y != x) {\n            _Exchange(h, x, y);\n            x = y;\n            y = -<span class="number">1</span>;\n        }\n    }\n}\n\nvoid MinHeapInsert(min_heap* h, void* item, int id) {\n    int x = h->size;\n    <span class="keyword">if</span> (x == h->capacity) {\n        <span class="keyword">return</span>;\n    }\n    h-><span class="keyword">array</span>[x].key = id;\n    h->map[id] = x;\n    <span class="keyword">if</span> (h-><span class="keyword">array</span>[x].item == <span class="keyword">NULL</span>) {\n        h-><span class="keyword">array</span>[x].item = SafeMalloc(h->item_size);\n    }\n    MemoryCopy(h-><span class="keyword">array</span>[x].item, item, h->item_size);\n    h->size++;\n    _Swim(h, x);\n}\n\nvoid* MinHeapPop(min_heap* h) {\n    void* item = SafeMalloc(h->item_size);\n    <span class="keyword">if</span> (h->size == <span class="number">0</span>) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    MemoryCopy(item, h-><span class="keyword">array</span>[<span class="number">0</span>].item, h->item_size);\n    h->map[h-><span class="keyword">array</span>[<span class="number">0</span>].key] = -<span class="number">1</span>;\n    MemoryCopy(h-><span class="keyword">array</span>[<span class="number">0</span>].item, h-><span class="keyword">array</span>[h->size-<span class="number">1</span>].item, h->item_size);\n    h-><span class="keyword">array</span>[<span class="number">0</span>].key = h-><span class="keyword">array</span>[h->size-<span class="number">1</span>].key;\n    h->map[h-><span class="keyword">array</span>[<span class="number">0</span>].key] = <span class="number">0</span>;\n    free(h-><span class="keyword">array</span>[h->size-<span class="number">1</span>].item);\n    h-><span class="keyword">array</span>[h->size-<span class="number">1</span>].item = <span class="keyword">NULL</span>;\n    h->size--;\n    _Sink(h, <span class="number">0</span>);\n    <span class="keyword">return</span> item;\n}\n\nvoid *MinHeapUpdate(min_heap *h, void *item, int id) {\n    int i;\n    int rc;\n    <span class="keyword">if</span> (id &lt; <span class="number">0</span> || id >= h->capacity) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    i = h->map[id];\n    rc = h->Compare(h-><span class="keyword">array</span>[i].item, item);\n    MemoryCopy(h-><span class="keyword">array</span>[i].item, item, h->item_size);\n    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) {\n        _Sink(h, i);\n        <span class="keyword">return</span> item;\n    } <span class="keyword">else</span> <span class="keyword">if</span> (rc > <span class="number">0</span>) {\n        _Swim(h, i);\n        <span class="keyword">return</span> item;\n    }\n    <span class="keyword">return</span> <span class="keyword">NULL</span>;\n}'},14:function(e,n,t){e.exports='<span class="comment">#ifndef MIN_HEAP_H</span>\n<span class="comment">#define MIN_HEAP_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\ntypedef struct min_heap_pair {\n    void *item;\n    int key;\n} min_heap_pair;\n\ntypedef struct min_heap {\n    int size;\n    int capacity;\n    size_t item_size;\n    min_heap_pair* <span class="keyword">array</span>;\n    int (*Compare)(<span class="keyword">const</span> void* a, <span class="keyword">const</span> void* b);\n    int* map;\n} min_heap;\n\nmin_heap* MinHeapCreate(int n, size_t item_size, int (*CompFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*));\nvoid MinHeapInsert(min_heap* h, void* item, int id);\nvoid* MinHeapPop(min_heap* h);\nvoid MinHeapDestroy(min_heap* h);\nvoid *MinHeapUpdate(min_heap *h, void *item, int id);\n\n<span class="comment">#endif</span>'},19:function(e,n,t){var s=t(10);"string"==typeof s&&(s=[[e.id,s,""]]);t(9)(s,{})},20:function(e,n,t){function s(e){this.array=[],this.cf=e,this.map=[]}s.prototype.p=function(e){return 0==e?0:Math.floor((e-1)/2)},s.prototype.l=function(e){return 2*e+1},s.prototype.r=function(e){return 2*e+2},s.prototype.ex=function(e,n){var t=this.array[e];this.array[e]=this.array[n],this.array[n]=t,this.map[this.array[e].k]=e,this.map[this.array[n].k]=n},s.prototype.swim=function(e){for(;0!=e&&this.cf(this.array[e].v,this.array[this.p(e)].v)<0;)this.ex(e,this.p(e)),e=this.p(e)},s.prototype.sink=function(e){for(var n=-1;e!==n;)n=e,void 0!==this.array[this.l(e)]&&this.cf(this.array[this.l(e)].v,this.array[e].v)<0&&(n=this.l(e)),void 0!==this.array[this.r(e)]&&this.cf(this.array[this.r(e)].v,this.array[n].v)<0&&(n=this.r(e)),n!=e&&(this.ex(e,n),e=n,n=-1)},s.prototype.insert=function(e,n){this.array.push({v:e,k:n}),this.map[n]=this.array.length-1,this.swim(this.array.length-1)},s.prototype.pop=function(){if(0!==this.array.length){var e=this.array[0];return this.ex(0,this.array.length-1),this.array.pop(),this.map[e.k]=void 0,this.sink(0),e.v}},s.prototype.update=function(e,n){if(!(0>n||n>=this.array.length)){var t=this.map[n],s=this.cf(this.array[t].v,e);this.array[t].v=e,0>s?this.sink(t):s>0&&this.swim(t)}},s.prototype.forceUpdate=function(e){var n=this.map[e];this.sink(n),this.swim(n)},e.exports=s},21:function(e,n,t){function s(e){ce=!1,Q=e.container||document.body,U=T.select(e.container).append("svg").node(),q=e.weighted||!1,N=e.directional||!1,R=e.width||U.clientWidth||e.container.clientWidth,O=e.height||U.clientHeight||e.container.clientHeight,oe=e.offsetLeft||0,ie=e.offsetTop||0,W.nodes=e.nodes||T.range(e.n||5).map(function(){return{}}),W.edges=(e.edges||T.range(5).map(function(e){return{u:e,v:(e+1)%5}})).map(function(e){return{source:W.nodes[e.u],target:W.nodes[e.v],val:e.w,reflexive:e.reflexive}}),j=void 0,B=e._onSelected||void 0,_onLoad=e._onLoad||void 0,ae=void 0,re=!1,T.select(U).call(se).on("dblclick.zoom",null).on("dblclick.svg",D);var n=T.select(U).append("defs");return n.append("marker").attr("id","arrow-end").attr("viewBox","0 -5 10 10").attr("refX",7).attr("refY",0).attr("markerWidth",ee).attr("markerHeight",ee).attr("orient","auto").append("path").attr("d","M0,-5L10,0L0,5"),n.append("marker").attr("id","arrow-start").attr("viewBox","0 -5 10 10").attr("refX",3).attr("refY",0).attr("markerWidth",ee).attr("markerHeight",ee).attr("orient","auto").append("path").attr("d","M10,-5L0,0L10,5"),G=T.select(U).append("g").attr("class","svg-entry"),F=G.append("g").attr("class","base"),$=F.append("g").attr("class","edges").classed("directional",N).classed("weighted",q),H=F.append("g").attr("class","nodes"),Y=G.append("g").attr("class","text").attr("transform","translate(0,7)"),$.append("path").attr("class","drag").attr("marker-end","url(#arrow-end)").style("display","none"),T.select(window).on("keydown.window",E),ne.nodes(W.nodes).links(W.edges).size([R,O]),d(),M(!1),ne.on("end",function(){M(),ne.on("end",null),_onLoad&&_onLoad()}),e.nowait&&(u(),ne.on("end")()),this}function a(e,n){var t=e.x-n.x,s=e.y-n.y;return K*K>=t*t+s*s}function r(e,n){var t=Math.PI*n/180;return{x:e.x*Math.cos(t)+e.y*Math.sin(t),y:e.x*-Math.sin(t)+e.y*Math.cos(t)}}function i(e){return"translate("+e.x+","+e.y+")"}function o(e){return{x:-e.x,y:-e.y}}function c(e,n){return{x:e.x-n.x,y:e.y-n.y}}function p(e){return void 0===e.val?"":e.val}function l(e){var n=e.target.x-e.source.x,t=e.target.y-e.source.y,s=Math.sqrt(n*n+t*t),i=T.interpolate(e.source,e.target)(K/s),p=T.interpolate(e.target,e.source)(K/s),l=T.interpolate(30,0)(K/s);if(N&&q){var u=W.edges.filter(function(n){return n.target===e.source&&(n.source===e.target||a(e.target,n.source))});return u.length>0?(e.curve=!0,i=c(r(c(i,e.source),l),o(e.source)),p=c(r(c(p,e.target),-l),o(e.target)),"M"+i.x+","+i.y+"A"+s+","+s+" 0 0,1 "+p.x+","+p.y):(e.curve=!1,"M"+i.x+","+i.y+"L"+p.x+","+p.y)}return e.curve=!1,"M"+i.x+","+i.y+"L"+p.x+","+p.y}function u(){H.selectAll(".node").data(W.nodes).classed("painter-selected",function(e){return e===j}).attr("transform",i),Y.selectAll(".node").data(W.nodes).attr("transform",i).text(function(e,n){return n}),$.selectAll(".edge").data(W.edges).classed("painter-selected",function(e){return e===j}).attr("marker-end",N?"url(#arrow-end)":null).attr("marker-start",N&&q===!1?function(e){return e.reflexive?"url(#arrow-start)":null}:null).attr("d",l),q&&($.selectAll(".edge").each(function(e){var n=this.getPointAtLength(this.getTotalLength()/2);e.x=n.x,e.y=n.y}),Y.selectAll(".edge").data(W.edges).attr("transform",i).text(p))}function d(){H.selectAll(".node").data(W.nodes).enter().append("circle").attr("class","node").attr("r",K).on("dblclick.node",f).call(te).on("click.select",x).on("mousedown.node",y).on("mouseup.node",w),H.selectAll(".node").data(W.nodes).exit().remove(),Y.selectAll(".node").data(W.nodes).enter().append("text").attr("class","node"),Y.selectAll(".node").data(W.nodes).exit().remove(),$.selectAll(".edge").data(W.edges).enter().append("path").attr("class","edge").on("click.select",x),$.selectAll(".edge").data(W.edges).exit().remove(),q?(Y.selectAll(".edge").data(W.edges).enter().append("text").attr("class","edge"),Y.selectAll(".edge").data(W.edges).exit().remove()):Y.selectAll(".edge").remove(),ne.start()}function h(){R=U.clientWidth||Q.clientWidth,O=U.clientHeight||Q.clientHeight,ne.size([R,O]).resume()}function f(e){T.event.stopPropagation(),T.select(this).classed("fixed",e.fixed=!1),ne.resume()}function m(e){e.fixed|=2}function g(e){ae&&(re?(T.select(this).classed("fixed",e.fixed=!0),e.px=T.event.x||T.event.clientX,e.py=T.event.y||T.event.clientY,ne.resume()):a(T.event,e)===!1?$.select("path.drag").datum({source:e,target:{x:T.event.x||T.event.clientX,y:T.event.y||T.event.clientY}}).attr("d",l).style("display",null):$.select("path.drag").style("display","none"))}function v(e){e.fixed&=-7,$.select("path.drag").style("display","none")}function y(e){(T.event.ctrlKey===!1||void 0===T.event.ctrlKey)&&(T.event.stopPropagation(),ae=e,re=T.event.shiftKey?!0:!1)}function w(e){if(ae&&ae!==e){var n={source:ae,target:e};k(n),d()}ae=void 0,re=!1}function x(e,n){j=j===e?void 0:e,n===!0&&(j=e),j&&B&&B(),ne.resume()}function k(e){var n;N===!1?(n=W.edges.filter(function(n){return n.source===e.source&&n.target===e.target||n.target===e.source&&n.source===e.target}),n.length>0?e=n[0]:W.edges.push(e)):q?(n=W.edges.filter(function(n){return n.source===e.source&&n.target===e.target}),n.length>0?e=n[0]:W.edges.push(e)):(n=W.edges.filter(function(n){return n.source===e.source&&n.target===e.target||n.target===e.source&&n.source===e.target}),n.length>0?(n[0].source===e.target&&(n[0].reflexive=!0),e=n[0]):W.edges.push(e)),x(e,!0)}function _(){var e=void 0===j||void 0===j.val?"数字":j.val;return prompt("权值",e)}function b(e){var n=e();return""===n?void delete j.val:(n=parseFloat(n),isNaN(n)||j.val===n?void 0:(j.val=n,d(),this))}function E(){j&&(8===T.event.keyCode?(T.event.preventDefault(),S()):13===T.event.keyCode&&q&&b(_))}function S(){var e=W.nodes.indexOf(j);return-1!==e?(W.nodes.splice(e,1),W.edges.filter(function(e){return e.source===j||e.target===j}).forEach(function(e){W.edges.splice(W.edges.indexOf(e),1)})):(e=W.edges.indexOf(j),-1!=e&&W.edges.splice(W.edges.indexOf(j),1)),j=void 0,d(),this}function L(){X=T.event.translate,J=T.event.scale,G.attr("transform","translate("+T.event.translate+")scale("+T.event.scale+")")}function A(){var e=document.documentElement;return{left:(window.pageXOffset||e.scrollLeft)-(e.clientLeft||0),top:(window.pageYOffset||e.scrollTop)-(e.clientTop||0)}}function D(){if(T.event.target===this){var e=T.event.x||T.event.clientX||T.event.clientX,n=T.event.y||T.event.clientY||T.event.clientY,t=A();e+=t.left-oe,n+=t.top-ie;var s={x:(e-X[0])/J,y:(n-X[1])/J};W.nodes.push(s),x(s),d()}}function M(e){return j&&($.select(".painter-selected").classed("painter-selected",!1),H.select(".painter-selected").classed("painter-selected",!1),j=void 0),q&&(W.edges.forEach(function(e){void 0===e.val&&(e.val=1)}),u()),e!==!1&&ne.stop(),T.select(window).on("resize",null).on("keydown.window",null),T.select(U).on("dblclick.svg",null),H.selectAll("circle.node").on("dblclick.node",null).on("dragstart",null).on("drag",null).on("dragend",null).on("click.select",null).on("mousedown.node",null).on("mouseup.node",null),$.selectAll("path.edge").on("click.select",null),this}function P(e,n){function t(e,n){return e.source===n.target&&e.target===n.source}if(N!==e||q!==n){pd=N,N=e,q=n;var s=[];return W.edges.forEach(function(e){N?q?((pd===!1||e.reflexive)&&s.push({source:e.target,target:e.source,val:e.val}),delete e.reflexive,s.push(e)):(delete e.reflexive,s.some(function(n){return t(e,n)})===!1&&((pd===!1||W.edges.some(function(n){return t(e,n)})===!0)&&(e.reflexive=!0),s.push(e))):s.some(function(n){return t(e,n)})===!1&&(delete e.reflexive,s.push(e))}),W.edges=s,$.classed("directional",N).classed("weighted",q),d(),this}}function C(){ne.start(),T.select(window).on("resize",h).on("keydown.window",E),T.select(U).on("dblclick.svg",D),H.selectAll("circle.node").on("dblclick.node",f).call(te).on("click.select",x).on("mousedown.node",y).on("mouseup.node",w),$.selectAll("path.edge").on("click.select",x)}function z(){W.nodes.length=0,W.edges.length=0,d()}function I(){}var T=t(3);t(19);var U,q,N,R,O,j,B,G,F,$,H,Y,Q,W={},X=[0,0],J=1,K=15,V=150,Z=-600,ee=3,ne=T.layout.force().linkDistance(V).charge(Z).on("tick",u),te=T.behavior.drag().origin(function(e){return e}).on("dragstart",m).on("drag",g).on("dragend",v),se=T.behavior.zoom().scaleExtent([.1,10]).on("zoom",L),ae=void 0,re=!1,ie=0,oe=0,ce=!1;e.exports={stop:M,convert:P,weighSelected:b,deleteSelected:S,init:s,restart:C,clear:z,random:I,directional:function(){return N},weighted:function(){return q},raw:function(){return W},data:function(){var e=W.edges.map(function(e){return{u:e.source.index,v:e.target.index,w:e.val}});return N||(e=e.concat(W.edges.map(function(e){return{u:e.target.index,v:e.source.index,w:e.val}}))),N&&!q&&(e=e.concat(W.edges.filter(function(e){return e.reflexive}).map(function(e){return{u:e.target.index,v:e.source.index,w:e.val}}))),{weighted:q,directional:N,n:W.nodes.length,e:e}}}},35:function(e,n,t){function s(e,n){return e===x||n===k?e===n?0:-1:e===k||n===x?e===n?0:1:e-n}function a(e,n){return s(e.w,n.w)}function r(e,n){return e===k||n===k?k:e===x||n===x?e===x?n:e:e+n}function i(e,n){void 0===n?g[e].pop():g[e].push(n)}function o(e){return e>=0&&e<y.n}function c(e,n){var t,c,p,u,d,h,f;if(l(56,1),!o(e))return void l(57);for(p=new w(a),f=[],d=[],g.pns=d,l(65,1),t=0;t<y.n;++t)d[t]={i:t},d[t].w=t==e?x:k,d[t].e=void 0,p.insert(d[t],t);for(t=0;l(71,1),t<y.n;++t){if(l(72),h=p.pop(),i("hl",h.i),d[h.i].out=!0,h.e&&i("ine",h.e),l(73,1),t===y.n-1){i("hl"),l(74);break}for(u=0;l(76,1),i("se"),i("hle"),u<y.e[h.i].length;u++){var m=y.e[h.i][u];l(77,1),c=r(h.w,m.w),i("se",m),i("hle",m),l(78,1),s(d[m.v].w,c)>0&&(i("ine",m),d[m.v].w=c,d[m.v].e=m,l(84,1),p.forceUpdate(m.v),i("ine"))}i("hl")}return f}function p(e){y.n=e.n,y.e=[];for(var n=0;n<y.n;++n)y.e.push([]);e.e.forEach(function(e){y.e[e.u].push(e)})}function l(e,n,t){1===n&&(lastStatus=g.clone()),f.push({status:lastStatus,line:e,animation:t,id:m}),m++}function u(){0===f.length?0:f[f.length-1].line;l(150,1)}function d(e){return e=parseInt(e),isNaN(e)?0:e}var h=t(6),f=[],m=0,g={},v=0,y={},w=t(20),x="-",k="+";g.clone=function(){return{neg:x,pos:k,ine:h(this.ine)||[],se:h(this.se)||[],hl:h(this.hl)||[],hle:h(this.hle)||[],pns:h(this.pns)||[]}},g.init=function(e){this.se=[],this.ine=[],this.pns=[],this.hl=[],this.hle=[]},lastStatus={},e.exports={initialize:function(e){return f=[],m=0,e&&(v=0),g.init(e),lastStatus=g.clone(),this},dijkstra:c,run:function(e,n){return p(n.g),this.initialize()[e](d(n.src)),u(),{frames:f,others:{}}}}},45:function(e,n,t){n=e.exports=t(8)(),n.push([e.id,"path.ine{stroke-width:20px;stroke:#00bfff;fill:none;stroke-opacity:.5}.node.visited{fill:#00bfff}path.edge.highlighted{stroke-width:6px}",""])},64:function(e,n,t){t(122);var s=t(4),a=t(5),r=t(21),i=t(137);e.exports=s.createClass({displayName:"module.exports",getInitialState:function(){return{painting:!1,loaded:!1,text:""}},componentDidMount:function(){r.init({container:this.refs.svg.getDOMNode(),offsetTop:document.querySelector(".dsa-app").offsetTop+55,offsetLeft:document.querySelector(".dsa-app").offsetLeft+80,_onLoad:this._onLoad,nodes:[{x:50,y:150,fixed:!0},{x:150,y:250,fixed:!0},{x:150,y:50,fixed:!0},{x:300,y:250,fixed:!0},{x:300,y:50,fixed:!0}],edges:[{u:0,v:1,w:5},{u:0,v:2,w:3},{u:1,v:2,w:1},{u:1,v:3,w:6},{u:1,v:4,w:4},{u:2,v:1,w:2},{u:2,v:4,w:6},{u:3,v:0,w:3},{u:3,v:4,w:7},{u:4,v:3,w:2}],directional:!0,weighted:!0,nowait:!0}),i.init(r.raw())},componentDidUpdate:function(e){this.props!==e&&void 0!==this.props.frame&&this.props.frame&&i.render(this.props.frame.status,this.props.delay,this.props.others)},render:function(){return s.createElement("div",{className:"wrapper-code"},s.createElement("div",{className:"list"},this.getInputList()),s.createElement("div",{ref:"svg",className:"scene"}))},_onLoad:function(){this.setState({loaded:!0})},_onPainting:function(){this.state.painting?r.stop():(i.clear(),a.pauseDemo(),a.waitDemo(),r.restart()),this.setState({painting:!this.state.painting})},_onChange:function(e,n){var t={};t[e]=n.target.value,this.setState(t)},_onClick:function(e){i.clear(),i.init(r.raw()),a.runDemo(e,{g:r.data(),src:this.state.text})},_onConvert:function(e,n){r.convert(e,n)},getInputList:function(){return this.state.loaded===!1?s.createElement("input",{className:"cmd-button",readOnly:!0,value:"加载中",title:"加载中"}):this.state.painting?s.createElement("div",null,s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onConvert.bind(this,!1,!0),value:"无向图",title:"无向带权图"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onConvert.bind(this,!0,!0),value:"有向图",title:"有向带权图"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:r.clear,value:"清空",title:"清空"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onPainting,value:"完成",title:"完成"})):s.createElement("div",null,s.createElement("input",{onChange:this._onChange.bind(this,"text"),value:this.state.text,placeholder:"源点"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"dijkstra"),value:"Dijkstra单源最短路径",title:"Dijkstra单源最短路径"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onPainting,value:"编辑图",title:"编辑图"}))}})},105:function(e,n,t){e.exports="CC=gcc\nCFLAGS=-c -Wall\nLDFLAGS=\nSOURCES=test.c ../common/util.c ../common/util.h ../common/graph.c ../common/graph.h ../min-heap/min-heap.c ../min-heap/min-heap.h ../stack/stack.c ../stack/stack.h ./sssp.c ./sssp.h\nOBJECTS=$(SOURCES:.c=.o)\nEXECUTABLE=a.out\n\nall: $(SOURCES) $(EXECUTABLE)\n\n$(EXECUTABLE): $(OBJECTS)\n    $(CC) $(LDFLAGS) $(OBJECTS) -o $@\n\n.cpp.o:\n    $(CC) $(CFLAGS) $&lt; -o $@\n\nclean:\n    rm -rf *.o a.out"},106:function(e,n,t){e.exports='<span class="comment">#include  &lt;stdlib.h></span>\n<span class="comment">#include "../common/graph.h"</span>\n<span class="comment">#include "../min-heap/min-heap.h"</span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "../stack/stack.h"</span>\n\ntypedef struct dijkstra_node {\n    int i;\n    void *w;\n    graph_edge *e;\n} dijkstra_node;\n\nint (*_gGraphEdgeWeightCompare)(<span class="keyword">const</span> void *, <span class="keyword">const</span> void *);\nvoid (*_gGraphEdgeWeightAdd)(<span class="keyword">const</span> void *, <span class="keyword">const</span> void *, <span class="keyword">const</span> void *);\nint _gNegInfinity = <span class="number">0</span>;\nint _gPosInfinity = <span class="number">0</span>;\n\nint _GraphDijkstraEdgeCompare(<span class="keyword">const</span> void *a, <span class="keyword">const</span> void *b) {\n    <span class="keyword">if</span> (a == &amp;_gNegInfinity || b == &amp;_gPosInfinity) {\n        <span class="keyword">return</span> a == b ? <span class="number">0</span> : -<span class="number">1</span>;\n    } <span class="keyword">else</span> <span class="keyword">if</span> (a == &amp;_gPosInfinity || b == &amp;_gNegInfinity) {\n        <span class="keyword">return</span> a == b ? <span class="number">0</span> : <span class="number">1</span>;\n    }\n    <span class="keyword">return</span> _gGraphEdgeWeightCompare(a, b);\n}\n\nint _GraphDijkstraNodeCompare(<span class="keyword">const</span> void *a, <span class="keyword">const</span> void *b) {\n    <span class="keyword">return</span> _GraphDijkstraEdgeCompare(((dijkstra_node *)a)->w, ((dijkstra_node *)b)->w);\n}\n\n<span class="keyword">const</span> void *_GraphDijkstraWeightAdd(<span class="keyword">const</span> void *a, <span class="keyword">const</span> void *b, <span class="keyword">const</span> void *c) {\n    <span class="keyword">if</span> (a == &amp;_gPosInfinity || b == &amp;_gPosInfinity) {\n        <span class="keyword">return</span> &amp;_gPosInfinity;\n    } <span class="keyword">else</span> <span class="keyword">if</span> (a == &amp;_gNegInfinity || b == &amp;_gNegInfinity) {\n        <span class="keyword">return</span> a == &amp;_gNegInfinity ? b : a;\n    }\n    _gGraphEdgeWeightAdd(a, b, c);\n    <span class="keyword">return</span> c;\n}\n\nstack *GraphDijkstra(\n    graph *g,\n    int src,\n    int dest,\n    int (*CompFn)(<span class="keyword">const</span> void *, <span class="keyword">const</span> void *),\n    void (*AddFn)(<span class="keyword">const</span> void *, <span class="keyword">const</span> void *, <span class="keyword">const</span> void *)\n) {\n    int i;\n    void *w;\n    <span class="keyword">const</span> void *rw;\n    min_heap *mh;\n    graph_edge *e;\n    dijkstra_node *dns;\n    dijkstra_node *dn;\n    stack *s;\n    <span class="keyword">if</span> (!GraphNodeValid(g, src) || !GraphNodeValid(g, dest)) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    w = SafeMalloc(g->w_size);\n    _gGraphEdgeWeightCompare = CompFn;\n    _gGraphEdgeWeightAdd = AddFn;\n    mh = MinHeapCreate(g->n, sizeof(dijkstra_node), _GraphDijkstraNodeCompare);\n    s = StackCreate(g->n, sizeof(graph_edge));\n    dns = SafeMalloc(g->n*sizeof(dijkstra_node));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        dns[i].i = i;\n        dns[i].w = (i == src ? &amp;_gNegInfinity : &amp;_gPosInfinity);\n        dns[i].e = <span class="keyword">NULL</span>;\n        MinHeapInsert(mh, &amp;dns[i], i);\n    }\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        dn = MinHeapPop(mh);\n        <span class="keyword">if</span> (i == g->n-<span class="number">1</span>) {\n          <span class="keyword">break</span>;\n        }\n        <span class="keyword">for</span> (e = g->adja[dn->i]->next; e != <span class="keyword">NULL</span>; e = e->next) {\n            rw = _GraphDijkstraWeightAdd(dn->w, e->w, w);\n            <span class="keyword">if</span> (_GraphDijkstraEdgeCompare(dns[e->v].w, rw) > <span class="number">0</span>) {\n               <span class="keyword">if</span> (dns[e->v].w == &amp;_gPosInfinity) {\n                   dns[e->v].w = SafeMalloc(g->w_size);\n               }\n               MemoryCopy(dns[e->v].w, w, g->w_size);\n               dns[e->v].e = e;\n               MinHeapUpdate(mh, &amp;dns[e->v], e->v);\n            }\n        }\n        free(dn);\n    }\n    i = dest;\n    <span class="keyword">while</span> (i != src) {\n      StackPush(s, dns[i].e);\n      i = dns[i].e->u;\n    }\n    MinHeapDestroy(mh);\n    free(w);\n    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; g->n; ++i) {\n      <span class="keyword">if</span> (dns[i].w != &amp;_gPosInfinity) {\n        free(dns[i].w);\n      }\n    }\n    free(dns);\n    <span class="keyword">return</span> s;\n}';

},107:function(e,n,t){e.exports='<span class="comment">#ifndef DIJKSTRA_H</span>\n<span class="comment">#define DIJKSTRA_H</span>\n\n<span class="comment">#include "../common/graph.h"</span>\n<span class="comment">#include "../stack/stack.h"</span>\n\nstack *GraphDijkstra(\n    graph *g,\n    int src,\n    int dest,\n    int (*CompFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*),\n    void (*AddFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*, <span class="keyword">const</span> void *)\n);\n\n<span class="comment">#endif</span>'},108:function(e,n,t){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/graph.h"</span>\n<span class="comment">#include "./sssp.h"</span>\n<span class="comment">#include "../stack/stack.h"</span>\n\nint Compare(<span class="keyword">const</span> void *a, <span class="keyword">const</span> void *b) {\n    <span class="keyword">return</span> *(int *)a - *(int *)b;\n}\n\nvoid Add(<span class="keyword">const</span> void *a, <span class="keyword">const</span> void *b, <span class="keyword">const</span> void *c) {\n    *(int *)c = *(int *)a + *(int *)b;\n}\n\nint main(int argc, char <span class="keyword">const</span> *argv[])\n{\n    int n, m, i, u, v, w;\n    graph *g;\n    stack *s;\n    graph_edge *e;\n    int sum = <span class="number">0</span>;\n    <span class="keyword">while</span> (scanf(<span class="string">"%d%d"</span>, &amp;n,&amp;m) != EOF) {\n        g = GraphCreate(n, sizeof(int));\n        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++i) {\n            scanf(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);\n            GraphInsert(g, u, v, &amp;w);\n        }\n        s = GraphDijkstra(g, <span class="number">0</span>, n-<span class="number">1</span>, Compare, Add);\n        sum = <span class="number">0</span>;\n        <span class="keyword">while</span> (!StackIsEmpty(s)) {\n            e = StackPeak(s);\n            StackPop(s);\n            printf (<span class="string">"u = %d, v = %d, w = %d\\n"</span>, e->u, e->v, *(int *)(e->w));\n            sum += *(int *)(e->w);\n        }\n        printf(<span class="string">"sum = %d\\n"</span>, sum);\n        StackDestroy(s);\n        GraphDestroy(g);\n    }\n    <span class="keyword">return</span> <span class="number">0</span>;\n}'},122:function(e,n,t){var s=t(45);"string"==typeof s&&(s=[[e.id,s,""]]);t(9)(s,{})},137:function(e,n,t){function s(e){return"translate("+E.nodes[e].x+","+E.nodes[e].y+")"}function a(){function e(e){return e.i}function n(e){return s(e.i)}function t(e){return(i.indexOf(e.w)+1)/i.length*A}function a(e,n){return k.pns[n]&&k.pns[n].out===!0}var r=k.pns.filter(function(e){return!isNaN(e.w)&&e.out!==!0}),i=S.set(r.map(function(e){return e.w})).values().map(parseFloat).sort(S.descending);gnodes.selectAll("path.inq").data(r,e).enter().append("path").attr("class","inq").attr("d",function(e){return D({endAngle:0})}).attr("transform",n).each(function(e){this._current={endAngle:0}}),gnodes.selectAll("path.inq").data(r,e).transition().duration(_).attr("transform",n).attrTween("d",function(e,n){var s=S.interpolate(this._current,{endAngle:t(e,n)});return this._current=s(0),function(e){return D(s(e))}}),gnodes.selectAll("path.inq").data(r,e).exit().remove(),gnodes.selectAll("circle.node").classed("visited",a),x.selectAll("text.node").classed("visited",a),gprimtext.selectAll("text.dist").data(k.pns,e).enter().append("text").attr("class","dist").attr("transform",n),gprimtext.selectAll("text.dist").data(k.pns,e).attr("transform",n).text(function(e){return e.w===k.neg?"=0":e.w===k.pos?"+∞":"="+e.w}),gprimtext.selectAll("text.dist").data(k.pns,e).exit().remove(),gnodes.selectAll("circle.node").classed("highlighted",function(e,n){return n===k.hl[0]})}function r(e){return e.u+"-"+e.v}function i(e,n,t){return t===!0?n.u===e.source.index&&n.v===e.target.index:t===!1?n.v===e.source.index&&n.u===e.target.index:n.u===e.source.index&&n.v===e.target.index||n.v===e.source.index&&n.u===e.target.index}function o(e){var n=E.edges.filter(function(n){return i(n,e)})[0];return{source:n.source.index===e.u?n.source:n.target,target:n.target.index===e.v?n.target:n.source,curve:n.curve}}function c(e,n){var t=Math.PI*n/180;return{x:e.x*Math.cos(t)+e.y*Math.sin(t),y:e.x*-Math.sin(t)+e.y*Math.cos(t)}}function p(e){return{x:-e.x,y:-e.y}}function l(e,n){return{x:e.x-n.x,y:e.y-n.y}}function u(e){return function(n){var t=o(n),s=t.source.x-t.target.x,a=t.target.y-t.source.y,r=Math.sqrt(s*s+a*a),i="exit"===e?S.interpolate(t.target,t.source):S.interpolate(t.source,t.target),u=t.source;if(t.curve){var d="exit"===e?S.interpolate(0,30):S.interpolate(30,0);return function(e){var n=d(e),t=l(c(l(i(e),u),n),p(u));return"M"+u.x+","+u.y+"A"+r+","+r+" 0 0,1 "+t.x+","+t.y}}return function(e){var n=i(e);return"M"+u.x+","+u.y+"L"+n.x+","+n.y}}}function d(e){var n=gedges.classed("directional")?!0:void 0;return k.se.concat(k.pns.filter(function(e){return e.w!==k.neg&&e.out!==!0}).map(function(e){return e.e})).some(function(t){return t&&i(e,t,n)})}function h(e){return gedges.classed("directional")?!1:k.se.concat(k.pns.filter(function(e){return e.w!==k.neg&&e.out!==!0}).map(function(e){return e.e})).some(function(n){return n&&i(e,n,!1)})}function f(){gedges.selectAll("path.edge").classed("painter-selected",d).classed("rev-dir",h).classed("highlighted",function(e){var n=gedges.classed("directional")?!0:void 0;return k.hle.some(function(t){return t&&i(e,t,n)})}),gedges.selectAll("path.ine").data(k.ine,r).enter().insert("path",":first-child").attr("class","ine").transition().duration(_).attrTween("d",u("update")),gedges.selectAll("path.ine").data(k.ine,r).exit().transition().duration(_).attrTween("d",u("exit")).remove()}function m(e,n,t){k=e,_=n,b=t}function g(e,n,t){m(e,n,t),a(),f()}function v(e){E=e,w=S.select("g.base"),x=S.select("g.text"),gnodes=S.select("g.nodes"),gedges=S.select("g.edges"),S.selectAll("g.prim").remove(),gprimtext=x.append("g").attr("class","prim").attr("transform","translate(15,-15)")}function y(){gnodes.selectAll("path.inq").remove(),gedges.selectAll("path.edge").attr("class","edge"),gedges.selectAll("path.ine").remove(),gnodes.selectAll("circle.node").attr("class","node"),x.selectAll("text.node").attr("class","node"),gprimtext.remove()}var w,x,k,_,b,E,S=t(3),L=(t(7),15),A=2*Math.PI,D=S.svg.arc().innerRadius(0).outerRadius(L).startAngle(0);e.exports={init:v,render:g,clear:y}}});