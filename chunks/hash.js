webpackJsonpdsa([12],{2:function(n,e,t){n.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "./util.h"</span>\n\nvoid* SafeMalloc(size_t size) {\n    void* m;\n    <span class="keyword">if</span> ((m = malloc(size))) {\n        <span class="keyword">return</span> m;\n    } <span class="keyword">else</span> {\n        printf(<span class="string">"memory overflow\\n"</span>);\n        <span class="keyword">exit</span>(-<span class="number">1</span>);\n        <span class="keyword">return</span> <span class="number">0</span>;\n    }\n}\n\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">// }</span>\n    memcpy(a, b, size);\n}\n\nvoid MemorySwap(void *a, void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// char t;</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     t = *(char *)a;</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">//     *((char *)b + i) = t;</span>\n    <span class="comment">// }</span>\n    void *t = SafeMalloc(size);\n    memcpy(t, a, size);\n    memcpy(a, b, size);\n    memcpy(b, t, size);\n}\n\nvoid MemoryClear(void *a, size_t size) {\n    memset(a, <span class="number">0</span>, size);\n}\n\nvoid *MemoryAddress(void *a, int i, size_t size) {\n    <span class="keyword">return</span> (char *)a + i*size;\n}'},3:function(n,e,t){n.exports='<span class="comment">#ifndef UTIL_H</span>\n<span class="comment">#define UTIL_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\nvoid * SafeMalloc(size_t size);\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size);\nvoid MemorySwap(void *a, void *b, size_t size);\nvoid MemoryClear(void *a, size_t size);\n\n<span class="comment">#endif</span>'},28:function(n,e,t){function a(n,e){U.occupied[n]=1,U.table[n][0].d=e}function s(n){var e=n,t=U.occupied[n];if(b(16,1),k(n,0),1!==t)return b(17,1),n;for(e=(n+1)%U.n;b(19,1),k(e,0),e!==n;e=(e+1)%U.n)if(t=U.occupied[e],b(21,1),1!==t)return b(22,1),e;return b(25,1),-1}function r(n){g(n),b(29,1);var e=_(n);return v(e),b(30,1),e=s(e),b(31,1),-1!==e?(b(32,1),a(e,n),w(),b(33,1),x(e),n):(b(35,1),x(-1),null)}function o(n){U.occupied[n]=-1}function c(n){g(n),b(45,1);var e=_(n);v(e);var t,a=U.occupied[e];if(b(48,1),k(e,0),0===a)return b(49,1),-1;if(b(51,1),1===a&&n===U.table[e][0].d)return b(52,1),e;for(t=(e+1)%U.n;(b(54,1),k(t,0),t!==e)&&(a=U.occupied[t],b(56,1),0!==a);t=(t+1)%U.n)if(b(59,1),1===a&&n===U.table[t][0].d)return b(60,1),t;return b(63,1),-1}function l(n){b(67,1);var e=c(n);return b(68,1),-1==e?(b(69,1),x(-1),null):(b(71,1),o(e),w(),b(72,1),x(e),n)}function p(n){b(76,1);var e=c(n);return b(77,1),x(e),-1==e?null:n}function d(n){g(n),b(83,1);var e=_(n);v(e);var t=U.table[e];return U.occupied[e]=1,b(86,1),"X"!==t[0].d&&(t.unshift({d:"",id:q++}),w()),b(87,1),b(88,1),b(89,1),t[0].d=n,w(),b(90,1),x(1),n}function u(n){g(n),b(94,1);var e=_(n);v(e);for(var t=U.table[e],a=-1,s=0;b(98,1),k(e,s),s<t.length;++s)if(b(101,1),t[s].d===n){b(102,1),a=s,b(103,1);break}return b(106,1),[e,a]}function h(n){b(110,1);var e=u(n);if(b(112,1),-1===e)return b(113,1),x(e),null;var t=e[0],a=e[1];return b(119,1),f(t,a),b(120,1),x(a),n}function m(n){b(124,1);var e=u(n);return b(125,1),x(e),-1===e?null:n}function f(n,e){U.occupied[n]=U.table[n].length-1>0?1:0,1===U.table[n].length?(U.table[n][0].d="X",U.occupied[n]=0):U.table[n]=U.table[n].slice(0,e).concat(U.table[n].slice(e+1)),w()}function y(n,e){U={},U.table=[],U.n=n,U.occupied=[];for(var t=0;n>t;++t)U.occupied[t]=0,U.table[t]=[{d:"X",id:q++}];U.fn=e,S=new Function("x","return "+e)}function g(n){D.key=n}function v(n){D.pos=n}function k(n,e){D.ptr={i:n,j:e}}function x(n){D.r=n}function w(){L=A(U)}function _(n){return n=S(n)%U.n,0>n&&(n=(n+U.n)%U.n),n=Math.floor(n),isNaN(n)?0:n}function b(n,e,t){1===e&&(lastStatus=D.clone()),M.push({status:lastStatus,line:n,animation:t,id:N}),N++}function E(){0===M.length?0:M[M.length-1].line;b(216,1)}function z(n){return n=parseInt(n),isNaN(n)?0:n}var S,C,L,A=t(6),M=[],N=0,D={},q=0,U={};D.clone=function(){return{ht:L,key:this.key,pos:this.pos,ptr:A(this.ptr),r:this.r}},D.init=function(n){L=A(U),this.key=void 0,this.pos=void 0,this.ptr={},this.r=void 0},lastStatus={},n.exports={getInitialDescriptions:function(){this.initialize(!0);var n=11,e=[1,1];for(i=2;i<n;++i)e.push(e[i-1]+e[i-2]);return this.run("create",{n:"10",f:"x",t:"ho"})},initialize:function(n){return M=[],N=0,n&&(q=0),D.init(n),lastStatus=D.clone(),this},create:function(n){C=n.t,y(z(n.n),n.f),D.init(),b(0,1)},searchhc:p,searchho:m,inserthc:r,insertho:d,deletehc:l,deleteho:h,run:function(n,e){return-1===n.indexOf("create")?(e=z(e),n+=C||"hc",this.initialize()[n](e)):this.initialize(!0)[n](e),E(),{frames:M,others:{}}}}},59:function(n,e,t){var a=t(1);n.exports=a.createClass({displayName:"module.exports",render:function(){var n={display:this.props.show?"block":"none"};return a.createElement("svg",{className:"legend",width:"210",height:"190",style:n},a.createElement("rect",{className:"outline",stroke:"black",x:"0",y:"0",width:"200",height:"160"}),a.createElement("g",{transform:"translate(15,10)"},a.createElement("g",{transform:"translate(0,0)"},a.createElement("rect",{width:"15",height:"15",fill:"green"})),a.createElement("g",{transform:"translate(0,25)"},a.createElement("rect",{width:"15",height:"15",fill:"deepskyblue"})),a.createElement("g",{transform:"translate(0,50)"},a.createElement("rect",{width:"15",height:"15",fill:"red"})),a.createElement("g",{transform:"translate(0,83)"},a.createElement("path",{markerEnd:"url(#arrow)",d:"M0,0L20,0",stroke:"deepskyblue",strokeWidth:"5"})),a.createElement("g",{transform:"translate(0,100)"},a.createElement("rect",{width:"15",height:"15",fill:"coral",stroke:"black"})),a.createElement("g",{transform:"translate(0,125)"},a.createElement("rect",{width:"15",height:"15",fill:"coral"}),a.createElement("text",{x:"4",y:"12",fontSize:"10px",fill:"red"},"X")),a.createElement("g",{transform:"translate(0,14)"},a.createElement("text",{x:"40",y:"0"},"操作成功"),a.createElement("text",{x:"40",y:"25"},"当前输入"),a.createElement("text",{x:"40",y:"50"},"操作失败"),a.createElement("text",{x:"40",y:"75"},"散列函数"),a.createElement("text",{x:"40",y:"100"},"循环指针"),a.createElement("text",{x:"40",y:"125"},"已删除"))))}})},60:function(n,e,t){var a=t(1),s=t(5),r=t(144),i=t(59);n.exports=a.createClass({displayName:"module.exports",getInitialState:function(){return{text:"",fn:"",demo:"insert",help:!0}},componentDidMount:function(){r.init.bind(this)(),s.runDemo("create",{n:"10",f:"x",t:"hc"}),s.runDemo("insert",11,!1)},componentDidUpdate:function(n){this.props!==n&&void 0!==this.props.frame&&r.render(this.props.frame.status,this.props.delay,this.props.others)},render:function(){var n=[{button:{demo:"createhc",onClick:this._onClick.bind(this,"create","hc"),value:"开地址散列"},items:[{onChange:this._onChange.bind(this,"text"),value:this.state.text,placeholder:"大小"},{onChange:this._onChange.bind(this,"fn"),value:this.state.fn,placeholder:"x的函数"}]},{button:{demo:"createho",onClick:this._onClick.bind(this,"create","ho"),value:"链地址散列"},items:[{onChange:this._onChange.bind(this,"text"),value:this.state.text,placeholder:"大小"},{onChange:this._onChange.bind(this,"fn"),value:this.state.fn,placeholder:"x的函数"}]},{button:{demo:"search",onClick:this._onClick.bind(this,"search"),value:"查找"},items:[{onChange:this._onChange.bind(this,"text"),value:this.state.text,placeholder:"数字"}]},{button:{demo:"insert",onClick:this._onClick.bind(this,"insert"),value:"插入"},items:[{onChange:this._onChange.bind(this,"text"),value:this.state.text,placeholder:"数字"}]},{button:{demo:"delete",onClick:this._onClick.bind(this,"delete"),value:"删除"},items:[{onChange:this._onChange.bind(this,"text"),value:this.state.text,placeholder:"数字"}]},{button:{help:this.state.help,onClick:this._onHelp,value:"帮助"}}],e=this;return a.createElement("div",{className:"wrapper-code"},a.createElement("div",{className:"list"},n.map(function(n,t){var s="input-group"+(n.button.help||n.button.demo===e.state.demo?" input-current":""),r=n.items?n.items:[];return a.createElement("div",{key:t,className:s},a.createElement("input",{className:"input-button",readOnly:!0,onClick:n.button.onClick,value:n.button.value,title:n.button.value}),a.createElement("div",null,r.map(function(n,e){return a.createElement("input",{key:e,className:"input-item",onChange:n.onChange,value:n.value,title:n.value,placeholder:n.placeholder})})))})),a.createElement("div",{ref:"svg",className:"scene"}),a.createElement(i,{show:this.state.help}))},_onChange:function(n,e){var t={};t[n]=e.target.value,this.setState(t)},_onClick:function(n,e){this.setState({demo:e?n+e:n}),-1!==n.indexOf("create")?s.runDemo(n,{n:this.state.text,f:this.state.fn,t:e}):s.runDemo(n,this.state.text)},_onHelp:function(){this.setState({help:!this.state.help})}})},89:function(n,e,t){n.exports="CC=gcc\nCFLAGS=-c -Wall\nLDFLAGS=\nSOURCES=test.c hash.c hash.h ../common/util.c ../common/util.h\nOBJECTS=$(SOURCES:.c=.o)\nEXECUTABLE=a.out\n\nall: $(SOURCES) $(EXECUTABLE)\n\n$(EXECUTABLE): $(OBJECTS)\n    $(CC) $(LDFLAGS) $(OBJECTS) -o $@\n\n.cpp.o:\n    $(CC) $(CFLAGS) $&lt; -o $@\n\nclean:\n    rm -rf *.o a.out"},90:function(n,e,t){n.exports='<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "./hash.h"</span>\n<span class="comment">#include "../common/util.h"</span>\n\nvoid _SetTable(hash *ht, int i, void *key) {\n    hash_item *p = ((hash_item **)ht->table)[i];\n    p->item = SafeMalloc(ht->item_size);\n    MemoryCopy(p->item, key, ht->item_size);\n    p->next = p;\n}\n\nint _GetEmptySlot(hash *ht, int i) {\n    int j = i;\n    hash_item *p = ((hash_item **)ht->table)[i];\n    <span class="keyword">if</span> (p->item == <span class="keyword">NULL</span>) {\n        <span class="keyword">return</span> i;\n    }\n    <span class="keyword">for</span> (j = (i+<span class="number">1</span>) % ht->n; j != i; j = (j+<span class="number">1</span>) % ht->n) {\n        p = ((hash_item **)ht->table)[j];\n        <span class="keyword">if</span> (p->item == <span class="keyword">NULL</span>) {\n          <span class="keyword">return</span> j;\n        }\n    }\n    <span class="keyword">return</span> -<span class="number">1</span>;\n}\n\nvoid *HashClosedInsert(hash *ht, void *key) {\n    int i = ht->Hash(ht, key);\n    i = _GetEmptySlot(ht, i);\n    <span class="keyword">if</span> (i != -<span class="number">1</span>) {\n        _SetTable(ht, i, key);\n        <span class="keyword">return</span> key;\n    }\n    <span class="keyword">return</span> <span class="keyword">NULL</span>;\n}\n\nvoid HashClosedDeleteSlot(hash *ht, int i) {\n    hash_item *p = ((hash_item **)ht->table)[i];\n    free(p->item);\n    p->item = <span class="keyword">NULL</span>;\n}\n\nint HashGetSlot(hash *ht, void *key) {\n    int i = ht->Hash(ht, key);\n    int j;\n    hash_item *p = ((hash_item **)ht->table)[i];\n    <span class="keyword">if</span> (p->item == <span class="keyword">NULL</span> &amp;&amp; p->next == <span class="keyword">NULL</span>) {\n        <span class="keyword">return</span> -<span class="number">1</span>;\n    }\n    <span class="keyword">if</span> (p->item != <span class="keyword">NULL</span> &amp;&amp; ht->Compare(key,p->item) == <span class="number">0</span>) {\n        <span class="keyword">return</span> i;\n    }\n    <span class="keyword">for</span> (j = (i+<span class="number">1</span>) % ht->n; j != i; j = (j+<span class="number">1</span>) % ht->n) {\n        p = ((hash_item **)ht->table)[j];\n        <span class="keyword">if</span> (p->item == <span class="keyword">NULL</span> &amp;&amp; p->next == <span class="keyword">NULL</span>) {\n            <span class="keyword">break</span>;\n        }\n        <span class="keyword">if</span> (p->item != <span class="keyword">NULL</span> &amp;&amp; ht->Compare(key, p->item) == <span class="number">0</span>) {\n            <span class="keyword">return</span> j;\n        }\n    }\n    <span class="keyword">return</span> -<span class="number">1</span>;\n}\n\nvoid *HashClosedDelete(hash *ht, void *key) {\n    int i = HashGetSlot(ht, key);\n    <span class="keyword">if</span> (i == -<span class="number">1</span>) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    HashClosedDeleteSlot(ht, i);\n    <span class="keyword">return</span> key;\n}\n\nvoid *HashClosedSearch(hash *ht, void *key) {\n    int i = HashGetSlot(ht, key);\n    <span class="keyword">return</span> i == -<span class="number">1</span> ? <span class="keyword">NULL</span> : key;\n}\n\n<span class="comment">// =============================================</span>\n\nvoid *HashOpenInsert(hash *ht, void *key) {\n    int i = ht->Hash(ht, key);\n    hash_item *p = ((hash_item **)ht->table)[i];\n    hash_item *q = p->next;\n    p->next = SafeMalloc(sizeof(hash_item));\n    p->next->next = q;\n    p->next->item = SafeMalloc(ht->item_size);\n    MemoryCopy(p->next->item, key, ht->item_size);\n    <span class="keyword">return</span> key;\n}\n\nhash_item *_SearchOpen(hash *ht, void *key) {\n    int i = ht->Hash(ht, key);\n    hash_item *p = ((hash_item **)ht->table)[i];\n    hash_item *q = <span class="keyword">NULL</span>;\n    hash_item *r = <span class="keyword">NULL</span>;\n    <span class="keyword">while</span> (p->next != <span class="keyword">NULL</span>) {\n        q = p;\n        p = p->next;\n        <span class="keyword">if</span> (ht->Compare(key,p->item) == <span class="number">0</span>) {\n            r = q;\n            <span class="keyword">break</span>;\n        }\n    }\n    <span class="keyword">return</span> r;\n}\n\nvoid *HashOpenDelete(hash *ht, void *key) {\n    hash_item *p = _SearchOpen(ht, key);\n    hash_item *q;\n    <span class="keyword">if</span> (p == <span class="keyword">NULL</span>) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    q = p->next;\n    p->next = q->next;\n    q->next = <span class="keyword">NULL</span>;\n    free(q->item);\n    free(q);\n    <span class="keyword">return</span> key;\n}\n\nvoid *HashOpenSearch(hash *ht, void *key) {\n    hash_item *p = _SearchOpen(ht, key);\n    <span class="keyword">return</span> p == <span class="keyword">NULL</span> ? <span class="keyword">NULL</span> : key;\n}\n\n<span class="comment">// =============================================</span>\n\nhash *HashCreate(\n    int n,\n    size_t item_size,\n    int (*Hash)(<span class="keyword">const</span> struct hash *, <span class="keyword">const</span> void *),\n    int (*Compare)(<span class="keyword">const</span> void *, <span class="keyword">const</span> void *)\n){\n    int i;\n    hash *ht = SafeMalloc(sizeof(hash));\n    hash_item *p = <span class="keyword">NULL</span>;\n    ht->n = n;\n    ht->item_size = item_size;\n    ht->table = SafeMalloc(n*sizeof(hash_item *));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) {\n        p = SafeMalloc(sizeof(hash_item));\n        p->item = <span class="keyword">NULL</span>;\n        p->next = <span class="keyword">NULL</span>;\n        ((hash_item **)ht->table)[i] = p;\n    }\n    ht->Hash = Hash;\n    ht->Compare = Compare;\n    <span class="keyword">return</span> ht;\n}\n\nvoid _Destroy(hash *ht, int i) {\n    hash_item *p = ((hash_item **)ht->table)[i];\n    hash_item *q = <span class="keyword">NULL</span>;\n    <span class="keyword">while</span> (p != <span class="keyword">NULL</span>) {\n        q = p->next;\n        <span class="keyword">if</span> (q == p) {\n            q = <span class="keyword">NULL</span>;\n        }\n        <span class="keyword">if</span> (p->item != <span class="keyword">NULL</span>) {\n            free(p->item);\n        }\n        free(p);\n        p = q;\n    }\n}\n\nvoid HashDestroy(hash *ht) {\n    int i;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht->n; ++i) {\n        _Destroy(ht, i);\n    }\n    free(ht->table);\n}'},91:function(n,e,t){n.exports='<span class="comment">#ifndef HASH_H</span>\n<span class="comment">#define HASH_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\ntypedef struct hash_item {\n    struct hash_item *next;\n    void *item;\n} hash_item;\n\ntypedef struct hash {\n    int n;\n    size_t item_size;\n    void *table;\n    int (*Hash)(<span class="keyword">const</span> struct hash *, <span class="keyword">const</span> void *);\n    int (*Compare)(<span class="keyword">const</span> void *, <span class="keyword">const</span> void *);\n} hash;\n\nhash *HashCreate(\n    int n,\n    size_t item_size,\n    int (*Hash)(<span class="keyword">const</span> struct hash *, <span class="keyword">const</span> void *),\n    int (*Compare)(<span class="keyword">const</span> void *, <span class="keyword">const</span> void *)\n);\nvoid HashDestroy(hash *ht);\n\nint HashGetSlot(hash *ht, void *key);\nvoid *HashClosedInsert(hash *ht, void *key);\nvoid *HashClosedDelete(hash *ht, void *key);\nvoid HashClosedDeleteSlot(hash *ht, int i);\nvoid *HashClosedSearch(hash *ht, void *key);\n\nvoid *HashOpenInsert(hash *ht, void *key);\nvoid *HashOpenDelete(hash *ht, void *key);\nvoid *HashOpenSearch(hash *ht, void *key);\n\n<span class="comment">#endif</span>'},92:function(n,e,t){n.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./hash.h"</span>\n\nvoid print_open(hash *ht) {\n    int i;\n    hash_item *p;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht->n; ++i) {\n        p = ((hash_item **)ht->table)[i];\n        printf(<span class="string">"%d: "</span>, i);\n        <span class="keyword">while</span> (p->next != <span class="keyword">NULL</span>) {\n            p = p->next;\n            printf(<span class="string">"%4d "</span>, *(int *)p->item);\n        }\n        printf(<span class="string">"\\n"</span>);\n    }\n}\n\nvoid print_closed(hash *ht) {\n    int i;\n    hash_item *p;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht->n; ++i) {\n        printf(<span class="string">"%4d "</span>, i);\n    }\n    printf(<span class="string">"\\n"</span>);\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht->n; ++i) {\n        p = ((hash_item **)ht->table)[i];\n        <span class="keyword">if</span> (p->item != <span class="keyword">NULL</span>) {\n            printf(<span class="string">"%4d "</span>, *(int *)p->item);\n        } <span class="keyword">else</span> {\n            printf(<span class="string">"%4s "</span>, p->next == <span class="keyword">NULL</span> ? <span class="string">"emp"</span> : <span class="string">"del"</span>);\n        }\n    }\n    printf(<span class="string">"\\n"</span>);\n}\n\nint ha(<span class="keyword">const</span> hash *<span class="keyword">self</span>, <span class="keyword">const</span> void *k) {\n    <span class="keyword">return</span> *(int *)k % <span class="keyword">self</span>->n;\n}\n\nint cf(<span class="keyword">const</span> void *a, <span class="keyword">const</span> void *b) {\n    <span class="keyword">return</span> *(int *)a - *(int *)b;\n}\n\nint main(int argc, char <span class="keyword">const</span> *argv[])\n{\n    int cmd;\n    int n, x;\n    int *y;\n    scanf(<span class="string">"%d"</span>, &amp;n);\n    hash *hc = HashCreate(n, sizeof(int), ha, cf);\n    hash *ho = HashCreate(n, sizeof(int), ha, cf);\n    <span class="keyword">while</span> (scanf(<span class="string">"%d"</span>, &amp;cmd) != EOF) {\n        scanf(<span class="string">"%d"</span>, &amp;x);\n        <span class="keyword">switch</span>(cmd) {\n            <span class="keyword">case</span> <span class="number">0</span>:\n                y = HashClosedInsert(hc, &amp;x);\n                printf(<span class="string">"insert closed hashing %d(%d)\\n"</span>, y == <span class="keyword">NULL</span> ? -<span class="number">1</span> : *y,x);\n                y = HashOpenInsert(ho, &amp;x);\n                printf(<span class="string">"insert open hashing %d(%d)\\n"</span>, y == <span class="keyword">NULL</span> ? -<span class="number">1</span> : *y,x);\n                <span class="keyword">break</span>;\n            <span class="keyword">case</span> <span class="number">1</span>:\n                y = HashClosedSearch(hc, &amp;x);\n                printf(<span class="string">"search closed hashing %d(%d)\\n"</span>, y == <span class="keyword">NULL</span> ? -<span class="number">1</span> : *y,x);\n                y = HashOpenSearch(ho, &amp;x);\n                printf(<span class="string">"search open hashing %d(%d)\\n"</span>, y == <span class="keyword">NULL</span> ? -<span class="number">1</span> : *y,x);\n                <span class="keyword">break</span>;\n            <span class="keyword">case</span> <span class="number">2</span>:\n                y = HashClosedDelete(hc, &amp;x);\n                printf(<span class="string">"delete closed hashing %d(%d)\\n"</span>, y == <span class="keyword">NULL</span> ? -<span class="number">1</span> : *y,x);\n                y = HashOpenDelete(ho, &amp;x);\n                printf(<span class="string">"delete open hashing %d(%d)\\n"</span>, y == <span class="keyword">NULL</span> ? -<span class="number">1</span> : *y,x);\n                <span class="keyword">break</span>;\n            <span class="keyword">default</span>:\n                <span class="keyword">break</span>;\n        }\n        print_closed(hc);\n        print_open(ho);\n    }\n    HashDestroy(hc);\n    HashDestroy(ho);\n    <span class="keyword">return</span> <span class="number">0</span>;\n}'},144:function(n,e,t){function a(n,e,t){return 1===y.ht.occupied[t]?"tomato":-1===y.ht.occupied[t]?E:"coral"}function s(n,e,t){return y.ptr.i===t&&y.ptr.j===e?"black":"none"}function r(n,e,t){return 1===y.ht.occupied[t]?n.d:-1===y.ht.occupied[t]?"X":""}function i(){h.selectAll("g.list").data(y.ht.table).enter().append("g").attr("class","list"),h.selectAll("g.list").data(y.ht.table).exit().remove();var n=h.selectAll("g.list").data(y.ht.table);n.selectAll("rect.item").data(function(n){return n},function(n){return n.id}).enter().append("rect").attr("class","item").attr("x",function(n,e,t){return z+_(e)}).attr("y",function(n,e,t){return w(t)}).attr("width",0).attr("height",w.rangeBand()).style("fill",a).style("stroke-width",3),n.selectAll("rect.item").data(function(n){return n},function(n){return n.id}).transition().duration(g).attr("x",function(n,e,t){return z+_(e)}).attr("y",function(n,e,t){return w(t)}).attr("width",_.rangeBand()).attr("height",w.rangeBand()).style("fill",a).style("stroke",s),n.selectAll("rect.item").data(function(n){return n},function(n){return n.id}).exit().remove(),m.selectAll("g.list").data(y.ht.table).enter().append("g").attr("class","list"),m.selectAll("g.list").data(y.ht.table).exit().remove();var e=m.selectAll("g.list").data(y.ht.table);e.selectAll("text.item").data(function(n){return n},function(n){return n.id}).enter().append("text").attr("class","item").attr("x",z).attr("y",function(n,e,t){return w(t)+w.rangeBand()/2+5}).style("fill",a).text(r),e.selectAll("text.item").data(function(n){return n},function(n){return n.id}).transition().duration(g).attr("x",function(n,e,t){return z+_(e)+_.rangeBand()/2}).style("fill",a).text(r),e.selectAll("text.item").data(function(n){return n},function(n){return n.id}).exit().remove(),m.selectAll("text.num").data(y.ht.table).enter().append("text").attr("class","num").attr("x",z-10).attr("y",function(n,e){return w(e)+w.rangeBand()/2+5}).style("fill",a).text(function(n,e){return e}),m.selectAll("text.num").data(y.ht.table).transition().duration(g).style("fill",a).text(function(n,e){return e}),m.selectAll("text.num").data(y.ht.table).exit().remove()}function o(n){return void 0===n?[]:[n]}function c(){function n(){return void 0===y.r?E:-1===y.r?"red":"green"}var e=o(y.key);h.selectAll("rect.key").data(e).enter().append("rect").attr("class","key").attr("x",S).attr("y",w(0)).attr("width",C).attr("height",w.rangeBand()).attr("fill",n),h.selectAll("rect.key").data(e).transition().duration(g).attr("y",w(y.pos||0)).attr("fill",n),h.selectAll("rect.key").data(e).exit().remove(),m.selectAll("text.key").data(e).enter().append("text").attr("class","key").attr("x",S+C/2).attr("y",w(0)+w.rangeBand()/2+5).attr("fill",n),m.selectAll("text.key").data(e).transition().duration(g).attr("y",w(y.pos||0)+w.rangeBand()/2+5).attr("fill",n).text(function(n){return n}),m.selectAll("text.key").data(e).exit().remove(),e=o(y.pos),h.selectAll("line.key").data(e).enter().append("line").attr("class","key").attr("x1",S+C+10).attr("y1",function(n){return w(n)+w.rangeBand()/2}).attr("x2",S+C+10).attr("y2",function(n){return w(n)+w.rangeBand()/2}).attr("marker-end","url(#arrow)").style("stroke",E).style("stroke-width",10),h.selectAll("line.key").data(e).transition().duration(g).attr("y1",function(n){return w(n)+w.rangeBand()/2}).attr("y2",function(n){return w(n)+w.rangeBand()/2}).attr("x2",z-55),h.selectAll("line.key").data(e).exit().remove(),m.selectAll("text.hash").data(e).enter().append("text").attr("class","hash").attr("x",(z-55+S+C+10)/2).attr("y",function(n){return w(n)+w.rangeBand()/2+5}).style("fill",E).text("hash(x) = "+y.ht.fn+" % "+y.ht.n),m.selectAll("text.hash").data(e).transition().duration(g).attr("y",function(n){return w(n)+w.rangeBand()/2+5}).text("hash(x) = "+y.ht.fn+" % "+y.ht.n),m.selectAll("text.hash").data(e).exit().remove()}function l(){w.rangeRoundBands([0,x/10*y.ht.n],.2).domain(v.range(y.ht.n));var n=v.max(y.ht.table,function(n){return n.length})+1;_.rangeRoundBands([0,x/10*n],.08).domain(v.range(n)),C=_.rangeBand()}function p(n,e){y=n,g=e}function d(n,e){p(n,e),l(),c(),i()}function u(){var n=this,e=v.behavior.zoom().scaleExtent([.1,10]).on("zoom",function(){n.svg.attr("transform",k().translate(v.event.translate).scale(v.event.scale))});this.svg=v.select(this.refs.svg.getDOMNode()).append("svg").call(e).append("g");this.svg.append("defs").selectAll("marker").data([1]).enter().append("marker").attr("id","arrow").attr("viewBox","-5 -5 10 10").attr("markerWidth",b).attr("markerHeight",b).attr("orient","auto").attr("refX",-5).append("path").attr("d","M-5,-5L5,0L-5,5").attr("opacity",.5).attr("fill",function(n,e){return E});this.g=this.svg.append("g").attr("transform",k().translate(-140,10).scale(.8)),h=this.g.append("g").attr("class","base"),f=this.g.append("g").attr("class","high"),m=this.g.append("g").attr("class","text")}var h,m,f,y,g,v=t(4),k=t(8),x=600,w=v.scale.ordinal(),_=v.scale.ordinal(),b=3,E="deepskyblue",z=500,S=200,C=50;n.exports={init:u,render:d}}});