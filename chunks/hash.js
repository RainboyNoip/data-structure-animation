webpackJsonpdsa([8],{6:function(n,t,e){n.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "./util.h"</span>\n\nvoid* SafeMalloc(size_t size) {\n    void* m;\n    <span class="keyword">if</span> ((m = malloc(size))) {\n        <span class="keyword">return</span> m;\n    } <span class="keyword">else</span> {\n        printf(<span class="string">"memory overflow\\n"</span>);\n        <span class="keyword">exit</span>(-<span class="number">1</span>);\n        <span class="keyword">return</span> <span class="number">0</span>;\n    }\n}\n\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">// }</span>\n    memcpy(a, b, size);\n}\n\nvoid MemorySwap(void *a, void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// char t;</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     t = *(char *)a;</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">//     *((char *)b + i) = t;</span>\n    <span class="comment">// }</span>\n    void *t = SafeMalloc(size);\n    memcpy(t, a, size);\n    memcpy(a, b, size);\n    memcpy(b, t, size);\n}\n\nvoid MemoryClear(void *a, size_t size) {\n    memset(a, <span class="number">0</span>, size);\n}\n\nvoid *MemoryAddress(void *a, int i, size_t size) {\n    <span class="keyword">return</span> (char *)a + i*size;\n}'},7:function(n,t,e){n.exports='<span class="comment">#ifndef UTIL_H</span>\n<span class="comment">#define UTIL_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\nvoid * SafeMalloc(size_t size);\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size);\nvoid MemorySwap(void *a, void *b, size_t size);\nvoid MemoryClear(void *a, size_t size);\n\n<span class="comment">#endif</span>'},19:function(n,t,e){function s(n,t){q.occupied[n]=1,q.table[n][0].d=t}function a(n){var t=n,e=q.occupied[n];if(b(16,1),k(n,0),1!==e)return b(17,1),n;for(t=(n+1)%q.n;b(19,1),k(t,0),t!==n;t=(t+1)%q.n)if(e=q.occupied[t],b(21,1),1!==e)return b(22,1),t;return b(25,1),-1}function r(n){g(n),b(29,1);var t=_(n);return v(t),b(30,1),t=a(t),b(31,1),-1!==t?(b(32,1),s(t,n),x(),b(33,1),w(t),n):(b(35,1),w(-1),null)}function o(n){q.occupied[n]=-1}function c(n){g(n),b(45,1);var t=_(n);v(t);var e,s=q.occupied[t];if(b(48,1),k(t,0),0===s)return b(49,1),-1;if(b(51,1),1===s&&n===q.table[t][0].d)return b(52,1),t;for(e=(t+1)%q.n;(b(54,1),k(e,0),e!==t)&&(s=q.occupied[e],b(56,1),0!==s);e=(e+1)%q.n)if(b(59,1),1===s&&n===q.table[e][0].d)return b(60,1),e;return b(63,1),-1}function l(n){b(67,1);var t=c(n);return b(68,1),-1==t?(b(69,1),w(-1),null):(b(71,1),o(t),x(),b(72,1),w(t),n)}function p(n){b(76,1);var t=c(n);return b(77,1),w(t),-1==t?null:n}function u(n){g(n),b(83,1);var t=_(n);v(t);var e=q.table[t];return q.occupied[t]=1,b(86,1),"X"!==e[0].d&&(e.unshift({d:"",id:U++}),x()),b(87,1),b(88,1),b(89,1),e[0].d=n,x(),b(90,1),w(1),n}function d(n){g(n),b(94,1);var t=_(n);v(t);for(var e=q.table[t],s=-1,a=0;b(98,1),k(t,a),a<e.length;++a)if(b(101,1),e[a].d===n){b(102,1),s=a,b(103,1);break}return b(106,1),[t,s]}function h(n){b(110,1);var t=d(n);if(b(112,1),-1===t)return b(113,1),w(t),null;var e=t[0],s=t[1];return b(119,1),m(e,s),b(120,1),w(s),n}function f(n){b(124,1);var t=d(n);return b(125,1),w(t),-1===t?null:n}function m(n,t){q.occupied[n]=q.table[n].length-1>0?1:0,1===q.table[n].length?(q.table[n][0].d="X",q.occupied[n]=0):q.table[n]=q.table[n].slice(0,t).concat(q.table[n].slice(t+1)),x()}function y(n,t){q={},q.table=[],q.n=n,q.occupied=[];for(var e=0;n>e;++e)q.occupied[e]=0,q.table[e]=[{d:"X",id:U++}];q.fn=t,z=new Function("x","return "+t)}function g(n){T.key=n}function v(n){T.pos=n}function k(n,t){T.ptr={i:n,j:t}}function w(n){T.r=n}function x(){L=A(q)}function _(n){return n=z(n)%q.n,0>n&&(n=(n+q.n)%q.n),n=Math.floor(n),isNaN(n)?0:n}function b(n,t,e){1===t&&(lastStatus=T.clone()),D.push({status:lastStatus,line:n,animation:e,id:M}),M++}function S(){0===D.length?0:D[D.length-1].line;b(216,1)}function E(n){return n=parseInt(n),isNaN(n)?0:n}var z,C,L,A=e(4),D=[],M=0,T={},U=0,q={};T.clone=function(){return{ht:L,key:this.key,pos:this.pos,ptr:A(this.ptr),r:this.r}},T.init=function(n){L=A(q),this.key=void 0,this.pos=void 0,this.ptr={},this.r=void 0},lastStatus={},n.exports={getInitialDescriptions:function(){this.initialize(!0);var n=11,t=[1,1];for(i=2;i<n;++i)t.push(t[i-1]+t[i-2]);return this.run("create",{n:"10",f:"x",t:"ho"})},initialize:function(n){return D=[],M=0,n&&(U=0),T.init(n),lastStatus=T.clone(),this},create:function(n){C=n.t,y(E(n.n),n.f),T.init(),b(0,1)},searchhc:p,searchho:f,inserthc:r,insertho:u,deletehc:l,deleteho:h,run:function(n,t){return-1===n.indexOf("create")?(t=E(t),n+=C||"hc",this.initialize()[n](t)):this.initialize(!0)[n](t),S(),{frames:D,others:{}}}}},45:function(n,t,e){var s=e(1),a=e(3),r=e(112);n.exports=s.createClass({displayName:"module.exports",getInitialState:function(){return{text:"10",fn:"x"}},componentDidMount:function(){r.init.bind(this)(),a.runDemo("create",{n:"10",f:"x",t:"hc"}),a.runDemo("insert",11,!1)},componentDidUpdate:function(n){this.props!==n&&void 0!==this.props.frame&&r.render(this.props.frame.status,this.props.delay,this.props.others)},render:function(){return s.createElement("div",{className:"wrapper-code"},s.createElement("div",{className:"list"},s.createElement("input",{onChange:this._onChange.bind(this,"text"),value:this.state.text,placeholder:"数字"}),s.createElement("input",{onChange:this._onChange.bind(this,"fn"),value:this.state.fn,placeholder:"x的函数"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"search"),value:"查找",title:"查找"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"insert"),value:"插入",title:"插入"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"delete"),value:"删除",title:"删除"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"create","hc"),value:"开地址散列",title:"开地址散列"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"create","ho"),value:"链地址散列",title:"链地址散列"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._test,value:"stop",title:"stop"})),s.createElement("div",{ref:"svg",className:"scene"}))},_test:function(n){a.pauseDemo(),a.waitDemo()},_onChange:function(n,t){var e={};e[n]=t.target.value,this.setState(e)},_onClick:function(n,t){-1!==n.indexOf("create")?a.runDemo(n,{n:this.state.text,f:this.state.fn,t:t}):a.runDemo(n,this.state.text)}})},64:function(n,t,e){n.exports="CC=gcc\nCFLAGS=-c -Wall\nLDFLAGS=\nSOURCES=test.c hash.c hash.h ../common/util.c ../common/util.h\nOBJECTS=$(SOURCES:.c=.o)\nEXECUTABLE=a.out\n\nall: $(SOURCES) $(EXECUTABLE)\n\n$(EXECUTABLE): $(OBJECTS)\n    $(CC) $(LDFLAGS) $(OBJECTS) -o $@\n\n.cpp.o:\n    $(CC) $(CFLAGS) $&lt; -o $@\n\nclean:\n    rm -rf *.o a.out"},65:function(n,t,e){n.exports='<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "./hash.h"</span>\n<span class="comment">#include "../common/util.h"</span>\n\nvoid _SetTable(hash *ht, int i, void *key) {\n    hash_item *p = ((hash_item **)ht->table)[i];\n    p->item = SafeMalloc(ht->item_size);\n    MemoryCopy(p->item, key, ht->item_size);\n    p->next = p;\n}\n\nint _GetEmptySlot(hash *ht, int i) {\n    int j = i;\n    hash_item *p = ((hash_item **)ht->table)[i];\n    <span class="keyword">if</span> (p->item == <span class="keyword">NULL</span>) {\n        <span class="keyword">return</span> i;\n    }\n    <span class="keyword">for</span> (j = (i+<span class="number">1</span>) % ht->n; j != i; j = (j+<span class="number">1</span>) % ht->n) {\n        p = ((hash_item **)ht->table)[j];\n        <span class="keyword">if</span> (p->item == <span class="keyword">NULL</span>) {\n          <span class="keyword">return</span> j;\n        }\n    }\n    <span class="keyword">return</span> -<span class="number">1</span>;\n}\n\nvoid *HashClosedInsert(hash *ht, void *key) {\n    int i = ht->Hash(ht, key);\n    i = _GetEmptySlot(ht, i);\n    <span class="keyword">if</span> (i != -<span class="number">1</span>) {\n        _SetTable(ht, i, key);\n        <span class="keyword">return</span> key;\n    }\n    <span class="keyword">return</span> <span class="keyword">NULL</span>;\n}\n\nvoid HashClosedDeleteSlot(hash *ht, int i) {\n    hash_item *p = ((hash_item **)ht->table)[i];\n    free(p->item);\n    p->item = <span class="keyword">NULL</span>;\n}\n\nint HashGetSlot(hash *ht, void *key) {\n    int i = ht->Hash(ht, key);\n    int j;\n    hash_item *p = ((hash_item **)ht->table)[i];\n    <span class="keyword">if</span> (p->item == <span class="keyword">NULL</span> &amp;&amp; p->next == <span class="keyword">NULL</span>) {\n        <span class="keyword">return</span> -<span class="number">1</span>;\n    }\n    <span class="keyword">if</span> (p->item != <span class="keyword">NULL</span> &amp;&amp; ht->Compare(key,p->item) == <span class="number">0</span>) {\n        <span class="keyword">return</span> i;\n    }\n    <span class="keyword">for</span> (j = (i+<span class="number">1</span>) % ht->n; j != i; j = (j+<span class="number">1</span>) % ht->n) {\n        p = ((hash_item **)ht->table)[j];\n        <span class="keyword">if</span> (p->item == <span class="keyword">NULL</span> &amp;&amp; p->next == <span class="keyword">NULL</span>) {\n            <span class="keyword">break</span>;\n        }\n        <span class="keyword">if</span> (p->item != <span class="keyword">NULL</span> &amp;&amp; ht->Compare(key, p->item) == <span class="number">0</span>) {\n            <span class="keyword">return</span> j;\n        }\n    }\n    <span class="keyword">return</span> -<span class="number">1</span>;\n}\n\nvoid *HashClosedDelete(hash *ht, void *key) {\n    int i = HashGetSlot(ht, key);\n    <span class="keyword">if</span> (i == -<span class="number">1</span>) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    HashClosedDeleteSlot(ht, i);\n    <span class="keyword">return</span> key;\n}\n\nvoid *HashClosedSearch(hash *ht, void *key) {\n    int i = HashGetSlot(ht, key);\n    <span class="keyword">return</span> i == -<span class="number">1</span> ? <span class="keyword">NULL</span> : key;\n}\n\n<span class="comment">// =============================================</span>\n\nvoid *HashOpenInsert(hash *ht, void *key) {\n    int i = ht->Hash(ht, key);\n    hash_item *p = ((hash_item **)ht->table)[i];\n    hash_item *q = p->next;\n    p->next = SafeMalloc(sizeof(hash_item));\n    p->next->next = q;\n    p->next->item = SafeMalloc(ht->item_size);\n    MemoryCopy(p->next->item, key, ht->item_size);\n    <span class="keyword">return</span> key;\n}\n\nhash_item *_SearchOpen(hash *ht, void *key) {\n    int i = ht->Hash(ht, key);\n    hash_item *p = ((hash_item **)ht->table)[i];\n    hash_item *q = <span class="keyword">NULL</span>;\n    hash_item *r = <span class="keyword">NULL</span>;\n    <span class="keyword">while</span> (p->next != <span class="keyword">NULL</span>) {\n        q = p;\n        p = p->next;\n        <span class="keyword">if</span> (ht->Compare(key,p->item) == <span class="number">0</span>) {\n            r = q;\n            <span class="keyword">break</span>;\n        }\n    }\n    <span class="keyword">return</span> r;\n}\n\nvoid *HashOpenDelete(hash *ht, void *key) {\n    hash_item *p = _SearchOpen(ht, key);\n    hash_item *q;\n    <span class="keyword">if</span> (p == <span class="keyword">NULL</span>) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    q = p->next;\n    p->next = q->next;\n    q->next = <span class="keyword">NULL</span>;\n    free(q->item);\n    free(q);\n    <span class="keyword">return</span> key;\n}\n\nvoid *HashOpenSearch(hash *ht, void *key) {\n    hash_item *p = _SearchOpen(ht, key);\n    <span class="keyword">return</span> p == <span class="keyword">NULL</span> ? <span class="keyword">NULL</span> : key;\n}\n\n<span class="comment">// =============================================</span>\n\nhash *HashCreate(\n    int n,\n    size_t item_size,\n    int (*Hash)(<span class="keyword">const</span> struct hash *, <span class="keyword">const</span> void *),\n    int (*Compare)(<span class="keyword">const</span> void *, <span class="keyword">const</span> void *)\n){\n    int i;\n    hash *ht = SafeMalloc(sizeof(hash));\n    hash_item *p = <span class="keyword">NULL</span>;\n    ht->n = n;\n    ht->item_size = item_size;\n    ht->table = SafeMalloc(n*sizeof(hash_item *));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) {\n        p = SafeMalloc(sizeof(hash_item));\n        p->item = <span class="keyword">NULL</span>;\n        p->next = <span class="keyword">NULL</span>;\n        ((hash_item **)ht->table)[i] = p;\n    }\n    ht->Hash = Hash;\n    ht->Compare = Compare;\n    <span class="keyword">return</span> ht;\n}\n\nvoid _Destroy(hash *ht, int i) {\n    hash_item *p = ((hash_item **)ht->table)[i];\n    hash_item *q = <span class="keyword">NULL</span>;\n    <span class="keyword">while</span> (p != <span class="keyword">NULL</span>) {\n        q = p->next;\n        <span class="keyword">if</span> (q == p) {\n            q = <span class="keyword">NULL</span>;\n        }\n        <span class="keyword">if</span> (p->item != <span class="keyword">NULL</span>) {\n            free(p->item);\n        }\n        free(p);\n        p = q;\n    }\n}\n\nvoid HashDestroy(hash *ht) {\n    int i;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht->n; ++i) {\n        _Destroy(ht, i);\n    }\n    free(ht->table);\n}'},66:function(n,t,e){n.exports='<span class="comment">#ifndef HASH_H</span>\n<span class="comment">#define HASH_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\ntypedef struct hash_item {\n    struct hash_item *next;\n    void *item;\n} hash_item;\n\ntypedef struct hash {\n    int n;\n    size_t item_size;\n    void *table;\n    int (*Hash)(<span class="keyword">const</span> struct hash *, <span class="keyword">const</span> void *);\n    int (*Compare)(<span class="keyword">const</span> void *, <span class="keyword">const</span> void *);\n} hash;\n\nhash *HashCreate(\n    int n,\n    size_t item_size,\n    int (*Hash)(<span class="keyword">const</span> struct hash *, <span class="keyword">const</span> void *),\n    int (*Compare)(<span class="keyword">const</span> void *, <span class="keyword">const</span> void *)\n);\nvoid HashDestroy(hash *ht);\n\nint HashGetSlot(hash *ht, void *key);\nvoid *HashClosedInsert(hash *ht, void *key);\nvoid *HashClosedDelete(hash *ht, void *key);\nvoid HashClosedDeleteSlot(hash *ht, int i);\nvoid *HashClosedSearch(hash *ht, void *key);\n\nvoid *HashOpenInsert(hash *ht, void *key);\nvoid *HashOpenDelete(hash *ht, void *key);\nvoid *HashOpenSearch(hash *ht, void *key);\n\n<span class="comment">#endif</span>'},67:function(n,t,e){n.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./hash.h"</span>\n\nvoid print_open(hash *ht) {\n    int i;\n    hash_item *p;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht->n; ++i) {\n        p = ((hash_item **)ht->table)[i];\n        printf(<span class="string">"%d: "</span>, i);\n        <span class="keyword">while</span> (p->next != <span class="keyword">NULL</span>) {\n            p = p->next;\n            printf(<span class="string">"%4d "</span>, *(int *)p->item);\n        }\n        printf(<span class="string">"\\n"</span>);\n    }\n}\n\nvoid print_closed(hash *ht) {\n    int i;\n    hash_item *p;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht->n; ++i) {\n        printf(<span class="string">"%4d "</span>, i);\n    }\n    printf(<span class="string">"\\n"</span>);\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht->n; ++i) {\n        p = ((hash_item **)ht->table)[i];\n        <span class="keyword">if</span> (p->item != <span class="keyword">NULL</span>) {\n            printf(<span class="string">"%4d "</span>, *(int *)p->item);\n        } <span class="keyword">else</span> {\n            printf(<span class="string">"%4s "</span>, p->next == <span class="keyword">NULL</span> ? <span class="string">"emp"</span> : <span class="string">"del"</span>);\n        }\n    }\n    printf(<span class="string">"\\n"</span>);\n}\n\nint ha(<span class="keyword">const</span> hash *<span class="keyword">self</span>, <span class="keyword">const</span> void *k) {\n    <span class="keyword">return</span> *(int *)k % <span class="keyword">self</span>->n;\n}\n\nint cf(<span class="keyword">const</span> void *a, <span class="keyword">const</span> void *b) {\n    <span class="keyword">return</span> *(int *)a - *(int *)b;\n}\n\nint main(int argc, char <span class="keyword">const</span> *argv[])\n{\n    int cmd;\n    int n, x;\n    int *y;\n    scanf(<span class="string">"%d"</span>, &amp;n);\n    hash *hc = HashCreate(n, sizeof(int), ha, cf);\n    hash *ho = HashCreate(n, sizeof(int), ha, cf);\n    <span class="keyword">while</span> (scanf(<span class="string">"%d"</span>, &amp;cmd) != EOF) {\n        scanf(<span class="string">"%d"</span>, &amp;x);\n        <span class="keyword">switch</span>(cmd) {\n            <span class="keyword">case</span> <span class="number">0</span>:\n                y = HashClosedInsert(hc, &amp;x);\n                printf(<span class="string">"insert closed hashing %d(%d)\\n"</span>, y == <span class="keyword">NULL</span> ? -<span class="number">1</span> : *y,x);\n                y = HashOpenInsert(ho, &amp;x);\n                printf(<span class="string">"insert open hashing %d(%d)\\n"</span>, y == <span class="keyword">NULL</span> ? -<span class="number">1</span> : *y,x);\n                <span class="keyword">break</span>;\n            <span class="keyword">case</span> <span class="number">1</span>:\n                y = HashClosedSearch(hc, &amp;x);\n                printf(<span class="string">"search closed hashing %d(%d)\\n"</span>, y == <span class="keyword">NULL</span> ? -<span class="number">1</span> : *y,x);\n                y = HashOpenSearch(ho, &amp;x);\n                printf(<span class="string">"search open hashing %d(%d)\\n"</span>, y == <span class="keyword">NULL</span> ? -<span class="number">1</span> : *y,x);\n                <span class="keyword">break</span>;\n            <span class="keyword">case</span> <span class="number">2</span>:\n                y = HashClosedDelete(hc, &amp;x);\n                printf(<span class="string">"delete closed hashing %d(%d)\\n"</span>, y == <span class="keyword">NULL</span> ? -<span class="number">1</span> : *y,x);\n                y = HashOpenDelete(ho, &amp;x);\n                printf(<span class="string">"delete open hashing %d(%d)\\n"</span>, y == <span class="keyword">NULL</span> ? -<span class="number">1</span> : *y,x);\n                <span class="keyword">break</span>;\n            <span class="keyword">default</span>:\n                <span class="keyword">break</span>;\n        }\n        print_closed(hc);\n        print_open(ho);\n    }\n    HashDestroy(hc);\n    HashDestroy(ho);\n    <span class="keyword">return</span> <span class="number">0</span>;\n}'},112:function(n,t,e){function s(n,t,e){return 1===y.ht.occupied[e]?"tomato":-1===y.ht.occupied[e]?S:"coral"}function a(n,t,e){return y.ptr.i===e&&y.ptr.j===t?"black":"none"}function r(n,t,e){return 1===y.ht.occupied[e]?n.d:-1===y.ht.occupied[e]?"X":""}function i(){h.selectAll("g.list").data(y.ht.table).enter().append("g").attr("class","list"),h.selectAll("g.list").data(y.ht.table).exit().remove();var n=h.selectAll("g.list").data(y.ht.table);n.selectAll("rect.item").data(function(n){return n},function(n){return n.id}).enter().append("rect").attr("class","item").attr("x",function(n,t,e){return E+_(t)}).attr("y",function(n,t,e){return x(e)}).attr("width",0).attr("height",x.rangeBand()).style("fill",s).style("stroke-width",3),n.selectAll("rect.item").data(function(n){return n},function(n){return n.id}).transition().duration(g).attr("x",function(n,t,e){return E+_(t)}).attr("y",function(n,t,e){return x(e)}).attr("width",_.rangeBand()).attr("height",x.rangeBand()).style("fill",s).style("stroke",a),n.selectAll("rect.item").data(function(n){return n},function(n){return n.id}).exit().remove(),f.selectAll("g.list").data(y.ht.table).enter().append("g").attr("class","list"),f.selectAll("g.list").data(y.ht.table).exit().remove();var t=f.selectAll("g.list").data(y.ht.table);t.selectAll("text.item").data(function(n){return n},function(n){return n.id}).enter().append("text").attr("class","item").attr("x",E).attr("y",function(n,t,e){return x(e)+x.rangeBand()/2+5}).style("fill",s).text(r),t.selectAll("text.item").data(function(n){return n},function(n){return n.id}).transition().duration(g).attr("x",function(n,t,e){return E+_(t)+_.rangeBand()/2}).style("fill",s).text(r),t.selectAll("text.item").data(function(n){return n},function(n){return n.id}).exit().remove(),f.selectAll("text.num").data(y.ht.table).enter().append("text").attr("class","num").attr("x",E-10).attr("y",function(n,t){return x(t)+x.rangeBand()/2+5}).style("fill",s).text(function(n,t){return t}),f.selectAll("text.num").data(y.ht.table).transition().duration(g).style("fill",s).text(function(n,t){return t}),f.selectAll("text.num").data(y.ht.table).exit().remove()}function o(n){return void 0===n?[]:[n]}function c(){function n(){return void 0===y.r?S:-1===y.r?"red":"green"}var t=o(y.key);h.selectAll("rect.key").data(t).enter().append("rect").attr("class","key").attr("x",z).attr("y",x(0)).attr("width",C).attr("height",x.rangeBand()).attr("fill",n),h.selectAll("rect.key").data(t).transition().duration(g).attr("y",x(y.pos||0)).attr("fill",n),h.selectAll("rect.key").data(t).exit().remove(),f.selectAll("text.key").data(t).enter().append("text").attr("class","key").attr("x",z+C/2).attr("y",x(0)+x.rangeBand()/2+5).attr("fill",n),f.selectAll("text.key").data(t).transition().duration(g).attr("y",x(y.pos||0)+x.rangeBand()/2+5).attr("fill",n).text(function(n){return n}),f.selectAll("text.key").data(t).exit().remove(),t=o(y.pos),h.selectAll("line.key").data(t).enter().append("line").attr("class","key").attr("x1",z+C+10).attr("y1",function(n){return x(n)+x.rangeBand()/2}).attr("x2",z+C+10).attr("y2",function(n){return x(n)+x.rangeBand()/2}).attr("marker-end","url(#arrow)").style("stroke",S).style("stroke-width",10),h.selectAll("line.key").data(t).transition().duration(g).attr("y1",function(n){return x(n)+x.rangeBand()/2}).attr("y2",function(n){return x(n)+x.rangeBand()/2}).attr("x2",E-55),h.selectAll("line.key").data(t).exit().remove(),f.selectAll("text.hash").data(t).enter().append("text").attr("class","hash").attr("x",(E-55+z+C+10)/2).attr("y",function(n){return x(n)+x.rangeBand()/2+5}).style("fill",S).text("hash(x) = "+y.ht.fn+" % "+y.ht.n),f.selectAll("text.hash").data(t).transition().duration(g).attr("y",function(n){return x(n)+x.rangeBand()/2+5}).text("hash(x) = "+y.ht.fn+" % "+y.ht.n),f.selectAll("text.hash").data(t).exit().remove()}function l(){x.rangeRoundBands([0,w/10*y.ht.n],.2).domain(v.range(y.ht.n));var n=v.max(y.ht.table,function(n){return n.length})+1;_.rangeRoundBands([0,w/10*n],.08).domain(v.range(n)),C=_.rangeBand()}function p(n,t){y=n,g=t}function u(n,t){p(n,t),l(),c(),i()}function d(){var n=this,t=v.behavior.zoom().scaleExtent([.1,10]).on("zoom",function(){n.svg.attr("transform",k().translate(v.event.translate).scale(v.event.scale))});this.svg=v.select(this.refs.svg.getDOMNode()).append("svg").call(t).append("g");this.svg.append("defs").selectAll("marker").data([1]).enter().append("marker").attr("id","arrow").attr("viewBox","-5 -5 10 10").attr("markerWidth",b).attr("markerHeight",b).attr("orient","auto").attr("refX",-5).append("path").attr("d","M-5,-5L5,0L-5,5").attr("opacity",.5).attr("fill",function(n,t){return S});this.g=this.svg.append("g").attr("transform",k().translate(-140,10).scale(.8)),h=this.g.append("g").attr("class","base"),m=this.g.append("g").attr("class","high"),f=this.g.append("g").attr("class","text")}var h,f,m,y,g,v=e(2),k=e(5),w=600,x=v.scale.ordinal(),_=v.scale.ordinal(),b=3,S="deepskyblue",E=500,z=200,C=50;n.exports={init:d,render:u}}});