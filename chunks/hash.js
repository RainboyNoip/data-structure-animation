webpackJsonpdsa([8],{6:function(n,t,e){n.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "./util.h"</span>\n\nvoid* SafeMalloc(size_t size) {\n    void* m;\n    <span class="keyword">if</span> ((m = malloc(size))) {\n        <span class="keyword">return</span> m;\n    } <span class="keyword">else</span> {\n        printf(<span class="string">"memory overflow\\n"</span>);\n        <span class="keyword">exit</span>(-<span class="number">1</span>);\n        <span class="keyword">return</span> <span class="number">0</span>;\n    }\n}\n\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">// }</span>\n    memcpy(a, b, size);\n}\n\nvoid MemorySwap(void *a, void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// char t;</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     t = *(char *)a;</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">//     *((char *)b + i) = t;</span>\n    <span class="comment">// }</span>\n    void *t = SafeMalloc(size);\n    memcpy(t, a, size);\n    memcpy(a, b, size);\n    memcpy(b, t, size);\n}\n\nvoid MemoryClear(void *a, size_t size) {\n    memset(a, <span class="number">0</span>, size);\n}\n\nvoid *MemoryAddress(void *a, int i, size_t size) {\n    <span class="keyword">return</span> (char *)a + i*size;\n}'},7:function(n,t,e){n.exports='<span class="comment">#ifndef UTIL_H</span>\n<span class="comment">#define UTIL_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\nvoid * SafeMalloc(size_t size);\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size);\nvoid MemorySwap(void *a, void *b, size_t size);\nvoid MemoryClear(void *a, size_t size);\n\n<span class="comment">#endif</span>'},19:function(n,t,e){function s(n,t){U.occupied[n]=1,U.table[n][0].d=t}function a(n){var t=n,e=U.occupied[n];if(_(16,1),x(n,0),1!==e)return _(17,1),n;for(t=(n+1)%U.n;_(19,1),x(t,0),t!==n;t=(t+1)%U.n)if(e=U.occupied[t],_(21,1),1!==e)return _(22,1),t;return _(25,1),-1}function r(n){g(n),_(29,1);var t=b(n);return v(t),_(30,1),t=a(t),_(31,1),-1!==t?(_(32,1),s(t,n),w(),_(33,1),k(t),n):(_(35,1),k(-1),null)}function o(n){U.occupied[n]=-1}function c(n){g(n),_(45,1);var t=b(n);v(t);var e,s=U.occupied[t];if(_(48,1),x(t,0),0===s)return _(49,1),-1;if(_(51,1),1===s&&n===U.table[t][0].d)return _(52,1),t;for(e=(t+1)%U.n;(_(54,1),x(e,0),e!==t)&&(s=U.occupied[e],_(56,1),0!==s);e=(e+1)%U.n)if(_(59,1),1===s&&n===U.table[e][0].d)return _(60,1),e;return _(63,1),-1}function l(n){_(67,1);var t=c(n);return _(68,1),-1==t?(_(69,1),k(-1),null):(_(71,1),o(t),w(),_(72,1),k(t),n)}function p(n){_(76,1);var t=c(n);return _(77,1),k(t),-1==t?null:n}function u(n){g(n),_(83,1);var t=b(n);v(t);var e=U.table[t];return U.occupied[t]=1,_(86,1),"X"!==e[0].d&&(e.unshift({d:"",id:B++}),w()),_(87,1),_(88,1),_(89,1),e[0].d=n,w(),_(90,1),k(1),n}function d(n){g(n),_(94,1);var t=b(n);v(t);for(var e=U.table[t],s=-1,a=0;_(98,1),x(t,a),a<e.length;++a)if(_(101,1),e[a].d===n){_(102,1),s=a,_(103,1);break}return _(106,1),[t,s]}function h(n){_(110,1);var t=d(n);if(_(112,1),-1===t)return _(113,1),k(t),null;var e=t[0],s=t[1];return _(119,1),m(e,s),_(120,1),k(s),n}function f(n){_(124,1);var t=d(n);return _(125,1),k(t),-1===t?null:n}function m(n,t){U.occupied[n]=U.table[n].length-1>0?1:0,1===U.table[n].length?(U.table[n][0].d="X",U.occupied[n]=0):U.table[n]=U.table[n].slice(0,t).concat(U.table[n].slice(t+1)),w()}function y(n,t){U={},U.table=[],U.n=n,U.occupied=[];for(var e=0;n>e;++e)U.occupied[e]=0,U.table[e]=[{d:"X",id:B++}];U.fn=t,C=new Function("x","return "+t)}function g(n){T.key=n}function v(n){T.pos=n}function x(n,t){T.ptr={i:n,j:t}}function k(n){T.r=n}function w(){z=L(U)}function b(n){return n=C(n)%U.n,0>n&&(n=(n+U.n)%U.n),n=Math.floor(n),isNaN(n)?0:n}function _(n,t,e){1===t&&(lastStatus=T.clone()),D.push({status:lastStatus,line:n,animation:e,id:M}),M++}function E(){0===D.length?0:D[D.length-1].line;_(216,1)}function A(n){return n=parseInt(n),isNaN(n)?0:n}var C,S,z,L=e(4),D=[],M=0,T={},B=0,U={};T.clone=function(){return{ht:z,key:this.key,pos:this.pos,ptr:L(this.ptr),r:this.r}},T.init=function(n){z=L(U),this.key=void 0,this.pos=void 0,this.ptr={},this.r=void 0},lastStatus={},n.exports={getInitialDescriptions:function(){this.initialize(!0);var n=11,t=[1,1];for(i=2;i<n;++i)t.push(t[i-1]+t[i-2]);return this.run("create",{n:"10",f:"x",t:"ho"})},initialize:function(n){return D=[],M=0,n&&(B=0),T.init(n),lastStatus=T.clone(),this},create:function(n){S=n.t,y(A(n.n),n.f),T.init(),_(0,1)},searchhc:p,searchho:f,inserthc:r,insertho:u,deletehc:l,deleteho:h,run:function(n,t){return-1===n.indexOf("create")?(t=A(t),n+=S||"hc",this.initialize()[n](t)):this.initialize(!0)[n](t),E(),{frames:D,others:{}}}}},44:function(n,t,e){var s=e(1),a=e(3),r=e(108);n.exports=s.createClass({displayName:"module.exports",getInitialState:function(){return{text:"10",fn:"x"}},componentDidMount:function(){r.init.bind(this)(),a.runDemo("create",{n:"10",f:"x",t:"hc"}),a.runDemo("insert",11,!1)},componentDidUpdate:function(n){this.props!==n&&void 0!==this.props.frame&&r.render(this.props.frame.status,this.props.delay,this.props.others)},render:function(){return s.createElement("div",{className:"wrapper-code"},s.createElement("div",{className:"list"},s.createElement("input",{onChange:this._onChange.bind(this,"text"),value:this.state.text,placeholder:"数字"}),s.createElement("input",{onChange:this._onChange.bind(this,"fn"),value:this.state.fn,placeholder:"x的函数"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"search"),value:"查找",title:"查找"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"insert"),value:"插入",title:"插入"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"delete"),value:"删除",title:"删除"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"create","hc"),value:"开地址散列",title:"开地址散列"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"create","ho"),value:"链地址散列",title:"链地址散列"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._test,value:"stop",title:"stop"})),s.createElement("div",{ref:"svg",className:"scene"}))},_test:function(n){a.pauseDemo(),a.waitDemo()},_onChange:function(n,t){var e={};e[n]=t.target.value,this.setState(e)},_onClick:function(n,t){-1!==n.indexOf("create")?a.runDemo(n,{n:this.state.text,f:this.state.fn,t:t}):a.runDemo(n,this.state.text)}})},61:function(n,t,e){n.exports="CC=gcc\nCFLAGS=-c -Wall\nLDFLAGS=\nSOURCES=test.c hash.c hash.h ../common/util.c ../common/util.h\nOBJECTS=$(SOURCES:.c=.o)\nEXECUTABLE=a.out\n\nall: $(SOURCES) $(EXECUTABLE)\n\n$(EXECUTABLE): $(OBJECTS)\n    $(CC) $(LDFLAGS) $(OBJECTS) -o $@\n\n.cpp.o:\n    $(CC) $(CFLAGS) $&lt; -o $@\n\nclean:\n    rm -rf *.o a.out"},62:function(n,t,e){n.exports='<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "./hash.h"</span>\n<span class="comment">#include "../common/util.h"</span>\n\nvoid _SetTable(hash *ht, int i, void *key) {\n    hash_item *p = ((hash_item **)ht->table)[i];\n    p->item = SafeMalloc(ht->item_size);\n    MemoryCopy(p->item, key, ht->item_size);\n    p->next = p;\n}\n\nint _GetSlot(hash *ht, int i) {\n    int j = i;\n    hash_item *p = ((hash_item **)ht->table)[i];\n    <span class="keyword">if</span> (p->item == <span class="keyword">NULL</span>) {\n        <span class="keyword">return</span> i;\n    }\n    <span class="keyword">for</span> (j = (i+<span class="number">1</span>) % ht->n; j != i; j = (j+<span class="number">1</span>) % ht->n) {\n        p = ((hash_item **)ht->table)[j];\n        <span class="keyword">if</span> (p->item == <span class="keyword">NULL</span>) {\n          <span class="keyword">return</span> j;\n        }\n    }\n    <span class="keyword">return</span> -<span class="number">1</span>;\n}\n\nvoid *HashClosedInsert(hash *ht, void *key) {\n    int i = ht->Hash(ht, key);\n    i = _GetSlot(ht, i);\n    <span class="keyword">if</span> (i != -<span class="number">1</span>) {\n        _SetTable(ht, i, key);\n        <span class="keyword">return</span> key;\n    }\n    <span class="keyword">return</span> <span class="keyword">NULL</span>;\n}\n\nvoid _UnsetTable(hash *ht, int i) {\n    hash_item *p = ((hash_item **)ht->table)[i];\n    free(p->item);\n    p->item = <span class="keyword">NULL</span>;\n}\n\nint _SearchClosed(hash *ht, void *key) {\n    int i = ht->Hash(ht, key);\n    int j;\n    hash_item *p = ((hash_item **)ht->table)[i];\n    <span class="keyword">if</span> (p->item == <span class="keyword">NULL</span> &amp;&amp; p->next == <span class="keyword">NULL</span>) {\n        <span class="keyword">return</span> -<span class="number">1</span>;\n    }\n    <span class="keyword">if</span> (p->item != <span class="keyword">NULL</span> &amp;&amp; ht->Compare(key,p->item) == <span class="number">0</span>) {\n        <span class="keyword">return</span> i;\n    }\n    <span class="keyword">for</span> (j = (i+<span class="number">1</span>) % ht->n; j != i; j = (j+<span class="number">1</span>) % ht->n) {\n        p = ((hash_item **)ht->table)[j];\n        <span class="keyword">if</span> (p->item == <span class="keyword">NULL</span> &amp;&amp; p->next == <span class="keyword">NULL</span>) {\n            <span class="keyword">break</span>;\n        }\n        <span class="keyword">if</span> (p->item != <span class="keyword">NULL</span> &amp;&amp; ht->Compare(key, p->item) == <span class="number">0</span>) {\n            <span class="keyword">return</span> j;\n        }\n    }\n    <span class="keyword">return</span> -<span class="number">1</span>;\n}\n\nvoid *HashClosedDelete(hash *ht, void *key) {\n    int i = _SearchClosed(ht, key);\n    <span class="keyword">if</span> (i == -<span class="number">1</span>) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    _UnsetTable(ht, i);\n    <span class="keyword">return</span> key;\n}\n\nvoid *HashClosedSearch(hash *ht, void *key) {\n    int i = _SearchClosed(ht, key);\n    <span class="keyword">return</span> i == -<span class="number">1</span> ? <span class="keyword">NULL</span> : key;\n}\n\n<span class="comment">// =============================================</span>\n\nvoid *HashOpenInsert(hash *ht, void *key) {\n    int i = ht->Hash(ht, key);\n    hash_item *p = ((hash_item **)ht->table)[i];\n    hash_item *q = p->next;\n    p->next = SafeMalloc(sizeof(hash_item));\n    p->next->next = q;\n    p->next->item = SafeMalloc(ht->item_size);\n    MemoryCopy(p->next->item, key, ht->item_size);\n    <span class="keyword">return</span> key;\n}\n\nhash_item *_SearchOpen(hash *ht, void *key) {\n    int i = ht->Hash(ht, key);\n    hash_item *p = ((hash_item **)ht->table)[i];\n    hash_item *q = <span class="keyword">NULL</span>;\n    hash_item *r = <span class="keyword">NULL</span>;\n    <span class="keyword">while</span> (p->next != <span class="keyword">NULL</span>) {\n        q = p;\n        p = p->next;\n        <span class="keyword">if</span> (ht->Compare(key,p->item) == <span class="number">0</span>) {\n            r = q;\n            <span class="keyword">break</span>;\n        }\n    }\n    <span class="keyword">return</span> r;\n}\n\nvoid *HashOpenDelete(hash *ht, void *key) {\n    hash_item *p = _SearchOpen(ht, key);\n    hash_item *q;\n    <span class="keyword">if</span> (p == <span class="keyword">NULL</span>) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    q = p->next;\n    p->next = q->next;\n    q->next = <span class="keyword">NULL</span>;\n    free(q->item);\n    free(q);\n    <span class="keyword">return</span> key;\n}\n\nvoid *HashOpenSearch(hash *ht, void *key) {\n    hash_item *p = _SearchOpen(ht, key);\n    <span class="keyword">return</span> p == <span class="keyword">NULL</span> ? <span class="keyword">NULL</span> : key;\n}\n\n<span class="comment">// =============================================</span>\n\nhash *HashCreate(\n    int n,\n    size_t item_size,\n    int (*Hash)(<span class="keyword">const</span> struct hash *, <span class="keyword">const</span> void *),\n    int (*Compare)(<span class="keyword">const</span> void *, <span class="keyword">const</span> void *)\n){\n    int i;\n    hash *ht = SafeMalloc(sizeof(hash));\n    hash_item *p = <span class="keyword">NULL</span>;\n    ht->n = n;\n    ht->item_size = item_size;\n    ht->table = SafeMalloc(n*sizeof(hash_item *));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) {\n        p = SafeMalloc(sizeof(hash_item));\n        p->item = <span class="keyword">NULL</span>;\n        p->next = <span class="keyword">NULL</span>;\n        ((hash_item **)ht->table)[i] = p;\n    }\n    ht->Hash = Hash;\n    ht->Compare = Compare;\n    <span class="keyword">return</span> ht;\n}\n\nvoid _Destroy(hash *ht, int i) {\n    hash_item *p = ((hash_item **)ht->table)[i];\n    hash_item *q = <span class="keyword">NULL</span>;\n    <span class="keyword">while</span> (p != <span class="keyword">NULL</span>) {\n        q = p->next;\n        <span class="keyword">if</span> (q == p) {\n            q = <span class="keyword">NULL</span>;\n        }\n        <span class="keyword">if</span> (p->item != <span class="keyword">NULL</span>) {\n            free(p->item);\n        }\n        free(p);\n        p = q;\n    }\n}\n\nvoid HashDestroy(hash *ht) {\n    int i;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht->n; ++i) {\n        _Destroy(ht, i);\n    }\n    free(ht->table);\n}'},63:function(n,t,e){n.exports='<span class="comment">#ifndef HASH_H</span>\n<span class="comment">#define HASH_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\ntypedef struct hash_item {\n    struct hash_item *next;\n    void *item;\n} hash_item;\n\ntypedef struct hash {\n    int n;\n    size_t item_size;\n    void *table;\n    int (*Hash)(<span class="keyword">const</span> struct hash *, <span class="keyword">const</span> void *);\n    int (*Compare)(<span class="keyword">const</span> void *, <span class="keyword">const</span> void *);\n} hash;\n\nhash *HashCreate(\n    int n,\n    size_t item_size,\n    int (*Hash)(<span class="keyword">const</span> struct hash *, <span class="keyword">const</span> void *),\n    int (*Compare)(<span class="keyword">const</span> void *, <span class="keyword">const</span> void *)\n);\nvoid HashDestroy(hash *ht);\n\nvoid *HashClosedInsert(hash *ht, void *key);\nvoid *HashClosedDelete(hash *ht, void *key);\nvoid *HashClosedSearch(hash *ht, void *key);\nvoid *HashOpenInsert(hash *ht, void *key);\nvoid *HashOpenDelete(hash *ht, void *key);\nvoid *HashOpenSearch(hash *ht, void *key);\n\n<span class="comment">#endif</span>'},64:function(n,t,e){n.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./hash.h"</span>\n\nvoid print_open(hash *ht) {\n    int i;\n    hash_item *p;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht->n; ++i) {\n        p = ((hash_item **)ht->table)[i];\n        printf(<span class="string">"%d: "</span>, i);\n        <span class="keyword">while</span> (p->next != <span class="keyword">NULL</span>) {\n            p = p->next;\n            printf(<span class="string">"%4d "</span>, *(int *)p->item);\n        }\n        printf(<span class="string">"\\n"</span>);\n    }\n}\n\nvoid print_closed(hash *ht) {\n    int i;\n    hash_item *p;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht->n; ++i) {\n        printf(<span class="string">"%4d "</span>, i);\n    }\n    printf(<span class="string">"\\n"</span>);\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht->n; ++i) {\n        p = ((hash_item **)ht->table)[i];\n        <span class="keyword">if</span> (p->item != <span class="keyword">NULL</span>) {\n            printf(<span class="string">"%4d "</span>, *(int *)p->item);\n        } <span class="keyword">else</span> {\n            printf(<span class="string">"%4s "</span>, p->next == <span class="keyword">NULL</span> ? <span class="string">"emp"</span> : <span class="string">"del"</span>);\n        }\n    }\n    printf(<span class="string">"\\n"</span>);\n}\n\nint ha(<span class="keyword">const</span> hash *<span class="keyword">self</span>, <span class="keyword">const</span> void *k) {\n    <span class="keyword">return</span> *(int *)k % <span class="keyword">self</span>->n;\n}\n\nint cf(<span class="keyword">const</span> void *a, <span class="keyword">const</span> void *b) {\n    <span class="keyword">return</span> *(int *)a - *(int *)b;\n}\n\nint main(int argc, char <span class="keyword">const</span> *argv[])\n{\n    int cmd;\n    int n, x;\n    int *y;\n    scanf(<span class="string">"%d"</span>, &amp;n);\n    hash *hc = HashCreate(n, sizeof(int), ha, cf);\n    hash *ho = HashCreate(n, sizeof(int), ha, cf);\n    <span class="keyword">while</span> (scanf(<span class="string">"%d"</span>, &amp;cmd) != EOF) {\n        scanf(<span class="string">"%d"</span>, &amp;x);\n        <span class="keyword">switch</span>(cmd) {\n            <span class="keyword">case</span> <span class="number">0</span>:\n                y = HashClosedInsert(hc, &amp;x);\n                printf(<span class="string">"insert closed hashing %d(%d)\\n"</span>, y == <span class="keyword">NULL</span> ? -<span class="number">1</span> : *y,x);\n                y = HashOpenInsert(ho, &amp;x);\n                printf(<span class="string">"insert open hashing %d(%d)\\n"</span>, y == <span class="keyword">NULL</span> ? -<span class="number">1</span> : *y,x);\n                <span class="keyword">break</span>;\n            <span class="keyword">case</span> <span class="number">1</span>:\n                y = HashClosedSearch(hc, &amp;x);\n                printf(<span class="string">"search closed hashing %d(%d)\\n"</span>, y == <span class="keyword">NULL</span> ? -<span class="number">1</span> : *y,x);\n                y = HashOpenSearch(ho, &amp;x);\n                printf(<span class="string">"search open hashing %d(%d)\\n"</span>, y == <span class="keyword">NULL</span> ? -<span class="number">1</span> : *y,x);\n                <span class="keyword">break</span>;\n            <span class="keyword">case</span> <span class="number">2</span>:\n                y = HashClosedDelete(hc, &amp;x);\n                printf(<span class="string">"delete closed hashing %d(%d)\\n"</span>, y == <span class="keyword">NULL</span> ? -<span class="number">1</span> : *y,x);\n                y = HashOpenDelete(ho, &amp;x);\n                printf(<span class="string">"delete open hashing %d(%d)\\n"</span>, y == <span class="keyword">NULL</span> ? -<span class="number">1</span> : *y,x);\n                <span class="keyword">break</span>;\n            <span class="keyword">default</span>:\n                <span class="keyword">break</span>;\n        }\n        print_closed(hc);\n        print_open(ho);\n    }\n    HashDestroy(hc);\n    HashDestroy(ho);\n    <span class="keyword">return</span> <span class="number">0</span>;\n}'},108:function(n,t,e){function s(n,t,e){return 1===y.ht.occupied[e]?"tomato":-1===y.ht.occupied[e]?E:"coral"}function a(n,t,e){return y.ptr.i===e&&y.ptr.j===t?"black":"none"}function r(n,t,e){return 1===y.ht.occupied[e]?n.d:-1===y.ht.occupied[e]?"X":""}function i(){h.selectAll("g.list").data(y.ht.table).enter().append("g").attr("class","list"),h.selectAll("g.list").data(y.ht.table).exit().remove();var n=h.selectAll("g.list").data(y.ht.table);n.selectAll("rect.item").data(function(n){return n},function(n){return n.id}).enter().append("rect").attr("class","item").attr("x",function(n,t,e){return A+b(t)}).attr("y",function(n,t,e){return w(e)}).attr("width",0).attr("height",w.rangeBand()).style("fill",s).style("stroke-width",3),n.selectAll("rect.item").data(function(n){return n},function(n){return n.id}).transition().duration(g).attr("x",function(n,t,e){return A+b(t)}).attr("y",function(n,t,e){return w(e)}).attr("width",b.rangeBand()).attr("height",w.rangeBand()).style("fill",s).style("stroke",a),n.selectAll("rect.item").data(function(n){return n},function(n){return n.id}).exit().remove(),f.selectAll("g.list").data(y.ht.table).enter().append("g").attr("class","list"),f.selectAll("g.list").data(y.ht.table).exit().remove();var t=f.selectAll("g.list").data(y.ht.table);t.selectAll("text.item").data(function(n){return n},function(n){return n.id}).enter().append("text").attr("class","item").attr("x",A).attr("y",function(n,t,e){return w(e)+w.rangeBand()/2+5}).style("fill",s).text(r),t.selectAll("text.item").data(function(n){return n},function(n){return n.id}).transition().duration(g).attr("x",function(n,t,e){return A+b(t)+b.rangeBand()/2}).style("fill",s).text(r),t.selectAll("text.item").data(function(n){return n},function(n){return n.id}).exit().remove(),f.selectAll("text.num").data(y.ht.table).enter().append("text").attr("class","num").attr("x",A-10).attr("y",function(n,t){return w(t)+w.rangeBand()/2+5}).style("fill",s).text(function(n,t){return t}),f.selectAll("text.num").data(y.ht.table).transition().duration(g).style("fill",s).text(function(n,t){return t}),f.selectAll("text.num").data(y.ht.table).exit().remove()}function o(n){return void 0===n?[]:[n]}function c(){function n(){return void 0===y.r?E:-1===y.r?"red":"green"}var t=o(y.key);h.selectAll("rect.key").data(t).enter().append("rect").attr("class","key").attr("x",C).attr("y",w(0)).attr("width",S).attr("height",w.rangeBand()).attr("fill",n),h.selectAll("rect.key").data(t).transition().duration(g).attr("y",w(y.pos||0)).attr("fill",n),h.selectAll("rect.key").data(t).exit().remove(),f.selectAll("text.key").data(t).enter().append("text").attr("class","key").attr("x",C+S/2).attr("y",w(0)+w.rangeBand()/2+5).attr("fill",n),f.selectAll("text.key").data(t).transition().duration(g).attr("y",w(y.pos||0)+w.rangeBand()/2+5).attr("fill",n).text(function(n){return n}),f.selectAll("text.key").data(t).exit().remove(),t=o(y.pos),h.selectAll("line.key").data(t).enter().append("line").attr("class","key").attr("x1",C+S+10).attr("y1",function(n){return w(n)+w.rangeBand()/2}).attr("x2",C+S+10).attr("y2",function(n){return w(n)+w.rangeBand()/2}).attr("marker-end","url(#arrow)").style("stroke",E).style("stroke-width",10),h.selectAll("line.key").data(t).transition().duration(g).attr("y1",function(n){return w(n)+w.rangeBand()/2}).attr("y2",function(n){return w(n)+w.rangeBand()/2}).attr("x2",A-55),h.selectAll("line.key").data(t).exit().remove(),f.selectAll("text.hash").data(t).enter().append("text").attr("class","hash").attr("x",(A-55+C+S+10)/2).attr("y",function(n){return w(n)+w.rangeBand()/2+5}).style("fill",E).text("hash(x) = "+y.ht.fn+" % "+y.ht.n),f.selectAll("text.hash").data(t).transition().duration(g).attr("y",function(n){return w(n)+w.rangeBand()/2+5}).text("hash(x) = "+y.ht.fn+" % "+y.ht.n),f.selectAll("text.hash").data(t).exit().remove()}function l(){w.rangeRoundBands([0,k/10*y.ht.n],.2).domain(v.range(y.ht.n));var n=v.max(y.ht.table,function(n){return n.length})+1;b.rangeRoundBands([0,k/10*n],.08).domain(v.range(n)),S=b.rangeBand()}function p(n,t){y=n,g=t}function u(n,t){p(n,t),l(),c(),i()}function d(){var n=this,t=v.behavior.zoom().scaleExtent([.1,10]).on("zoom",function(){n.svg.attr("transform",x().translate(v.event.translate).scale(v.event.scale))});this.svg=v.select(this.refs.svg.getDOMNode()).append("svg").call(t).append("g");this.svg.append("defs").selectAll("marker").data([1]).enter().append("marker").attr("id","arrow").attr("viewBox","-5 -5 10 10").attr("markerWidth",_).attr("markerHeight",_).attr("orient","auto").attr("refX",-5).append("path").attr("d","M-5,-5L5,0L-5,5").attr("opacity",.5).attr("fill",function(n,t){return E});this.g=this.svg.append("g").attr("transform",x().translate(-140,10).scale(.8)),h=this.g.append("g").attr("class","base"),m=this.g.append("g").attr("class","high"),f=this.g.append("g").attr("class","text")}var h,f,m,y,g,v=e(2),x=e(5),k=600,w=v.scale.ordinal(),b=v.scale.ordinal(),_=3,E="deepskyblue",A=500,C=200,S=50;n.exports={init:d,render:u}}});