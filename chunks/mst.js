webpackJsonpdsa([3],{2:function(e,n,t){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "./util.h"</span>\n\nvoid* SafeMalloc(size_t size) {\n    void* m;\n    <span class="keyword">if</span> ((m = malloc(size))) {\n        <span class="keyword">return</span> m;\n    } <span class="keyword">else</span> {\n        printf(<span class="string">"memory overflow\\n"</span>);\n        <span class="keyword">exit</span>(-<span class="number">1</span>);\n        <span class="keyword">return</span> <span class="number">0</span>;\n    }\n}\n\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">// }</span>\n    memcpy(a, b, size);\n}\n\nvoid MemorySwap(void *a, void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// char t;</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     t = *(char *)a;</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">//     *((char *)b + i) = t;</span>\n    <span class="comment">// }</span>\n    void *t = SafeMalloc(size);\n    memcpy(t, a, size);\n    memcpy(a, b, size);\n    memcpy(b, t, size);\n}\n\nvoid MemoryClear(void *a, size_t size) {\n    memset(a, <span class="number">0</span>, size);\n}\n\nvoid *MemoryAddress(void *a, int i, size_t size) {\n    <span class="keyword">return</span> (char *)a + i*size;\n}'},3:function(e,n,t){e.exports='<span class="comment">#ifndef UTIL_H</span>\n<span class="comment">#define UTIL_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\nvoid * SafeMalloc(size_t size);\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size);\nvoid MemorySwap(void *a, void *b, size_t size);\nvoid MemoryClear(void *a, size_t size);\n\n<span class="comment">#endif</span>'},10:function(e,n,t){n=e.exports=t(7)(),n.push([e.id,"circle.node{fill:#ccc;stroke:#000;stroke-width:1.5px}circle.node.painter-selected{fill:#000}circle.node.highlighted{stroke-dasharray:10 2;-webkit-animation:dash .4s linear infinite;animation:dash .4s linear infinite}text.edge,text.node{fill:#000;font:20px sans-serif;pointer-events:none;text-anchor:middle;text-shadow:0 1px 0 #fff,1px 0 0 #fff,0 -1px 0 #fff,-1px 0 0 #fff}path.drag,path.edge{fill:none;stroke:#000;stroke-width:4px}path.edge.painter-selected{stroke-dasharray:10 2;-webkit-animation:dash .4s linear infinite;animation:dash .4s linear infinite}path.edge.painter-selected.rev-dir{-webkit-animation-direction:reverse;animation-direction:reverse}path.edge.painter-selected.rev-dir.sam-dir{-webkit-animation-direction:alternate;animation-direction:alternate}@-webkit-keyframes dash{from{stroke-dashoffset:12}to{stroke-dashoffset:0}}@keyframes dash{from{stroke-dashoffset:12}to{stroke-dashoffset:0}}",""])},11:function(e,n,t){var a=t(1);e.exports=a.createClass({displayName:"module.exports",render:function(){var e={display:this.props.show?"block":"none"},n='<use xlink:href="#cursor">',t='<use xlink:href="#cross">',s=12,r=6,i=Math.sqrt(3),o="M"+[[0,0],[0,s],[i*s/6,-s/6],[r/2,r/2*i],[i*s/6,-s/6],[-r/2,-r/2*i],[i*s/6,-s/6]].map(function(e){return e.toString()}).join("l")+"z";return a.createElement("svg",{className:"legend",width:"210",height:"230",style:e},a.createElement("defs",null,a.createElement("path",{id:"cursor",d:o,stroke:"black",strokeWidth:"1.2",fill:"white"}),a.createElement("g",{id:"cross"},a.createElement("path",{d:"M-6,-6L6,6",stroke:"gray",strokeWidth:"2"}),a.createElement("path",{d:"M-6,6L6,-6",stroke:"gray",strokeWidth:"2"}))),a.createElement("rect",{className:"outline",stroke:"black",x:"0",y:"0",width:"200",height:"210"}),a.createElement("g",{transform:"translate(15,20)"},a.createElement("g",{transform:"translate(8,0)"},a.createElement("path",{d:"M2,0L8,0",markerEnd:"url(#arrow-end)",strokeWidth:"2",stroke:"black"}),a.createElement("path",{d:"M-2,0L-8,0",markerEnd:"url(#arrow-end)",strokeWidth:"2",stroke:"black"}),a.createElement("path",{d:"M0,2L0,8",markerEnd:"url(#arrow-end)",strokeWidth:"2",stroke:"black"}),a.createElement("path",{d:"M0,-2L0,-8",markerEnd:"url(#arrow-end)",strokeWidth:"2",stroke:"black"})),a.createElement("g",{transform:"translate(6,25)"},a.createElement("line",{x1:"0",y1:"0",x2:"10",y2:"10",stroke:"black",strokeWidth:"3"}),a.createElement("circle",{cx:"0",cy:"0",r:"6",fill:"white",stroke:"black",strokeWidth:"2"})),a.createElement("g",{transform:"translate(6,50)"},a.createElement("circle",{cx:"0",cy:"0",r:"6",className:"node"}),a.createElement("g",{transform:"translate(2,-2)",dangerouslySetInnerHTML:{__html:n}})),a.createElement("g",{transform:"translate(6,75)"},a.createElement("circle",{cx:"0",cy:"0",r:"6",className:"node",style:{opacity:"0.33"}}),a.createElement("circle",{cx:"6",cy:"0",r:"6",className:"node",style:{opacity:"0.67"}}),a.createElement("circle",{cx:"12",cy:"0",r:"6",className:"node",style:{opacity:"1"}}),a.createElement("g",{transform:"translate(12,-2)",dangerouslySetInnerHTML:{__html:n}})),a.createElement("g",{transform:"translate(6,100)"},a.createElement("circle",{cx:"0",cy:"0",r:"6",className:"node painter-selected",style:{opacity:"1"}}),a.createElement("g",{transform:"translate(0,0)",dangerouslySetInnerHTML:{__html:t}})),a.createElement("g",{transform:"translate(6,125)"},a.createElement("path",{d:"M0,0L20,0",markerEnd:"url(#arrow-end)",stroke:"black",strokeWidth:"2"}),a.createElement("circle",{r:"6",className:"node"})),a.createElement("g",{transform:"translate(0,150)"},a.createElement("g",{transform:"scale(0.5)"},a.createElement("path",{d:"M0,0L40,0",className:"edge painter-selected",markerEnd:"url(#arrow-end)",stroke:"black",strokeWidth:"2"})),a.createElement("g",{transform:"translate(10,0)",dangerouslySetInnerHTML:{__html:t}})),a.createElement("g",{transform:"translate(0,175)"},a.createElement("g",{transform:"scale(0.5)"},a.createElement("path",{d:"M0,0L40,0",className:"edge painter-selected",markerEnd:"url(#arrow-end)",stroke:"black",strokeWidth:"2"})),a.createElement("text",{x:"3",y:"5"},"a")),a.createElement("g",{transform:"translate(0,5)"},a.createElement("text",{x:"40",y:"0"},"拖动空白区域"),a.createElement("text",{x:"40",y:"25"},"滚动鼠标轴"),a.createElement("text",{x:"40",y:"50"},"双击空白区"),a.createElement("text",{x:"40",y:"75"},"shift键后拖动结点"),a.createElement("text",{x:"40",y:"100"},"退格键删除结点"),a.createElement("text",{x:"40",y:"125"},"结点上新建边"),a.createElement("text",{x:"40",y:"150"},"退格键删除边"),a.createElement("text",{x:"40",y:"175"},"回车键输入权值"))))}})},12:function(e,n,t){e.exports='<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./graph.h"</span>\n\ngraph* GraphCreate(int n, size_t w_size) {\n    int i;\n    <span class="keyword">if</span> (n == <span class="number">0</span>) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    graph *g = SafeMalloc(sizeof(graph));\n    g->n = n;\n    g->w_size = w_size;\n    g->adja = SafeMalloc(n*(sizeof(graph_edge *)));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) {\n        g->adja[i] = SafeMalloc(sizeof(graph_edge));\n        g->adja[i]->next = <span class="keyword">NULL</span>;\n        g->adja[i]->w = <span class="keyword">NULL</span>;\n    }\n    <span class="keyword">return</span> g;\n}\n\nvoid GraphDestroy(graph *g) {\n    int i;\n    graph_edge *p, *e;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        e = g->adja[i];\n        <span class="keyword">while</span> (e != <span class="keyword">NULL</span>) {\n            p = e->next;\n            <span class="keyword">if</span> (e->w != <span class="keyword">NULL</span>) {\n                free(e->w);\n            }\n            free(e);\n            e = p;\n        }\n    }\n    free(g->adja);\n    free(g);\n}\n\nint GraphNodeValid(graph *g, int u) {\n    <span class="keyword">return</span> <span class="number">0</span> &lt;= u &amp;&amp; u &lt; g->n ? <span class="number">1</span> : <span class="number">0</span>;\n}\n\ngraph_edge* _GraphNewEdge(int u, int v, void *w, size_t w_size) {\n    graph_edge *e = SafeMalloc(sizeof(graph_edge));\n    e->u = u;\n    e->v = v;\n    e->w = SafeMalloc(w_size);\n    MemoryCopy(e->w, w, w_size);\n    <span class="keyword">return</span> e;\n}\n\ngraph_edge* GraphInsert(graph *g, int u, int v, void *w) {\n    graph_edge *e;\n    <span class="keyword">if</span> (!GraphNodeValid(g,u) || !GraphNodeValid(g,v)) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    e = _GraphNewEdge(u,v,w,g->w_size);\n    e->next = g->adja[u]->next;\n    g->adja[u]->next = e;\n    <span class="keyword">return</span> e;\n}'},13:function(e,n,t){e.exports='<span class="comment">#ifndef GRAPH_H</span>\n<span class="comment">#define GRAPH_H</span>\n<span class="comment">#include &lt;stddef.h></span>\n\ntypedef struct graph_edge {\n  int u;\n  int v;\n  void *w;\n  struct graph_edge *next;\n} graph_edge;\n\ntypedef struct graph {\n  int n;\n  size_t w_size;\n  graph_edge **adja;\n} graph;\n\ngraph* GraphCreate(int n, size_t w_size);\nvoid GraphDestroy(graph *g);\ngraph_edge* GraphInsert(graph *g, int u, int v, void *w);\ngraph_edge* GraphDelete(graph *g, int u, int v);\nint GraphNodeValid(graph *g, int u);\n\n<span class="comment">#endif</span>'},14:function(e,n,t){e.exports='<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./min-heap.h"</span>\n\nmin_heap* MinHeapCreate(int n, size_t item_size, int (*CompFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*)) {\n    int i;\n    min_heap* h = (min_heap*)SafeMalloc(sizeof(min_heap));\n    h-><span class="keyword">array</span> = SafeMalloc(n * sizeof(min_heap_pair));\n    h->capacity = n;\n    h->size = <span class="number">0</span>;\n    h->item_size = item_size;\n    h->Compare = CompFn;\n    h->map = SafeMalloc(n*sizeof(int));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) {\n        h-><span class="keyword">array</span>[i].item = <span class="keyword">NULL</span>;\n        h->map[i] = -<span class="number">1</span>;\n    }\n    <span class="keyword">return</span> h;\n}\n\nvoid MinHeapDestroy(min_heap *h) {\n    int i;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; h->capacity; ++i) {\n        <span class="keyword">if</span> (h-><span class="keyword">array</span>[i].item != <span class="keyword">NULL</span>) {\n            free(h-><span class="keyword">array</span>[i].item);\n        }\n    }\n    free(h-><span class="keyword">array</span>);\n    free(h->map);\n    free(h);\n}\n\nint _P(int x) {\n    <span class="keyword">return</span> x == <span class="number">0</span> ? <span class="number">0</span> : (x-<span class="number">1</span>)/<span class="number">2</span>;\n}\nint _L(int x) {\n    <span class="keyword">return</span> x*<span class="number">2</span>+<span class="number">1</span>;\n}\nint _R(int x) {\n    <span class="keyword">return</span> x*<span class="number">2</span>+<span class="number">2</span>;\n}\nvoid _Exchange(min_heap* h, int i, int j) {\n    min_heap_pair tmp;\n    tmp = h-><span class="keyword">array</span>[i];\n    h-><span class="keyword">array</span>[i] = h-><span class="keyword">array</span>[j];\n    h-><span class="keyword">array</span>[j] = tmp;\n    h->map[h-><span class="keyword">array</span>[i].key] = i;\n    h->map[h-><span class="keyword">array</span>[j].key] = j;\n}\n\nvoid _Swim(min_heap *h, int x) {\n    <span class="keyword">while</span> (x != <span class="number">0</span> &amp;&amp; h->Compare(h-><span class="keyword">array</span>[x].item, h-><span class="keyword">array</span>[_P(x)].item) &lt; <span class="number">0</span>) {\n        _Exchange(h, x, _P(x));\n        x = _P(x);\n    }\n}\n\nvoid _Sink(min_heap *h, int x) {\n    int y = -<span class="number">1</span>;\n    <span class="keyword">while</span> (x != y) {\n        y = x;\n        <span class="keyword">if</span> (_L(x) &lt; h->size &amp;&amp; h->Compare(h-><span class="keyword">array</span>[_L(x)].item, h-><span class="keyword">array</span>[x].item) &lt; <span class="number">0</span>) {\n            y = _L(x);\n        }\n        <span class="keyword">if</span> (_R(x) &lt; h->size &amp;&amp; h->Compare(h-><span class="keyword">array</span>[_R(x)].item, h-><span class="keyword">array</span>[y].item) &lt; <span class="number">0</span>) {\n            y = _R(x);\n        }\n        <span class="keyword">if</span> (y != x) {\n            _Exchange(h, x, y);\n            x = y;\n            y = -<span class="number">1</span>;\n        }\n    }\n}\n\nvoid MinHeapInsert(min_heap* h, void* item, int id) {\n    int x = h->size;\n    <span class="keyword">if</span> (x == h->capacity) {\n        <span class="keyword">return</span>;\n    }\n    h-><span class="keyword">array</span>[x].key = id;\n    h->map[id] = x;\n    <span class="keyword">if</span> (h-><span class="keyword">array</span>[x].item == <span class="keyword">NULL</span>) {\n        h-><span class="keyword">array</span>[x].item = SafeMalloc(h->item_size);\n    }\n    MemoryCopy(h-><span class="keyword">array</span>[x].item, item, h->item_size);\n    h->size++;\n    _Swim(h, x);\n}\n\nvoid* MinHeapPop(min_heap* h) {\n    void* item = SafeMalloc(h->item_size);\n    <span class="keyword">if</span> (h->size == <span class="number">0</span>) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    MemoryCopy(item, h-><span class="keyword">array</span>[<span class="number">0</span>].item, h->item_size);\n    h->map[h-><span class="keyword">array</span>[<span class="number">0</span>].key] = -<span class="number">1</span>;\n    MemoryCopy(h-><span class="keyword">array</span>[<span class="number">0</span>].item, h-><span class="keyword">array</span>[h->size-<span class="number">1</span>].item, h->item_size);\n    h-><span class="keyword">array</span>[<span class="number">0</span>].key = h-><span class="keyword">array</span>[h->size-<span class="number">1</span>].key;\n    h->map[h-><span class="keyword">array</span>[<span class="number">0</span>].key] = <span class="number">0</span>;\n    free(h-><span class="keyword">array</span>[h->size-<span class="number">1</span>].item);\n    h-><span class="keyword">array</span>[h->size-<span class="number">1</span>].item = <span class="keyword">NULL</span>;\n    h->size--;\n    _Sink(h, <span class="number">0</span>);\n    <span class="keyword">return</span> item;\n}\n\nvoid *MinHeapUpdate(min_heap *h, void *item, int id) {\n    int i;\n    int rc;\n    <span class="keyword">if</span> (id &lt; <span class="number">0</span> || id >= h->capacity) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    i = h->map[id];\n    rc = h->Compare(h-><span class="keyword">array</span>[i].item, item);\n    MemoryCopy(h-><span class="keyword">array</span>[i].item, item, h->item_size);\n    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) {\n        _Sink(h, i);\n        <span class="keyword">return</span> item;\n    } <span class="keyword">else</span> <span class="keyword">if</span> (rc > <span class="number">0</span>) {\n        _Swim(h, i);\n        <span class="keyword">return</span> item;\n    }\n    <span class="keyword">return</span> <span class="keyword">NULL</span>;\n}'},15:function(e,n,t){e.exports='<span class="comment">#ifndef MIN_HEAP_H</span>\n<span class="comment">#define MIN_HEAP_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\ntypedef struct min_heap_pair {\n    void *item;\n    int key;\n} min_heap_pair;\n\ntypedef struct min_heap {\n    int size;\n    int capacity;\n    size_t item_size;\n    min_heap_pair* <span class="keyword">array</span>;\n    int (*Compare)(<span class="keyword">const</span> void* a, <span class="keyword">const</span> void* b);\n    int* map;\n} min_heap;\n\nmin_heap* MinHeapCreate(int n, size_t item_size, int (*CompFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*));\nvoid MinHeapInsert(min_heap* h, void* item, int id);\nvoid* MinHeapPop(min_heap* h);\nvoid MinHeapDestroy(min_heap* h);\nvoid *MinHeapUpdate(min_heap *h, void *item, int id);\n\n<span class="comment">#endif</span>'},20:function(e,n,t){var a=t(10);"string"==typeof a&&(a=[[e.id,a,""]]);t(9)(a,{})},21:function(e,n,t){function a(e){this.array=[],this.cf=e,this.map=[]}a.prototype.p=function(e){return 0==e?0:Math.floor((e-1)/2)},a.prototype.l=function(e){return 2*e+1},a.prototype.r=function(e){return 2*e+2},a.prototype.ex=function(e,n){var t=this.array[e];this.array[e]=this.array[n],this.array[n]=t,this.map[this.array[e].k]=e,this.map[this.array[n].k]=n},a.prototype.swim=function(e){for(;0!=e&&this.cf(this.array[e].v,this.array[this.p(e)].v)<0;)this.ex(e,this.p(e)),e=this.p(e)},a.prototype.sink=function(e){for(var n=-1;e!==n;)n=e,void 0!==this.array[this.l(e)]&&this.cf(this.array[this.l(e)].v,this.array[e].v)<0&&(n=this.l(e)),void 0!==this.array[this.r(e)]&&this.cf(this.array[this.r(e)].v,this.array[n].v)<0&&(n=this.r(e)),n!=e&&(this.ex(e,n),e=n,n=-1)},a.prototype.insert=function(e,n){this.array.push({v:e,k:n}),this.map[n]=this.array.length-1,this.swim(this.array.length-1)},a.prototype.pop=function(){if(0!==this.array.length){var e=this.array[0];return this.ex(0,this.array.length-1),this.array.pop(),this.map[e.k]=void 0,this.sink(0),e.v}},a.prototype.update=function(e,n){if(!(0>n||n>=this.array.length)){var t=this.map[n],a=this.cf(this.array[t].v,e);this.array[t].v=e,0>a?this.sink(t):a>0&&this.swim(t)}},a.prototype.forceUpdate=function(e){var n=this.map[e];this.sink(n),this.swim(n)},e.exports=a},22:function(e,n,t){function a(e){ce=!1,Y=e.container||document.body,T=I.select(e.container).append("svg").node(),U=e.weighted||!1,q=e.directional||!1,R=e.width||T.clientWidth||e.container.clientWidth,O=e.height||T.clientHeight||e.container.clientHeight,oe=e.offsetLeft||0,ie=e.offsetTop||0,Q.nodes=e.nodes||I.range(e.n||5).map(function(){return{}}),Q.edges=(e.edges||I.range(5).map(function(e){return{u:e,v:(e+1)%5}})).map(function(e){return{source:Q.nodes[e.u],target:Q.nodes[e.v],val:e.w,reflexive:e.reflexive}}),j=void 0,B=e._onSelected||void 0,_onLoad=e._onLoad||void 0,se=void 0,re=!1,I.select(T).call(ae).on("dblclick.zoom",null).on("dblclick.svg",A);var n=I.select(T).append("defs");return n.append("marker").attr("id","arrow-end").attr("viewBox","0 -5 10 10").attr("refX",7).attr("refY",0).attr("markerWidth",ee).attr("markerHeight",ee).attr("orient","auto").append("path").attr("d","M0,-5L10,0L0,5"),n.append("marker").attr("id","arrow-start").attr("viewBox","0 -5 10 10").attr("refX",3).attr("refY",0).attr("markerWidth",ee).attr("markerHeight",ee).attr("orient","auto").append("path").attr("d","M10,-5L0,0L10,5"),G=I.select(T).append("g").attr("class","svg-entry"),H=G.append("g").attr("class","base"),F=H.append("g").attr("class","edges").classed("directional",q).classed("weighted",U),W=H.append("g").attr("class","nodes"),$=G.append("g").attr("class","text").attr("transform","translate(0,7)"),F.append("path").attr("class","drag").attr("marker-end","url(#arrow-end)").style("display","none"),I.select(window).on("keydown.window",E),ne.nodes(Q.nodes).links(Q.edges).size([R,O]),u(),C(!1),ne.on("end",function(){C(),ne.on("end",null),_onLoad&&_onLoad()}),e.nowait&&(d(),ne.on("end")()),this}function s(e,n){var t=e.x-n.x,a=e.y-n.y;return K*K>=t*t+a*a}function r(e,n){var t=Math.PI*n/180;return{x:e.x*Math.cos(t)+e.y*Math.sin(t),y:e.x*-Math.sin(t)+e.y*Math.cos(t)}}function i(e){return"translate("+e.x+","+e.y+")"}function o(e){return{x:-e.x,y:-e.y}}function c(e,n){return{x:e.x-n.x,y:e.y-n.y}}function l(e){return void 0===e.val?"":e.val}function p(e){var n=e.target.x-e.source.x,t=e.target.y-e.source.y,a=Math.sqrt(n*n+t*t),i=I.interpolate(e.source,e.target)(K/a),l=I.interpolate(e.target,e.source)(K/a),p=I.interpolate(30,0)(K/a);if(q&&U){var d=Q.edges.filter(function(n){return n.target===e.source&&(n.source===e.target||s(e.target,n.source))});return d.length>0?(e.curve=!0,i=c(r(c(i,e.source),p),o(e.source)),l=c(r(c(l,e.target),-p),o(e.target)),"M"+i.x+","+i.y+"A"+a+","+a+" 0 0,1 "+l.x+","+l.y):(e.curve=!1,"M"+i.x+","+i.y+"L"+l.x+","+l.y)}return e.curve=!1,"M"+i.x+","+i.y+"L"+l.x+","+l.y}function d(){W.selectAll(".node").data(Q.nodes).classed("painter-selected",function(e){return e===j}).attr("transform",i),$.selectAll(".node").data(Q.nodes).attr("transform",i).text(function(e,n){return n}),F.selectAll(".edge").data(Q.edges).classed("painter-selected",function(e){return e===j}).attr("marker-end",q?"url(#arrow-end)":null).attr("marker-start",q&&U===!1?function(e){return e.reflexive?"url(#arrow-start)":null}:null).attr("d",p),U&&(F.selectAll(".edge").each(function(e){var n=this.getPointAtLength(this.getTotalLength()/2);e.x=n.x,e.y=n.y}),$.selectAll(".edge").data(Q.edges).attr("transform",i).text(l))}function u(){W.selectAll(".node").data(Q.nodes).enter().append("circle").attr("class","node").attr("r",K).on("dblclick.node",m).call(te).on("click.select",x).on("mousedown.node",v).on("mouseup.node",w),W.selectAll(".node").data(Q.nodes).exit().remove(),$.selectAll(".node").data(Q.nodes).enter().append("text").attr("class","node"),$.selectAll(".node").data(Q.nodes).exit().remove(),F.selectAll(".edge").data(Q.edges).enter().append("path").attr("class","edge").on("click.select",x),F.selectAll(".edge").data(Q.edges).exit().remove(),U?($.selectAll(".edge").data(Q.edges).enter().append("text").attr("class","edge"),$.selectAll(".edge").data(Q.edges).exit().remove()):$.selectAll(".edge").remove(),ne.start()}function h(){R=T.clientWidth||Y.clientWidth,O=T.clientHeight||Y.clientHeight,ne.size([R,O]).resume()}function m(e){I.event.stopPropagation(),I.select(this).classed("fixed",e.fixed=!1),ne.resume()}function f(e){e.fixed|=2}function g(e){se&&(re?(I.select(this).classed("fixed",e.fixed=!0),e.px=I.event.x||I.event.clientX,e.py=I.event.y||I.event.clientY,ne.resume()):s(I.event,e)===!1?F.select("path.drag").datum({source:e,target:{x:I.event.x||I.event.clientX,y:I.event.y||I.event.clientY}}).attr("d",p).style("display",null):F.select("path.drag").style("display","none"))}function y(e){e.fixed&=-7,F.select("path.drag").style("display","none")}function v(e){(I.event.ctrlKey===!1||void 0===I.event.ctrlKey)&&(I.event.stopPropagation(),se=e,re=I.event.shiftKey?!0:!1)}function w(e){if(se&&se!==e){var n={source:se,target:e};k(n),u()}se=void 0,re=!1}function x(e,n){j=j===e?void 0:e,n===!0&&(j=e),j&&B&&B(),ne.resume()}function k(e){var n;q===!1?(n=Q.edges.filter(function(n){return n.source===e.source&&n.target===e.target||n.target===e.source&&n.source===e.target}),n.length>0?e=n[0]:Q.edges.push(e)):U?(n=Q.edges.filter(function(n){return n.source===e.source&&n.target===e.target}),n.length>0?e=n[0]:Q.edges.push(e)):(n=Q.edges.filter(function(n){return n.source===e.source&&n.target===e.target||n.target===e.source&&n.source===e.target}),n.length>0?(n[0].source===e.target&&(n[0].reflexive=!0),e=n[0]):Q.edges.push(e)),x(e,!0)}function _(){var e=void 0===j||void 0===j.val?"数字":j.val;return prompt("权值",e)}function b(e){var n=e();return""===n?void delete j.val:(n=parseFloat(n),isNaN(n)||j.val===n?void 0:(j.val=n,u(),this))}function E(){j&&(8===I.event.keyCode?(I.event.preventDefault(),L()):13===I.event.keyCode&&U&&b(_))}function L(){var e=Q.nodes.indexOf(j);return-1!==e?(Q.nodes.splice(e,1),Q.edges.filter(function(e){return e.source===j||e.target===j}).forEach(function(e){Q.edges.splice(Q.edges.indexOf(e),1)})):(e=Q.edges.indexOf(j),-1!=e&&Q.edges.splice(Q.edges.indexOf(j),1)),j=void 0,u(),this}function S(){X=I.event.translate,J=I.event.scale,G.attr("transform","translate("+I.event.translate+")scale("+I.event.scale+")")}function M(){var e=document.documentElement;return{left:(window.pageXOffset||e.scrollLeft)-(e.clientLeft||0),top:(window.pageYOffset||e.scrollTop)-(e.clientTop||0)}}function A(){if(I.event.target===this){var e=I.event.x||I.event.clientX||I.event.clientX,n=I.event.y||I.event.clientY||I.event.clientY,t=M();e+=t.left-oe,n+=t.top-ie;var a={x:(e-X[0])/J,y:(n-X[1])/J};Q.nodes.push(a),x(a),u()}}function C(e){return j&&(F.select(".painter-selected").classed("painter-selected",!1),W.select(".painter-selected").classed("painter-selected",!1),j=void 0),U&&(Q.edges.forEach(function(e){void 0===e.val&&(e.val=1)}),d()),e!==!1&&ne.stop(),I.select(window).on("resize",null).on("keydown.window",null),I.select(T).on("dblclick.svg",null),W.selectAll("circle.node").on("dblclick.node",null).on("dragstart",null).on("drag",null).on("dragend",null).on("click.select",null).on("mousedown.node",null).on("mouseup.node",null),F.selectAll("path.edge").on("click.select",null),this}function z(e,n){function t(e,n){return e.source===n.target&&e.target===n.source}if(q!==e||U!==n){pd=q,q=e,U=n;var a=[];return Q.edges.forEach(function(e){q?U?((pd===!1||e.reflexive)&&a.push({source:e.target,target:e.source,val:e.val}),delete e.reflexive,a.push(e)):(delete e.reflexive,a.some(function(n){return t(e,n)})===!1&&((pd===!1||Q.edges.some(function(n){return t(e,n)})===!0)&&(e.reflexive=!0),a.push(e))):a.some(function(n){return t(e,n)})===!1&&(delete e.reflexive,a.push(e))}),Q.edges=a,F.classed("directional",q).classed("weighted",U),u(),this}}function D(){ne.start(),I.select(window).on("resize",h).on("keydown.window",E),I.select(T).on("dblclick.svg",A),W.selectAll("circle.node").on("dblclick.node",m).call(te).on("click.select",x).on("mousedown.node",v).on("mouseup.node",w),F.selectAll("path.edge").on("click.select",x)}function N(){Q.nodes.length=0,Q.edges.length=0,u()}function P(){}var I=t(4);t(20);var T,U,q,R,O,j,B,G,H,F,W,$,Y,Q={},X=[0,0],J=1,K=15,V=150,Z=-600,ee=3,ne=I.layout.force().linkDistance(V).charge(Z).on("tick",d),te=I.behavior.drag().origin(function(e){return e}).on("dragstart",f).on("drag",g).on("dragend",y),ae=I.behavior.zoom().scaleExtent([.1,10]).on("zoom",S),se=void 0,re=!1,ie=0,oe=0,ce=!1;e.exports={stop:C,convert:z,weighSelected:b,deleteSelected:L,init:a,restart:D,clear:N,random:P,directional:function(){return q},weighted:function(){return U},raw:function(){return Q},data:function(){var e=Q.edges.map(function(e){return{u:e.source.index,v:e.target.index,w:e.val}});return q||(e=e.concat(Q.edges.map(function(e){return{u:e.target.index,v:e.source.index,w:e.val}}))),q&&!U&&(e=e.concat(Q.edges.filter(function(e){return e.reflexive}).map(function(e){return{u:e.target.index,v:e.source.index,w:e.val}}))),{weighted:U,directional:q,n:Q.nodes.length,e:e}}}},30:function(e,n,t){function a(e,n){return e.w===g||n.w===y?-1:e.w===y||n.w===g?1:e.w-n.w}function s(e,n){void 0===n?u[e].pop():u[e].push(n)}function r(){var e,n,t,r,i,c;if(!(m.n<=1)){for(n=[],t=new f(a),i=[],u.pns=i,o(39,1),e=0;e<m.n;++e)i[e]={i:e},i[e].w=0===e?g:y,i[e].e=void 0,t.insert(i[e],e);for(e=0;o(45,1),e<m.n;++e){if(o(46),c=t.pop(),s("hl",c.i),o(47,1),void 0!==c.e&&(o(48,1),n[e-1]=c.e,s("ine",c.e)),o(50,1),i[c.i].w=g,o(51,1),e===m.n-1){s("hl"),o(52,1);break}for(r=0;o(54,1),s("se"),s("hle"),r<m.e[c.i].length;r++){var l=m.e[c.i][r];o(55,1),s("se",l),s("hle",l),(i[l.v].w===y||i[l.v].w!==g&&i[l.v].w-l.w>0)&&(s("ine",l),i[l.v].w=l.w,i[l.v].e=l,o(60,1),t.forceUpdate(l.v),s("ine"))}s("hl")}return o(67,1),n}}function i(e){m.n=e.n,m.e=[];for(var n=0;n<m.n;++n)m.e.push([]);e.e.forEach(function(e){m.e[e.u].push(e)})}function o(e,n,t){1===n&&(lastStatus=u.clone()),p.push({status:lastStatus,line:e,animation:t,id:d}),d++}function c(){0===p.length?0:p[p.length-1].line;o(115,1)}var l=t(6),p=[],d=0,u={},h=0,m={},f=t(21),g="-",y="+";u.clone=function(){return{neg:g,pos:y,ine:l(this.ine)||[],se:l(this.se)||[],hl:l(this.hl)||[],hle:l(this.hle)||[],pns:l(this.pns)||[]}},u.init=function(e){this.se=[],this.ine=[],this.pns=[],this.hl=[],this.hle=[]},lastStatus={},e.exports={initialize:function(e){return p=[],d=0,e&&(h=0),u.init(e),lastStatus=u.clone(),this},prim:r,run:function(e,n){return i(n.g),this.initialize()[e](),c(),{frames:p,others:{}}}}},43:function(e,n,t){n=e.exports=t(7)(),n.push([e.id,"path.ine{stroke-width:20px;stroke:#00bfff;fill:none;stroke-opacity:.5}.node.visited{fill:#00bfff}path.edge.highlighted{stroke-width:6px}",""])},63:function(e,n,t){var a=t(1);e.exports=a.createClass({displayName:"module.exports",render:function(){var e={display:this.props.show?"block":"none"};return a.createElement("svg",{className:"legend",width:"210",height:"190",style:e},a.createElement("rect",{className:"outline",stroke:"black",x:"0",y:"0",width:"200",height:"170"}),a.createElement("g",{transform:"translate(15,20)"},a.createElement("g",{transform:"translate(0,0)"},a.createElement("g",{transform:"scale(0.5)"},a.createElement("path",{d:"M0,0L50,0",className:"edge painter-selected"}))),a.createElement("g",{transform:"translate(0,25)"},a.createElement("g",{transform:"scale(0.5)"},a.createElement("path",{d:"M0,0L50,0",className:"ine"}))),a.createElement("g",{transform:"translate(6,50)"},a.createElement("circle",{cx:"0",cy:"0",r:"6",className:"node highlighted"})),a.createElement("g",{transform:"translate(6,75)"},a.createElement("circle",{cx:"0",cy:"0",r:"6",className:"node visited"})),a.createElement("g",{transform:"translate(6,100)"},a.createElement("circle",{r:"6",className:"node"}),a.createElement("path",{d:"M0,0L0,-6A6,6 0 0,1 5.19,3Z",className:"inq"})),a.createElement("g",{transform:"translate(6,125)"},a.createElement("circle",{r:"6",className:"node"}),a.createElement("text",{x:"2",y:"-2",fontSize:"10px"},"距离")),a.createElement("g",{transform:"translate(0,5)"},a.createElement("text",{x:"40",y:"0"},"更新源"),a.createElement("text",{x:"40",y:"25"},"最小生成树"),a.createElement("text",{x:"40",y:"50"},"当前结点"),a.createElement("text",{x:"40",y:"75"},"生成树结点"),a.createElement("text",{x:"40",y:"100"},"可加入结点"),a.createElement("text",{x:"40",y:"125"},"到生成树的距离"))))}})},64:function(e,n,t){t(133);var a=t(1),s=t(5),r=t(22),i=t(146),o=t(63),c=t(11);e.exports=a.createClass({displayName:"module.exports",getInitialState:function(){return{painting:!1,loaded:!1,text:"",demo:"",help:!0}},componentDidMount:function(){r.init({container:this.refs.svg.getDOMNode(),offsetTop:document.querySelector(".dsa-app").offsetTop+55,offsetLeft:document.querySelector(".dsa-app").offsetLeft+80,_onLoad:this._onLoad,nodes:[{x:50,y:50,fixed:!0},{x:50,y:250,fixed:!0},{x:150,y:150,fixed:!0},{x:250,y:250,fixed:!0},{x:150,y:350,fixed:!0},{x:250,y:450,fixed:!0},{x:350,y:50,fixed:!0},{x:450,y:350,fixed:!0},{x:450,y:150,fixed:!0}],edges:[{u:0,v:1,w:8},{u:0,v:2,w:12},{u:1,v:2,w:13},{u:1,v:3,w:25},{u:1,v:4,w:9},{u:2,v:3,w:14},{u:2,v:6,w:21},{u:3,v:4,w:20},{u:3,v:5,w:8},{u:3,v:6,w:12},{u:3,v:7,w:12},{u:3,v:8,w:16},{u:4,v:5,w:19},{u:5,v:7,w:11},{u:6,v:8,w:11},{u:7,v:8,w:9}],directional:!1,weighted:!0,nowait:!0}),i.init(r.raw())},componentDidUpdate:function(e){this.props!==e&&void 0!==this.props.frame&&this.props.frame&&i.render(this.props.frame.status,this.props.delay,this.props.others)},render:function(){var e=this.state.painting?a.createElement(c,{show:this.state.help}):a.createElement(o,{show:this.state.help});return a.createElement("div",{className:"wrapper-code"},a.createElement("div",{className:"list"},this.getInputList()),a.createElement("div",{ref:"svg",
className:"scene"}),e)},_onLoad:function(){this.setState({loaded:!0})},_onPainting:function(){this.state.painting?r.stop():(i.clear(),s.pauseDemo(),s.waitDemo(),r.restart()),this.setState({painting:!this.state.painting,demo:""})},_onClick:function(e){this.setState({demo:e}),i.clear(),i.init(r.raw()),s.runDemo(e,{g:r.data(),x:this.state.text})},_onHelp:function(){this.setState({help:!this.state.help})},getInputList:function(){if(this.state.loaded===!1)return a.createElement("input",{className:"input-button",readOnly:!0,value:"加载中",title:"加载中"});var e=this;if(this.state.painting){var n=[{onClick:r.clear,value:"清空"},{onClick:this._onPainting,value:"完成"},{help:this.state.help,onClick:this._onHelp,value:"帮助"}];return a.createElement("div",null,n.map(function(n,t){var s="input-group"+(n.value===e.state.graphType||n.help?" input-current":"");return a.createElement("div",{key:t,className:s},a.createElement("input",{className:"input-button",readOnly:!0,onClick:n.onClick,value:n.value,title:n.value}))}))}var n=[{button:{demo:"prim",onClick:this._onClick.bind(this,"prim"),value:"Prim最小生成树"}},{button:{demo:"",onClick:this._onPainting,value:"编辑图"}},{button:{help:this.state.help,onClick:this._onHelp,value:"帮助"}}];return a.createElement("div",null,n.map(function(n,t){var s="input-group"+(n.button.demo===e.state.demo||n.button.help?" input-current":""),r=n.items?n.items:[];return a.createElement("div",{key:t,className:s},a.createElement("input",{className:"input-button",readOnly:!0,onClick:n.button.onClick,value:n.button.value,title:n.button.value}),a.createElement("div",null,r.map(function(e,n){return a.createElement("input",{key:n,className:"input-item",onChange:e.onChange,value:e.value,title:e.value,placeholder:e.placeholder})})))}))}})},97:function(e,n,t){e.exports="CC=gcc\nCFLAGS=-c -Wall\nLDFLAGS=\nSOURCES=test.c ../common/util.c ../common/util.h ../common/graph.c ../common/graph.h ../min-heap/min-heap.c ../min-heap/min-heap.h ./mst.c ./mst.h\nOBJECTS=$(SOURCES:.c=.o)\nEXECUTABLE=a.out\n\nall: $(SOURCES) $(EXECUTABLE)\n\n$(EXECUTABLE): $(OBJECTS)\n    $(CC) $(LDFLAGS) $(OBJECTS) -o $@\n\n.cpp.o:\n    $(CC) $(CFLAGS) $&lt; -o $@\n\nclean:\n    rm -rf *.o a.out"},98:function(e,n,t){e.exports='<span class="comment">#include "../common/graph.h"</span>\n<span class="comment">#include "../min-heap/min-heap.h"</span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include &lt;stdlib.h></span>\n\ntypedef struct prim_node {\n    int i;\n    void *w;\n    graph_edge *e;\n} prim_node;\n\nint (*_gGraphEdgeWeightCompare)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*);\nint _gNegInfinity = <span class="number">0</span>;\nint _gPosInfinity = <span class="number">0</span>;\n\nint _GraphPrimNodeCompare(<span class="keyword">const</span> void *a, <span class="keyword">const</span> void *b) {\n    <span class="keyword">if</span> (((prim_node *)a)->w == &amp;_gNegInfinity || ((prim_node *)b)->w == &amp;_gPosInfinity) {\n        <span class="keyword">return</span> -<span class="number">1</span>;\n    } <span class="keyword">else</span> <span class="keyword">if</span> (((prim_node *)a)->w == &amp;_gPosInfinity || ((prim_node *)b)->w == &amp;_gNegInfinity) {\n        <span class="keyword">return</span> <span class="number">1</span>;\n    }\n    <span class="keyword">return</span> _gGraphEdgeWeightCompare(((prim_node *)a)->w, ((prim_node *)b)->w);\n}\n\ngraph_edge **GraphPrim(graph *g, int (*CompFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*)) {\n    int i;\n    graph_edge **mst;\n    min_heap *mh;\n    graph_edge *e;\n    prim_node *pns;\n    prim_node *pn;\n    <span class="keyword">if</span> (g->n &lt;= <span class="number">1</span>) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    _gGraphEdgeWeightCompare = CompFn;\n    mst = SafeMalloc((g->n-<span class="number">1</span>)*sizeof(graph_edge *));\n    mh = MinHeapCreate(g->n, sizeof(prim_node), _GraphPrimNodeCompare);\n    pns = SafeMalloc(g->n*sizeof(prim_node));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        pns[i].i = i;\n        pns[i].w = (i == <span class="number">0</span> ? &amp;_gNegInfinity : &amp;_gPosInfinity);\n        pns[i].e = <span class="keyword">NULL</span>;\n        MinHeapInsert(mh, &amp;pns[i], i);\n    }\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        pn = MinHeapPop(mh);\n        <span class="keyword">if</span> (pn->e != <span class="keyword">NULL</span>) {\n            mst[i-<span class="number">1</span>] = pn->e;\n        }\n        pns[pn->i].w = &amp;_gNegInfinity;\n        <span class="keyword">if</span> (i == g->n-<span class="number">1</span>) {\n            <span class="keyword">break</span>;\n        }\n        <span class="keyword">for</span> (e = g->adja[pn->i]->next; e != <span class="keyword">NULL</span>; e = e->next) {\n            <span class="keyword">if</span> (pns[e->v].w == &amp;_gPosInfinity ||\n                        (pns[e->v].w != &amp;_gNegInfinity &amp;&amp; _gGraphEdgeWeightCompare(pns[e->v].w, e->w) > <span class="number">0</span>)\n                ) {\n                pns[e->v].w = e->w;\n                pns[e->v].e = e;\n                MinHeapUpdate(mh, &amp;pns[e->v], e->v);\n            }\n        }\n        free(pn);\n    }\n    MinHeapDestroy(mh);\n    free(pns);\n    <span class="keyword">return</span> mst;\n}'},99:function(e,n,t){e.exports='<span class="comment">#ifndef PRIM_H</span>\n<span class="comment">#define PRIM_H</span>\n\n<span class="comment">#include "../common/graph.h"</span>\n\ngraph_edge **GraphPrim(graph *g, int (*CompFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*));\n\n<span class="comment">#endif</span>'},100:function(e,n,t){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/graph.h"</span>\n<span class="comment">#include "./mst.h"</span>\n\nint Compare(<span class="keyword">const</span> void *a, <span class="keyword">const</span> void *b) {\n    <span class="keyword">return</span> *(int *)a - *(int *)b;\n}\n\nint main(int argc, char <span class="keyword">const</span> *argv[])\n{\n    int n, m, i, u, v, w;\n    graph *g;\n    graph_edge **mst;\n    int sum = <span class="number">0</span>;\n    <span class="keyword">while</span> (scanf(<span class="string">"%d%d"</span>, &amp;n,&amp;m) != EOF) {\n        g = GraphCreate(n, sizeof(int));\n        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++i) {\n            scanf(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);\n            GraphInsert(g, u, v, &amp;w);\n            GraphInsert(g, v, u, &amp;w);\n        }\n        mst = GraphPrim(g, Compare);\n        sum = <span class="number">0</span>;\n        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n-<span class="number">1</span>; ++i) {\n            printf (<span class="string">"u = %d, v = %d, w = %d\\n"</span>, mst[i]->u, mst[i]->v, *(int *)(mst[i]->w));\n            sum += *(int *)(mst[i]->w);\n        }\n        printf(<span class="string">"sum = %d\\n"</span>, sum);\n        free(mst);\n        GraphDestroy(g);\n    }\n    <span class="keyword">return</span> <span class="number">0</span>;\n}'},133:function(e,n,t){var a=t(43);"string"==typeof a&&(a=[[e.id,a,""]]);t(9)(a,{})},146:function(e,n,t){function a(e){return"translate("+k.nodes[e].x+","+k.nodes[e].y+")"}function s(){function e(e){return e.i}function n(e){return a(e.i)}function t(e){return(i.indexOf(e.w)+1)/i.length*E}function s(e,n){return v.pns[n]&&v.pns[n].w===v.neg}var r=v.pns.filter(function(e){return!isNaN(e.w)}),i=_.set(r.map(function(e){return e.w})).values().map(parseFloat).sort(_.descending);gnodes.selectAll("path.inq").data(r,e).enter().append("path").attr("class","inq").attr("d",function(e){return L({endAngle:0})}).attr("transform",n).each(function(e){this._current={endAngle:0}}),gnodes.selectAll("path.inq").data(r,e).transition().duration(w).attr("transform",n).attrTween("d",function(e,n){var a=_.interpolate(this._current,{endAngle:t(e,n)});return this._current=a(0),function(e){return L(a(e))}}),gnodes.selectAll("path.inq").data(r,e).exit().remove(),gnodes.selectAll("circle.node").classed("visited",s),y.selectAll("text.node").classed("visited",s),gprimtext.selectAll("text.dist").data(v.pns,e).enter().append("text").attr("class","dist").attr("transform",n),gprimtext.selectAll("text.dist").data(v.pns,e).attr("transform",n).text(function(e){return e.w===v.neg?"-∞":e.w===v.pos?"+∞":e.w}),gprimtext.selectAll("text.dist").data(v.pns,e).exit().remove(),gnodes.selectAll("circle.node").classed("highlighted",function(e,n){return n===v.hl[0]})}function r(e){return e.u+"-"+e.v}function i(e,n,t){return t===!0?n.u===e.source.index&&n.v===e.target.index:t===!1?n.v===e.source.index&&n.u===e.target.index:n.u===e.source.index&&n.v===e.target.index||n.v===e.source.index&&n.u===e.target.index}function o(e){var n=k.edges.filter(function(n){return i(n,e)})[0];return{source:n.source.index===e.u?n.source:n.target,target:n.target.index===e.v?n.target:n.source}}function c(e){return function(n){var t=o(n),a=t.source.x-t.target.x,s=t.target.y-t.source.y,r=(Math.sqrt(a*a+s*s),"exit"===e?_.interpolate(t.target,t.source):_.interpolate(t.source,t.target)),i=t.source;return function(e){var n=r(e);return"M"+i.x+","+i.y+"L"+n.x+","+n.y}}}function l(e){return v.se.concat(v.pns.filter(function(e){return e.w!==v.neg}).map(function(e){return e.e})).some(function(n){return n&&i(e,n)})}function p(e){return v.se.concat(v.pns.filter(function(e){return e.w!==v.neg}).map(function(e){return e.e})).some(function(n){return n&&i(e,n,!1)})}function d(){gedges.selectAll("path.edge").classed("painter-selected",l).classed("rev-dir",p).classed("highlighted",function(e){return v.hle.some(function(n){return n&&i(e,n)})}),gedges.selectAll("path.ine").data(v.ine,r).enter().insert("path",":first-child").attr("class","ine").transition().duration(w).attrTween("d",c("update")),gedges.selectAll("path.ine").data(v.ine,r).exit().transition().duration(w).attrTween("d",c("exit")).remove()}function u(e,n,t){v=e,w=n,x=t}function h(e,n,t){u(e,n,t),s(),d()}function m(e){k=e,g=_.select("g.base"),y=_.select("g.text"),gnodes=_.select("g.nodes"),gedges=_.select("g.edges"),_.selectAll("g.prim").remove(),gprimtext=y.append("g").attr("class","prim").attr("transform","translate(15,-15)")}function f(){gnodes.selectAll("path.inq").remove(),gedges.selectAll("path.edge").attr("class","edge"),gedges.selectAll("path.ine").remove(),gnodes.selectAll("circle.node").attr("class","node"),y.selectAll("text.node").attr("class","node"),gprimtext.remove()}var g,y,v,w,x,k,_=t(4),b=(t(8),15),E=2*Math.PI,L=_.svg.arc().innerRadius(0).outerRadius(b).startAngle(0);e.exports={init:m,render:h,clear:f}}});