webpackJsonpdsa([2],{1:function(e,n,t){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "./util.h"</span>\n\nvoid* SafeMalloc(size_t size) {\n    void* m;\n    <span class="keyword">if</span> ((m = malloc(size))) {\n        <span class="keyword">return</span> m;\n    } <span class="keyword">else</span> {\n        printf(<span class="string">"memory overflow\\n"</span>);\n        <span class="keyword">exit</span>(-<span class="number">1</span>);\n        <span class="keyword">return</span> <span class="number">0</span>;\n    }\n}\n\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">// }</span>\n    memcpy(a, b, size);\n}\n\nvoid MemorySwap(void *a, void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// char t;</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     t = *(char *)a;</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">//     *((char *)b + i) = t;</span>\n    <span class="comment">// }</span>\n    void *t = SafeMalloc(size);\n    memcpy(t, a, size);\n    memcpy(a, b, size);\n    memcpy(b, t, size);\n}\n\nvoid MemoryClear(void *a, size_t size) {\n    memset(a, <span class="number">0</span>, size);\n}\n\nvoid *MemoryAddress(void *a, int i, size_t size) {\n    <span class="keyword">return</span> (char *)a + i*size;\n}'},2:function(e,n,t){e.exports='<span class="comment">#ifndef UTIL_H</span>\n<span class="comment">#define UTIL_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\nvoid * SafeMalloc(size_t size);\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size);\nvoid MemorySwap(void *a, void *b, size_t size);\nvoid MemoryClear(void *a, size_t size);\n\n<span class="comment">#endif</span>'},15:function(e,n,t){n=e.exports=t(8)(),n.push([e.id,"circle.node{fill:#ccc;stroke:#000;stroke-width:1.5px}circle.node.painter-selected{fill:#000}circle.node.highlighted{stroke-dasharray:10 2;-webkit-animation:dash .4s linear infinite;animation:dash .4s linear infinite}text.edge,text.node{fill:#000;font:20px sans-serif;pointer-events:none;text-anchor:middle;text-shadow:0 1px 0 #fff,1px 0 0 #fff,0 -1px 0 #fff,-1px 0 0 #fff}path.drag,path.edge{fill:none;stroke:#000;stroke-width:4px}path.edge.painter-selected{stroke-dasharray:10 2;-webkit-animation:dash .4s linear infinite;animation:dash .4s linear infinite}path.edge.painter-selected.rev-dir{-webkit-animation-direction:reverse;animation-direction:reverse}path.edge.painter-selected.rev-dir.sam-dir{-webkit-animation-direction:alternate;animation-direction:alternate}@-webkit-keyframes dash{from{stroke-dashoffset:12}to{stroke-dashoffset:0}}@keyframes dash{from{stroke-dashoffset:12}to{stroke-dashoffset:0}}",""])},16:function(e,n,t){e.exports='<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./graph.h"</span>\n\ngraph* GraphCreate(int n, size_t w_size) {\n    int i;\n    <span class="keyword">if</span> (n == <span class="number">0</span>) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    graph *g = SafeMalloc(sizeof(graph));\n    g->n = n;\n    g->w_size = w_size;\n    g->adja = SafeMalloc(n*(sizeof(graph_edge *)));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) {\n        g->adja[i] = SafeMalloc(sizeof(graph_edge));\n        g->adja[i]->next = <span class="keyword">NULL</span>;\n        g->adja[i]->w = <span class="keyword">NULL</span>;\n    }\n    <span class="keyword">return</span> g;\n}\n\nvoid GraphDestroy(graph *g) {\n    int i;\n    graph_edge *p, *e;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        e = g->adja[i];\n        <span class="keyword">while</span> (e != <span class="keyword">NULL</span>) {\n            p = e->next;\n            <span class="keyword">if</span> (e->w != <span class="keyword">NULL</span>) {\n                free(e->w);\n            }\n            free(e);\n            e = p;\n        }\n    }\n    free(g->adja);\n    free(g);\n}\n\nint GraphNodeValid(graph *g, int u) {\n    <span class="keyword">return</span> <span class="number">0</span> &lt;= u &amp;&amp; u &lt; g->n ? <span class="number">1</span> : <span class="number">0</span>;\n}\n\ngraph_edge* _GraphNewEdge(int u, int v, void *w, size_t w_size) {\n    graph_edge *e = SafeMalloc(sizeof(graph_edge));\n    e->u = u;\n    e->v = v;\n    e->w = SafeMalloc(w_size);\n    MemoryCopy(e->w, w, w_size);\n    <span class="keyword">return</span> e;\n}\n\ngraph_edge* GraphInsert(graph *g, int u, int v, void *w) {\n    graph_edge *e;\n    <span class="keyword">if</span> (!GraphNodeValid(g,u) || !GraphNodeValid(g,v)) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    e = _GraphNewEdge(u,v,w,g->w_size);\n    e->next = g->adja[u]->next;\n    g->adja[u]->next = e;\n    <span class="keyword">return</span> e;\n}'},17:function(e,n,t){e.exports='<span class="comment">#ifndef GRAPH_H</span>\n<span class="comment">#define GRAPH_H</span>\n<span class="comment">#include &lt;stddef.h></span>\n\ntypedef struct graph_edge {\n  int u;\n  int v;\n  void *w;\n  struct graph_edge *next;\n} graph_edge;\n\ntypedef struct graph {\n  int n;\n  size_t w_size;\n  graph_edge **adja;\n} graph;\n\ngraph* GraphCreate(int n, size_t w_size);\nvoid GraphDestroy(graph *g);\ngraph_edge* GraphInsert(graph *g, int u, int v, void *w);\ngraph_edge* GraphDelete(graph *g, int u, int v);\nint GraphNodeValid(graph *g, int u);\n\n<span class="comment">#endif</span>'},18:function(e,n,t){e.exports='<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./min-heap.h"</span>\n\nmin_heap* MinHeapCreate(int n, size_t item_size, int (*CompFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*)) {\n    int i;\n    min_heap* h = (min_heap*)SafeMalloc(sizeof(min_heap));\n    h-><span class="keyword">array</span> = SafeMalloc(n * sizeof(min_heap_pair));\n    h->capacity = n;\n    h->size = <span class="number">0</span>;\n    h->item_size = item_size;\n    h->Compare = CompFn;\n    h->map = SafeMalloc(n*sizeof(int));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) {\n        h-><span class="keyword">array</span>[i].item = <span class="keyword">NULL</span>;\n        h->map[i] = -<span class="number">1</span>;\n    }\n    <span class="keyword">return</span> h;\n}\n\nvoid MinHeapDestroy(min_heap *h) {\n    int i;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; h->capacity; ++i) {\n        <span class="keyword">if</span> (h-><span class="keyword">array</span>[i].item != <span class="keyword">NULL</span>) {\n            free(h-><span class="keyword">array</span>[i].item);\n        }\n    }\n    free(h-><span class="keyword">array</span>);\n    free(h->map);\n    free(h);\n}\n\nint _P(int x) {\n    <span class="keyword">return</span> x == <span class="number">0</span> ? <span class="number">0</span> : (x-<span class="number">1</span>)/<span class="number">2</span>;\n}\nint _L(int x) {\n    <span class="keyword">return</span> x*<span class="number">2</span>+<span class="number">1</span>;\n}\nint _R(int x) {\n    <span class="keyword">return</span> x*<span class="number">2</span>+<span class="number">2</span>;\n}\nvoid _Exchange(min_heap* h, int i, int j) {\n    min_heap_pair tmp;\n    tmp = h-><span class="keyword">array</span>[i];\n    h-><span class="keyword">array</span>[i] = h-><span class="keyword">array</span>[j];\n    h-><span class="keyword">array</span>[j] = tmp;\n    h->map[h-><span class="keyword">array</span>[i].key] = i;\n    h->map[h-><span class="keyword">array</span>[j].key] = j;\n}\n\nvoid _Swim(min_heap *h, int x) {\n    <span class="keyword">while</span> (x != <span class="number">0</span> &amp;&amp; h->Compare(h-><span class="keyword">array</span>[x].item, h-><span class="keyword">array</span>[_P(x)].item) &lt; <span class="number">0</span>) {\n        _Exchange(h, x, _P(x));\n        x = _P(x);\n    }\n}\n\nvoid _Sink(min_heap *h, int x) {\n    int y = -<span class="number">1</span>;\n    <span class="keyword">while</span> (x != y) {\n        y = x;\n        <span class="keyword">if</span> (_L(x) &lt; h->size &amp;&amp; h->Compare(h-><span class="keyword">array</span>[_L(x)].item, h-><span class="keyword">array</span>[x].item) &lt; <span class="number">0</span>) {\n            y = _L(x);\n        }\n        <span class="keyword">if</span> (_R(x) &lt; h->size &amp;&amp; h->Compare(h-><span class="keyword">array</span>[_R(x)].item, h-><span class="keyword">array</span>[y].item) &lt; <span class="number">0</span>) {\n            y = _R(x);\n        }\n        <span class="keyword">if</span> (y != x) {\n            _Exchange(h, x, y);\n            x = y;\n            y = -<span class="number">1</span>;\n        }\n    }\n}\n\nvoid MinHeapInsert(min_heap* h, void* item, int id) {\n    int x = h->size;\n    <span class="keyword">if</span> (x == h->capacity) {\n        <span class="keyword">return</span>;\n    }\n    h-><span class="keyword">array</span>[x].key = id;\n    h->map[id] = x;\n    <span class="keyword">if</span> (h-><span class="keyword">array</span>[x].item == <span class="keyword">NULL</span>) {\n        h-><span class="keyword">array</span>[x].item = SafeMalloc(h->item_size);\n    }\n    MemoryCopy(h-><span class="keyword">array</span>[x].item, item, h->item_size);\n    h->size++;\n    _Swim(h, x);\n}\n\nvoid* MinHeapPop(min_heap* h) {\n    void* item = SafeMalloc(h->item_size);\n    <span class="keyword">if</span> (h->size == <span class="number">0</span>) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    MemoryCopy(item, h-><span class="keyword">array</span>[<span class="number">0</span>].item, h->item_size);\n    h->map[h-><span class="keyword">array</span>[<span class="number">0</span>].key] = -<span class="number">1</span>;\n    MemoryCopy(h-><span class="keyword">array</span>[<span class="number">0</span>].item, h-><span class="keyword">array</span>[h->size-<span class="number">1</span>].item, h->item_size);\n    h-><span class="keyword">array</span>[<span class="number">0</span>].key = h-><span class="keyword">array</span>[h->size-<span class="number">1</span>].key;\n    h->map[h-><span class="keyword">array</span>[<span class="number">0</span>].key] = <span class="number">0</span>;\n    free(h-><span class="keyword">array</span>[h->size-<span class="number">1</span>].item);\n    h-><span class="keyword">array</span>[h->size-<span class="number">1</span>].item = <span class="keyword">NULL</span>;\n    h->size--;\n    _Sink(h, <span class="number">0</span>);\n    <span class="keyword">return</span> item;\n}\n\nvoid *MinHeapUpdate(min_heap *h, void *item, int id) {\n    int i;\n    int rc;\n    <span class="keyword">if</span> (id &lt; <span class="number">0</span> || id >= h->capacity) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    i = h->map[id];\n    rc = h->Compare(h-><span class="keyword">array</span>[i].item, item);\n    MemoryCopy(h-><span class="keyword">array</span>[i].item, item, h->item_size);\n    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) {\n        _Sink(h, i);\n        <span class="keyword">return</span> item;\n    } <span class="keyword">else</span> <span class="keyword">if</span> (rc > <span class="number">0</span>) {\n        _Swim(h, i);\n        <span class="keyword">return</span> item;\n    }\n    <span class="keyword">return</span> <span class="keyword">NULL</span>;\n}'},19:function(e,n,t){e.exports='<span class="comment">#ifndef MIN_HEAP_H</span>\n<span class="comment">#define MIN_HEAP_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\ntypedef struct min_heap_pair {\n    void *item;\n    int key;\n} min_heap_pair;\n\ntypedef struct min_heap {\n    int size;\n    int capacity;\n    size_t item_size;\n    min_heap_pair* <span class="keyword">array</span>;\n    int (*Compare)(<span class="keyword">const</span> void* a, <span class="keyword">const</span> void* b);\n    int* map;\n} min_heap;\n\nmin_heap* MinHeapCreate(int n, size_t item_size, int (*CompFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*));\nvoid MinHeapInsert(min_heap* h, void* item, int id);\nvoid* MinHeapPop(min_heap* h);\nvoid MinHeapDestroy(min_heap* h);\nvoid *MinHeapUpdate(min_heap *h, void *item, int id);\n\n<span class="comment">#endif</span>'},20:function(e,n,t){var s=t(15);"string"==typeof s&&(s=[[e.id,s,""]]);t(9)(s,{})},21:function(e,n,t){function s(e){this.array=[],this.cf=e,this.map=[]}s.prototype.p=function(e){return 0==e?0:Math.floor((e-1)/2)},s.prototype.l=function(e){return 2*e+1},s.prototype.r=function(e){return 2*e+2},s.prototype.ex=function(e,n){var t=this.array[e];this.array[e]=this.array[n],this.array[n]=t,this.map[this.array[e].k]=e,this.map[this.array[n].k]=n},s.prototype.swim=function(e){for(;0!=e&&this.cf(this.array[e].v,this.array[this.p(e)].v)<0;)this.ex(e,this.p(e)),e=this.p(e)},s.prototype.sink=function(e){for(var n=-1;e!==n;)n=e,void 0!==this.array[this.l(e)]&&this.cf(this.array[this.l(e)].v,this.array[e].v)<0&&(n=this.l(e)),void 0!==this.array[this.r(e)]&&this.cf(this.array[this.r(e)].v,this.array[n].v)<0&&(n=this.r(e)),n!=e&&(this.ex(e,n),e=n,n=-1)},s.prototype.insert=function(e,n){this.array.push({v:e,k:n}),this.map[n]=this.array.length-1,this.swim(this.array.length-1)},s.prototype.pop=function(){if(0!==this.array.length){var e=this.array[0];return this.ex(0,this.array.length-1),this.array.pop(),this.map[e.k]=void 0,this.sink(0),e.v}},s.prototype.update=function(e,n){if(!(0>n||n>=this.array.length)){var t=this.map[n],s=this.cf(this.array[t].v,e);this.array[t].v=e,0>s?this.sink(t):s>0&&this.swim(t)}},s.prototype.forceUpdate=function(e){var n=this.map[e];this.sink(n),this.swim(n)},e.exports=s},22:function(e,n,t){function s(e){ce=!1,Q=e.container||document.body,U=T.select(e.container).append("svg").node(),q=e.weighted||!1,N=e.directional||!1,R=e.width||U.clientWidth||e.container.clientWidth,O=e.height||U.clientHeight||e.container.clientHeight,oe=e.offsetLeft||0,ie=e.offsetTop||0,W.nodes=e.nodes||T.range(e.n||5).map(function(){return{}}),W.edges=(e.edges||T.range(5).map(function(e){return{u:e,v:(e+1)%5}})).map(function(e){return{source:W.nodes[e.u],target:W.nodes[e.v],val:e.w,reflexive:e.reflexive}}),B=void 0,j=e._onSelected||void 0,_onLoad=e._onLoad||void 0,ae=void 0,re=!1,T.select(U).call(se).on("dblclick.zoom",null).on("dblclick.svg",M);var n=T.select(U).append("defs");return n.append("marker").attr("id","arrow-end").attr("viewBox","0 -5 10 10").attr("refX",7).attr("refY",0).attr("markerWidth",ee).attr("markerHeight",ee).attr("orient","auto").append("path").attr("d","M0,-5L10,0L0,5"),n.append("marker").attr("id","arrow-start").attr("viewBox","0 -5 10 10").attr("refX",3).attr("refY",0).attr("markerWidth",ee).attr("markerHeight",ee).attr("orient","auto").append("path").attr("d","M10,-5L0,0L10,5"),G=T.select(U).append("g").attr("class","svg-entry"),F=G.append("g").attr("class","base"),$=F.append("g").attr("class","edges"),H=F.append("g").attr("class","nodes"),Y=G.append("g").attr("class","text").attr("transform","translate(0,7)"),$.append("path").attr("class","drag").attr("marker-end","url(#arrow-end)").style("display","none"),T.select(window).on("keydown.window",E),ne.nodes(W.nodes).links(W.edges).size([R,O]),d(),D(!1),ne.on("end",function(){D(),ne.on("end",null),_onLoad&&_onLoad()}),e.nowait&&(u(),ne.on("end")()),this}function a(e,n){var t=e.x-n.x,s=e.y-n.y;return K*K>=t*t+s*s}function r(e,n){var t=Math.PI*n/180;return{x:e.x*Math.cos(t)+e.y*Math.sin(t),y:e.x*-Math.sin(t)+e.y*Math.cos(t)}}function i(e){return"translate("+e.x+","+e.y+")"}function o(e){return{x:-e.x,y:-e.y}}function c(e,n){return{x:e.x-n.x,y:e.y-n.y}}function p(e){return void 0===e.val?"":e.val}function l(e){var n=e.target.x-e.source.x,t=e.target.y-e.source.y,s=Math.sqrt(n*n+t*t),i=T.interpolate(e.source,e.target)(K/s),p=T.interpolate(e.target,e.source)(K/s),l=T.interpolate(30,0)(K/s);if(N&&q){var u=W.edges.filter(function(n){return n.target===e.source&&(n.source===e.target||a(e.target,n.source))});return u.length>0?(e.curve=!0,i=c(r(c(i,e.source),l),o(e.source)),p=c(r(c(p,e.target),-l),o(e.target)),"M"+i.x+","+i.y+"A"+s+","+s+" 0 0,1 "+p.x+","+p.y):(e.curve=!1,"M"+i.x+","+i.y+"L"+p.x+","+p.y)}return e.curve=!1,"M"+i.x+","+i.y+"L"+p.x+","+p.y}function u(){H.selectAll(".node").data(W.nodes).classed("painter-selected",function(e){return e===B}).attr("transform",i),Y.selectAll(".node").data(W.nodes).attr("transform",i).text(function(e,n){return n}),$.selectAll(".edge").data(W.edges).classed("painter-selected",function(e){return e===B}).attr("marker-end",N?"url(#arrow-end)":null).attr("marker-start",N&&q===!1?function(e){return e.reflexive?"url(#arrow-start)":null}:null).attr("d",l),q&&($.selectAll(".edge").each(function(e){var n=this.getPointAtLength(this.getTotalLength()/2);e.x=n.x,e.y=n.y}),Y.selectAll(".edge").data(W.edges).attr("transform",i).text(p))}function d(){H.selectAll(".node").data(W.nodes).enter().append("circle").attr("class","node").attr("r",K).on("dblclick.node",f).call(te).on("click.select",x).on("mousedown.node",y).on("mouseup.node",w),H.selectAll(".node").data(W.nodes).exit().remove(),Y.selectAll(".node").data(W.nodes).enter().append("text").attr("class","node"),Y.selectAll(".node").data(W.nodes).exit().remove(),$.selectAll(".edge").data(W.edges).enter().append("path").attr("class","edge").on("click.select",x),$.selectAll(".edge").data(W.edges).exit().remove(),q?(Y.selectAll(".edge").data(W.edges).enter().append("text").attr("class","edge"),Y.selectAll(".edge").data(W.edges).exit().remove()):Y.selectAll(".edge").remove(),ne.start()}function h(){R=U.clientWidth||Q.clientWidth,O=U.clientHeight||Q.clientHeight,ne.size([R,O]).resume()}function f(e){T.event.stopPropagation(),T.select(this).classed("fixed",e.fixed=!1),ne.resume()}function m(e){e.fixed|=2}function g(e){ae&&(re?(T.select(this).classed("fixed",e.fixed=!0),e.px=T.event.x||T.event.clientX,e.py=T.event.y||T.event.clientY,ne.resume()):a(T.event,e)===!1?$.select("path.drag").datum({source:e,target:{x:T.event.x||T.event.clientX,y:T.event.y||T.event.clientY}}).attr("d",l).style("display",null):$.select("path.drag").style("display","none"))}function v(e){e.fixed&=-7,$.select("path.drag").style("display","none")}function y(e){(T.event.ctrlKey===!1||void 0===T.event.ctrlKey)&&(T.event.stopPropagation(),ae=e,re=T.event.shiftKey?!0:!1)}function w(e){if(ae&&ae!==e){var n={source:ae,target:e};k(n),d()}ae=void 0,re=!1}function x(e,n){B=B===e?void 0:e,n===!0&&(B=e),B&&j&&j(),ne.resume()}function k(e){var n;N===!1?(n=W.edges.filter(function(n){return n.source===e.source&&n.target===e.target||n.target===e.source&&n.source===e.target}),n.length>0?e=n[0]:W.edges.push(e)):q?(n=W.edges.filter(function(n){return n.source===e.source&&n.target===e.target}),n.length>0?e=n[0]:W.edges.push(e)):(n=W.edges.filter(function(n){return n.source===e.source&&n.target===e.target||n.target===e.source&&n.source===e.target}),n.length>0?(n[0].source===e.target&&(n[0].reflexive=!0),e=n[0]):W.edges.push(e)),x(e,!0)}function _(){var e=void 0===B||void 0===B.val?"数字":B.val;return prompt("权值",e)}function b(e){var n=e();return""===n?void delete B.val:(n=parseFloat(n),isNaN(n)||B.val===n?void 0:(B.val=n,d(),this))}function E(){B&&(8===T.event.keyCode?(T.event.preventDefault(),S()):13===T.event.keyCode&&q&&b(_))}function S(){var e=W.nodes.indexOf(B);return-1!==e?(W.nodes.splice(e,1),W.edges.filter(function(e){return e.source===B||e.target===B}).forEach(function(e){W.edges.splice(W.edges.indexOf(e),1)})):(e=W.edges.indexOf(B),-1!=e&&W.edges.splice(W.edges.indexOf(B),1)),B=void 0,d(),this}function L(){X=T.event.translate,J=T.event.scale,G.attr("transform","translate("+T.event.translate+")scale("+T.event.scale+")")}function A(){var e=document.documentElement;return{left:(window.pageXOffset||e.scrollLeft)-(e.clientLeft||0),top:(window.pageYOffset||e.scrollTop)-(e.clientTop||0)}}function M(){if(T.event.target===this){var e=T.event.x||T.event.clientX||T.event.clientX,n=T.event.y||T.event.clientY||T.event.clientY,t=A();e+=t.left-oe,n+=t.top-ie;var s={x:(e-X[0])/J,y:(n-X[1])/J};W.nodes.push(s),x(s),d()}}function D(e){return B&&($.select(".painter-selected").classed("painter-selected",!1),H.select(".painter-selected").classed("painter-selected",!1),B=void 0),q&&(W.edges.forEach(function(e){void 0===e.val&&(e.val=1)}),u()),e!==!1&&ne.stop(),T.select(window).on("resize",null).on("keydown.window",null),T.select(U).on("dblclick.svg",null),H.selectAll("circle.node").on("dblclick.node",null).on("dragstart",null).on("drag",null).on("dragend",null).on("click.select",null).on("mousedown.node",null).on("mouseup.node",null),$.selectAll("path.edge").on("click.select",null),this}function P(e,n){function t(e,n){return e.source===n.target&&e.target===n.source}if(N!==e||q!==n){pd=N,N=e,q=n;var s=[];return W.edges.forEach(function(e){N?q?((pd===!1||e.reflexive)&&s.push({source:e.target,target:e.source,val:e.val}),delete e.reflexive,s.push(e)):(delete e.reflexive,s.some(function(n){return t(e,n)})===!1&&((pd===!1||W.edges.some(function(n){return t(e,n)})===!0)&&(e.reflexive=!0),s.push(e))):s.some(function(n){return t(e,n)})===!1&&(delete e.reflexive,s.push(e))}),W.edges=s,$.classed("directional",N).classed("weighted",q),d(),this}}function z(){ne.start(),T.select(window).on("resize",h).on("keydown.window",E),T.select(U).on("dblclick.svg",M),H.selectAll("circle.node").on("dblclick.node",f).call(te).on("click.select",x).on("mousedown.node",y).on("mouseup.node",w),$.selectAll("path.edge").on("click.select",x)}function C(){W.nodes.length=0,W.edges.length=0,d()}function I(){}var T=t(4);t(20);var U,q,N,R,O,B,j,G,F,$,H,Y,Q,W={},X=[0,0],J=1,K=15,V=150,Z=-600,ee=3,ne=T.layout.force().linkDistance(V).charge(Z).on("tick",u),te=T.behavior.drag().origin(function(e){return e}).on("dragstart",m).on("drag",g).on("dragend",v),se=T.behavior.zoom().scaleExtent([.1,10]).on("zoom",L),ae=void 0,re=!1,ie=0,oe=0,ce=!1;e.exports={stop:D,convert:P,weighSelected:b,deleteSelected:S,init:s,restart:z,clear:C,random:I,directional:function(){return N},weighted:function(){return q},raw:function(){return W},data:function(){var e=W.edges.map(function(e){return{u:e.source.index,v:e.target.index,w:e.val}});return N||(e=e.concat(W.edges.map(function(e){return{u:e.target.index,v:e.source.index,w:e.val}}))),N&&!q&&(e=e.concat(W.edges.filter(function(e){return e.reflexive}).map(function(e){return{u:e.target.index,v:e.source.index,w:e.val}}))),{weighted:q,directional:N,n:W.nodes.length,e:e}}}},29:function(e,n,t){function s(e,n){return e.w===g||n.w===v?-1:e.w===v||n.w===g?1:e.w-n.w}function a(e,n){void 0===n?d[e].pop():d[e].push(n)}function r(){var e,n,t,r,i,c;if(!(f.n<=1)){for(n=[],t=new m(s),i=[],d.pns=i,o(39,1),e=0;e<f.n;++e)i[e]={i:e},i[e].w=0===e?g:v,i[e].e=void 0,t.insert(i[e],e);for(e=0;o(45,1),e<f.n;++e){if(o(46),c=t.pop(),a("hl",c.i),o(47,1),void 0!==c.e&&(o(48,1),n[e-1]=c.e,a("ine",c.e)),o(50,1),i[c.i].w=g,o(51,1),e===f.n-1){a("hl"),o(52,1);break}for(r=0;o(54,1),a("se"),r<f.e[c.i].length;r++){var p=f.e[c.i][r];o(55,1),a("se",p),(i[p.v].w===v||i[p.v].w!==g&&i[p.v].w-p.w>0)&&(a("ine",p),i[p.v].w=p.w,i[p.v].e=p,o(60,1),t.forceUpdate(p.v),a("ine"))}a("hl")}return o(67,1),n}}function i(e){f.n=e.n,f.e=[];for(var n=0;n<f.n;++n)f.e.push([]);e.e.forEach(function(e){f.e[e.u].push(e)})}function o(e,n,t){1===n&&(lastStatus=d.clone()),l.push({status:lastStatus,line:e,animation:t,id:u}),u++}function c(){0===l.length?0:l[l.length-1].line;o(113,1)}var p=t(6),l=[],u=0,d={},h=0,f={},m=t(21),g="-",v="+";d.clone=function(){return{neg:g,pos:v,ine:p(this.ine)||[],se:p(this.se)||[],hl:p(this.hl)||[],pns:p(this.pns)||[]}},d.init=function(e){this.se=[],this.ine=[],this.pns=[],this.hl=[]},lastStatus={},e.exports={initialize:function(e){return l=[],u=0,e&&(h=0),d.init(e),lastStatus=d.clone(),this},prim:r,run:function(e,n){return i(n.g),this.initialize()[e](),c(),{frames:l,others:{}}}}},41:function(e,n,t){n=e.exports=t(8)(),n.push([e.id,"path.ine{stroke-width:20px;stroke:#00bfff;fill:none;stroke-opacity:.5}.node.visited{fill:#00bfff}path.scc{stroke:#ccc;fill:#ccc;stroke-width:30px;stroke-linejoin:round;opacity:.5}",""])},56:function(e,n,t){t(112);var s=t(3),a=t(5),r=t(22),i=t(123);e.exports=s.createClass({displayName:"module.exports",getInitialState:function(){return{painting:!1,loaded:!1,text:""}},componentDidMount:function(){r.init({container:this.refs.svg.getDOMNode(),offsetTop:document.querySelector(".dsa-app").offsetTop+55,offsetLeft:document.querySelector(".dsa-app").offsetLeft+80,_onLoad:this._onLoad,nodes:[{x:50,y:50,fixed:!0},{x:50,y:250,fixed:!0},{x:150,y:150,fixed:!0},{x:250,y:250,fixed:!0},{x:150,y:350,fixed:!0},{x:250,y:450,fixed:!0},{x:350,y:50,fixed:!0},{x:450,y:350,fixed:!0},{x:450,y:150,fixed:!0}],edges:[{u:0,v:1,w:8},{u:0,v:2,w:12},{u:1,v:2,w:13},{u:1,v:3,w:25},{u:1,v:4,w:9},{u:2,v:3,w:14},{u:2,v:6,w:21},{u:3,v:4,w:20},{u:3,v:5,w:8},{u:3,v:6,w:12},{u:3,v:7,w:12},{u:3,v:8,w:16},{u:4,v:5,w:19},{u:5,v:7,w:11},{u:6,v:8,w:11},{u:7,v:8,w:9}],directional:!1,weighted:!0,nowait:!0}),i.init(r.raw())},componentDidUpdate:function(e){this.props!==e&&void 0!==this.props.frame&&this.props.frame&&i.render(this.props.frame.status,this.props.delay,this.props.others)},render:function(){return s.createElement("div",{className:"wrapper-code"},s.createElement("div",{className:"list"},this.getInputList()),s.createElement("div",{ref:"svg",className:"scene"}))},_onLoad:function(){this.setState({loaded:!0})},_onPainting:function(){this.state.painting?r.stop():(i.clear(),a.pauseDemo(),a.waitDemo(),r.restart()),this.setState({painting:!this.state.painting})},_onClick:function(e){i.clear(),i.init(r.raw()),a.runDemo(e,{g:r.data(),x:this.state.text})},getInputList:function(){return this.state.loaded===!1?s.createElement("input",{className:"cmd-button",readOnly:!0,value:"加载中",title:"加载中"}):this.state.painting?s.createElement("div",null,s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:r.clear,value:"清空",title:"清空"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onPainting,value:"完成",title:"完成"})):s.createElement("div",null,s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"prim"),value:"Prim最小生成树",title:"Prim最小生成树"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onPainting,value:"编辑图",title:"编辑图"}))}})},80:function(e,n,t){e.exports="CC=gcc\nCFLAGS=-c -Wall\nLDFLAGS=\nSOURCES=test.c ../common/util.c ../common/util.h ../graph/graph.c ../graph/graph.h ../min-heap/min-heap.c ../min-heap/min-heap.h ./mst.c ./mst.h\nOBJECTS=$(SOURCES:.c=.o)\nEXECUTABLE=a.out\n\nall: $(SOURCES) $(EXECUTABLE)\n\n$(EXECUTABLE): $(OBJECTS)\n    $(CC) $(LDFLAGS) $(OBJECTS) -o $@\n\n.cpp.o:\n    $(CC) $(CFLAGS) $&lt; -o $@\n\nclean:\n    rm -rf *.o a.out"},81:function(e,n,t){e.exports='<span class="comment">#include "../graph/graph.h"</span>\n<span class="comment">#include "../min-heap/min-heap.h"</span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include &lt;stdlib.h></span>\n\ntypedef struct prim_node {\n    int i;\n    void *w;\n    graph_edge *e;\n} prim_node;\n\nint (*_gGraphEdgeWeightCompare)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*);\nint _gNegInfinity = <span class="number">0</span>;\nint _gPosInfinity = <span class="number">0</span>;\n\nint _GraphPrimNodeCompare(<span class="keyword">const</span> void *a, <span class="keyword">const</span> void *b) {\n    <span class="keyword">if</span> (((prim_node *)a)->w == &amp;_gNegInfinity || ((prim_node *)b)->w == &amp;_gPosInfinity) {\n        <span class="keyword">return</span> -<span class="number">1</span>;\n    } <span class="keyword">else</span> <span class="keyword">if</span> (((prim_node *)a)->w == &amp;_gPosInfinity || ((prim_node *)b)->w == &amp;_gNegInfinity) {\n        <span class="keyword">return</span> <span class="number">1</span>;\n    }\n    <span class="keyword">return</span> _gGraphEdgeWeightCompare(((prim_node *)a)->w, ((prim_node *)b)->w);\n}\n\ngraph_edge **GraphPrim(graph *g, int (*CompFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*)) {\n    int i;\n    graph_edge **mst;\n    min_heap *mh;\n    graph_edge *e;\n    prim_node *pns;\n    prim_node *pn;\n    <span class="keyword">if</span> (g->n &lt;= <span class="number">1</span>) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    _gGraphEdgeWeightCompare = CompFn;\n    mst = SafeMalloc((g->n-<span class="number">1</span>)*sizeof(graph_edge *));\n    mh = MinHeapCreate(g->n, sizeof(prim_node), _GraphPrimNodeCompare);\n    pns = SafeMalloc(g->n*sizeof(prim_node));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        pns[i].i = i;\n        pns[i].w = (i == <span class="number">0</span> ? &amp;_gNegInfinity : &amp;_gPosInfinity);\n        pns[i].e = <span class="keyword">NULL</span>;\n        MinHeapInsert(mh, &amp;pns[i], i);\n    }\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        pn = MinHeapPop(mh);\n        <span class="keyword">if</span> (pn->e != <span class="keyword">NULL</span>) {\n            mst[i-<span class="number">1</span>] = pn->e;\n        }\n        pns[pn->i].w = &amp;_gNegInfinity;\n        <span class="keyword">if</span> (i == g->n-<span class="number">1</span>) {\n            <span class="keyword">break</span>;\n        }\n        <span class="keyword">for</span> (e = g->adja[pn->i]->next; e != <span class="keyword">NULL</span>; e = e->next) {\n            <span class="keyword">if</span> (pns[e->v].w == &amp;_gPosInfinity ||\n                        (pns[e->v].w != &amp;_gNegInfinity &amp;&amp; _gGraphEdgeWeightCompare(pns[e->v].w, e->w) > <span class="number">0</span>)\n                ) {\n                pns[e->v].w = e->w;\n                pns[e->v].e = e;\n                MinHeapUpdate(mh, &amp;pns[e->v], e->v);\n            }\n        }\n        free(pn);\n    }\n    MinHeapDestroy(mh);\n    free(pns);\n    <span class="keyword">return</span> mst;\n}'},82:function(e,n,t){e.exports='<span class="comment">#ifndef PRIM_H</span>\n<span class="comment">#define PRIM_H</span>\n\n<span class="comment">#include "../graph/graph.h"</span>\n\ngraph_edge **GraphPrim(graph *g, int (*CompFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*));\n\n<span class="comment">#endif</span>'},83:function(e,n,t){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../graph/graph.h"</span>\n<span class="comment">#include "./mst.h"</span>\n\nint Compare(<span class="keyword">const</span> void *a, <span class="keyword">const</span> void *b) {\n    <span class="keyword">return</span> *(int *)a - *(int *)b;\n}\n\nint main(int argc, char <span class="keyword">const</span> *argv[])\n{\n    int n, m, i, u, v, w;\n    graph *g;\n    graph_edge **mst;\n    int sum = <span class="number">0</span>;\n    <span class="keyword">while</span> (scanf(<span class="string">"%d%d"</span>, &amp;n,&amp;m) != EOF) {\n        g = GraphCreate(n, sizeof(int));\n        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++i) {\n            scanf(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);\n            GraphInsert(g, u, v, &amp;w);\n            GraphInsert(g, v, u, &amp;w);\n        }\n        mst = GraphPrim(g, Compare);\n        sum = <span class="number">0</span>;\n        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n-<span class="number">1</span>; ++i) {\n            printf (<span class="string">"u = %d, v = %d, w = %d\\n"</span>, mst[i]->u, mst[i]->v, *(int *)(mst[i]->w));\n            sum += *(int *)(mst[i]->w);\n        }\n        printf(<span class="string">"sum = %d\\n"</span>, sum);\n        free(mst);\n        GraphDestroy(g);\n    }\n    <span class="keyword">return</span> <span class="number">0</span>;\n}';

},112:function(e,n,t){var s=t(41);"string"==typeof s&&(s=[[e.id,s,""]]);t(9)(s,{})},123:function(e,n,t){function s(e){return"translate("+k.nodes[e].x+","+k.nodes[e].y+")"}function a(){function e(e){return e.i}function n(e){return s(e.i)}function t(e){return(i.indexOf(e.w)+1)/i.length*E}function a(e,n){return y.pns[n]&&y.pns[n].w===y.neg}var r=y.pns.filter(function(e){return!isNaN(e.w)}),i=_.set(r.map(function(e){return e.w})).values().map(parseFloat).sort(_.descending);gnodes.selectAll("path.inq").data(r,e).enter().append("path").attr("class","inq").attr("d",function(e){return S({endAngle:0})}).attr("transform",n).each(function(e){this._current={endAngle:0}}),gnodes.selectAll("path.inq").data(r,e).transition().duration(w).attr("transform",n).attrTween("d",function(e,n){var s=_.interpolate(this._current,{endAngle:t(e,n)});return this._current=s(0),function(e){return S(s(e))}}),gnodes.selectAll("path.inq").data(r,e).exit().remove(),gnodes.selectAll("circle.node").classed("visited",a),v.selectAll("text.node").classed("visited",a),gprimtext.selectAll("text.dist").data(y.pns,e).enter().append("text").attr("class","dist").attr("transform",n),gprimtext.selectAll("text.dist").data(y.pns,e).attr("transform",n).text(function(e){return e.w===y.neg?"-∞":e.w===y.pos?"+∞":e.w}),gprimtext.selectAll("text.dist").data(y.pns,e).exit().remove(),gnodes.selectAll("circle.node").classed("highlighted",function(e,n){return n===y.hl[0]})}function r(e){return e.u+"-"+e.v}function i(e,n,t){return t===!0?n.u===e.source.index&&n.v===e.target.index:t===!1?n.v===e.source.index&&n.u===e.target.index:n.u===e.source.index&&n.v===e.target.index||n.v===e.source.index&&n.u===e.target.index}function o(e){var n=k.edges.filter(function(n){return i(n,e)})[0];return{source:n.source.index===e.u?n.source:n.target,target:n.target.index===e.v?n.target:n.source}}function c(e){return function(n){var t=o(n),s=t.source.x-t.target.x,a=t.target.y-t.source.y,r=(Math.sqrt(s*s+a*a),"exit"===e?_.interpolate(t.target,t.source):_.interpolate(t.source,t.target)),i=t.source;return function(e){var n=r(e);return"M"+i.x+","+i.y+"L"+n.x+","+n.y}}}function p(e){return y.se.concat(y.pns.filter(function(e){return e.w!==y.neg}).map(function(e){return e.e})).some(function(n){return n&&i(e,n)})}function l(e){return y.se.concat(y.pns.filter(function(e){return e.w!==y.neg}).map(function(e){return e.e})).some(function(n){return n&&i(e,n,!1)})}function u(){gedges.selectAll("path.edge").classed("painter-selected",p).classed("rev-dir",l),gedges.selectAll("path.ine").data(y.ine,r).enter().insert("path",":first-child").attr("class","ine").transition().duration(w).attrTween("d",c("update")),gedges.selectAll("path.ine").data(y.ine,r).exit().transition().duration(w).attrTween("d",c("exit")).remove()}function d(e,n,t){y=e,w=n,x=t}function h(e,n,t){d(e,n,t),a(),u()}function f(e){k=e,g=_.select("g.base"),v=_.select("g.text"),gnodes=_.select("g.nodes"),gedges=_.select("g.edges"),_.selectAll("g.prim").remove(),gprimtext=v.append("g").attr("class","prim").attr("transform","translate(15,-15)")}function m(){gnodes.selectAll("path.inq").remove(),gedges.selectAll("path.edge").attr("class","edge"),gedges.selectAll("path.ine").remove(),gnodes.selectAll("circle.node").attr("class","node"),v.selectAll("text.node").attr("class","node"),gprimtext.remove()}var g,v,y,w,x,k,_=t(4),b=(t(7),15),E=2*Math.PI,S=_.svg.arc().innerRadius(0).outerRadius(b).startAngle(0);e.exports={init:f,render:h,clear:m}}});