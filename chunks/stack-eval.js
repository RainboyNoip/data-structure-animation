webpackJsonpdsa([5],{1:function(n,e,t){n.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "./util.h"</span>\n\nvoid* SafeMalloc(size_t size) {\n    void* m;\n    <span class="keyword">if</span> ((m = malloc(size))) {\n        <span class="keyword">return</span> m;\n    } <span class="keyword">else</span> {\n        printf(<span class="string">"memory overflow\\n"</span>);\n        <span class="keyword">exit</span>(-<span class="number">1</span>);\n        <span class="keyword">return</span> <span class="number">0</span>;\n    }\n}\n\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">// }</span>\n    memcpy(a, b, size);\n}\n\nvoid MemorySwap(void *a, void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// char t;</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     t = *(char *)a;</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">//     *((char *)b + i) = t;</span>\n    <span class="comment">// }</span>\n    void *t = SafeMalloc(size);\n    memcpy(t, a, size);\n    memcpy(a, b, size);\n    memcpy(b, t, size);\n}\n\nvoid MemoryClear(void *a, size_t size) {\n    memset(a, <span class="number">0</span>, size);\n}\n\nvoid *MemoryAddress(void *a, int i, size_t size) {\n    <span class="keyword">return</span> (char *)a + i*size;\n}'},2:function(n,e,t){n.exports='<span class="comment">#ifndef UTIL_H</span>\n<span class="comment">#define UTIL_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\nvoid * SafeMalloc(size_t size);\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size);\nvoid MemorySwap(void *a, void *b, size_t size);\nvoid MemoryClear(void *a, size_t size);\n\n<span class="comment">#endif</span>'},17:function(n,e,t){n.exports='<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./stack.h"</span>\n\nint StackIsEmpty(stack *s) {\n  <span class="keyword">return</span> s->top > <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;\n}\n\nint StackIsFull(stack *s) {\n  <span class="keyword">return</span> s->top &lt; s->capacity ? <span class="number">0</span> : <span class="number">1</span>;\n}\n\nvoid* StackPop(stack *s) {\n  void *item = <span class="keyword">NULL</span>;\n  <span class="keyword">if</span> (!StackIsEmpty(s)) {\n    item = (char *)s->items + (s->top-<span class="number">1</span>)*s->item_size;\n    s->top--;\n  }\n  <span class="keyword">return</span> item;\n}\n\nvoid* StackPeak(stack *s) {\n  void *item = <span class="keyword">NULL</span>;\n  <span class="keyword">if</span> (!StackIsEmpty(s)) {\n    item = (char *)s->items + (s->top-<span class="number">1</span>)*s->item_size;\n  }\n  <span class="keyword">return</span> item;\n}\n\nvoid* StackPush(stack *s, void *x) {\n  <span class="keyword">if</span> (!StackIsFull(s)) {\n    MemoryCopy((char *)s->items + s->top*s->item_size, x, s->item_size);\n    s->top++;\n    <span class="keyword">return</span> x;\n  }\n  <span class="keyword">return</span> <span class="keyword">NULL</span>;\n}\n\nstack *StackCreate(int n, size_t item_size) {\n  stack *s = SafeMalloc(sizeof(stack));\n  s->capacity = n;\n  s->item_size = item_size;\n  s->top = <span class="number">0</span>;\n  s->items = SafeMalloc(item_size*n);\n  <span class="keyword">return</span> s;\n}\n\nvoid StackDestroy(stack *s) {\n  free(s->items);\n  free(s);\n}'},18:function(n,e,t){n.exports='<span class="comment">#ifndef STACK_H</span>\n<span class="comment">#define STACK_H</span>\n<span class="comment">#include &lt;stddef.h></span>\n\ntypedef struct stack {\n  int top;\n  int capacity;\n  size_t item_size;\n  void *items;\n} stack;\n\nstack *StackCreate(int n, size_t item_size);\nvoid StackDestroy(stack *s);\nint StackIsEmpty(stack *s);\nint StackIsFull(stack *s);\nvoid* StackPop(stack *s);\nvoid* StackPeak(stack *s);\nvoid* StackPush(stack *s, void *x);\n\n<span class="comment">#endif</span>'},36:function(n,e,t){function s(n){currentStatus.stack.push(n)}function a(n){currentStatus.iter[0]=n,void 0===n&&(currentStatus.iter=[])}function r(n){currentStatus.table.push(n),0===n&&(currentStatus.table=[])}function i(n,e){void 0===n?currentStatus.peak=[]:(void 0===currentStatus.peak[n]&&(currentStatus.peak[n]=[]),currentStatus.peak[n].push(e))}function o(n,e,t){1===e&&(lastStatus=l(currentStatus)),d.push({status:lastStatus,line:n,animation:t,id:u}),u++}function c(){o(d[d.length-1].line,1)}var p,l=t(6),d=[],u=0,h=[],f=[],m=function(n,e){return o(5),"+"===n||"-"===n?(r(n),o(6,1),"+"==e||"-"==e||")"===e?(r(e),o(7,1),1):(r(e),o(9,1),-1)):(o(11,1),"*"===n||"/"===n?(r(n),o(12,1),"("===e?(r(e),o(13,1),-1):(r(e),o(15,1),1)):(o(17,1),"("===n?(r(n),o(18,1),")"===e?(r(e),o(19,1),0):(r(e),o(21,1),-1)):(o(24,1),-1)))},g=function(n,e){var t,s,a;switch(o(31,0),t=n[n.length-1],i(0,t),o(32,1),n.pop(),o(33,1),s=n[n.length-1],i(0,s),o(34,1),n.pop(),o(35,1),a=e[e.length-1],i(1,a),o(36,1),e.pop(),o(37,1),a){case"+":o(38),n.push(t+s);break;case"-":o(39),n.push(s-t);break;case"*":o(40),n.push(t*s);break;case"/":o(41),n.push(Math.floor(s/t));break;default:o(42)}i()},y=function(n){var e;for(o(48),h=[],s(h),o(49,1),o(50),f=[],s(f),o(51,1),e=0;o(52,1),a(e),0!=n.length;n=n.slice(1),++e)if(o(53,1),"0"<=n[0]&&n[0]<="9")o(54),h.push(n[0]-"0");else{for(;o(56,1),0!==f.length&&1===(p=m(f[f.length-1],n[0]),o(56,1),r(0),p);)o(57,1),g(h,f);o(59,1),")"===n[0]?(o(60),f.pop()):(o(62),f.push(n[0]))}for(;o(66,1),0!==f.length;)o(67,1),g(h,f);return o(69),i(0,h[h.length-1]),h[h.length-1]};currentStatus={},lastStatus={},n.exports={getInitialDescriptions:function(){return this.run("eval","1*(2+3)")},initialize:function(){return d=[],u=0,currentStatus={stack:[],iter:[],peak:[],table:[]},lastStatus=l(currentStatus),this},eval:function(n){y(n)},run:function(n,e){return this.initialize().eval(e),c(),{frames:d,others:{string:(e.trim()+"=").split("")}}}}},65:function(n,e,t){var s=t(4),a=t(5),r=t(138);n.exports=s.createClass({displayName:"module.exports",getInitialState:function(){return{text:"1*(2+3)"}},componentDidMount:function(){r.init.bind(this)(),a.runDemo("eval","1*(2+3)",!1)},componentDidUpdate:function(n){this.props!==n&&void 0!==this.props.frame&&r.render(this.props.frame.status,this.props.delay,this.props.others)},render:function(){return s.createElement("div",{className:"wrapper-code"},s.createElement("div",{className:"list"},s.createElement("input",{onChange:this._onChange,value:this.state.text,placeholder:"表达式"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"eval"),value:"计算"})),s.createElement("div",{ref:"svg",className:"scene"}))},_onChange:function(n){this.setState({text:n.target.value})},_onClick:function(n){a.runDemo(n,this.state.text)}})},109:function(n,e,t){n.exports='CC=gcc\nCFLAGS=-c -Wall\nLDFLAGS=\nSOURCES=test.c stack-<span class="keyword">eval</span>.c ../stack/stack.c ../common/util.c\nOBJECTS=$(SOURCES:.c=.o)\nEXECUTABLE=a.out\n\nall: $(SOURCES) $(EXECUTABLE)\n\n$(EXECUTABLE): $(OBJECTS)\n    $(CC) $(LDFLAGS) $(OBJECTS) -o $@\n\n.cpp.o:\n    $(CC) $(CFLAGS) $&lt; -o $@\n\nclean:\n    rm -rf *.o a.out'},110:function(n,e,t){n.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "../stack/stack.h"</span>\n\nint prior(char instack, char coming) {\n    <span class="keyword">if</span> (instack == <span class="string">\'+\'</span> || instack == <span class="string">\'-\'</span>) {\n        <span class="keyword">if</span> (coming == <span class="string">\'+\'</span> || coming == <span class="string">\'-\'</span> || coming == <span class="string">\')\'</span>) {\n            <span class="keyword">return</span> <span class="number">1</span>;\n        } <span class="keyword">else</span> {\n            <span class="keyword">return</span> -<span class="number">1</span>;\n        }\n    } <span class="keyword">else</span> <span class="keyword">if</span> (instack == <span class="string">\'*\'</span> || instack == <span class="string">\'/\'</span>) {\n        <span class="keyword">if</span> (coming == <span class="string">\'(\'</span>) {\n            <span class="keyword">return</span> -<span class="number">1</span>;\n        } <span class="keyword">else</span> {\n            <span class="keyword">return</span> <span class="number">1</span>;\n        }\n    } <span class="keyword">else</span> <span class="keyword">if</span> (instack == <span class="string">\'(\'</span>) {\n        <span class="keyword">if</span> (coming == <span class="string">\')\'</span>) {\n            <span class="keyword">return</span> <span class="number">0</span>;\n        } <span class="keyword">else</span> {\n            <span class="keyword">return</span> -<span class="number">1</span>;\n        }\n    }\n    <span class="keyword">return</span> -<span class="number">1</span>;\n};\n\nvoid poppush(stack *nums, stack *ops) {\n    int a;\n    int b;\n    int op;\n    a = *(int *)StackPeak(nums);\n    StackPop(nums);\n    b = *(int *)StackPeak(nums);\n    StackPop(nums);\n    op = *(char *)StackPeak(ops);\n    StackPop(ops);\n    <span class="keyword">switch</span>(op) {\n        <span class="keyword">case</span> <span class="string">\'+\'</span>: a = a+b; StackPush(nums, &amp;a); <span class="keyword">break</span>;\n        <span class="keyword">case</span> <span class="string">\'-\'</span>: a = b-a; StackPush(nums, &amp;a); <span class="keyword">break</span>;\n        <span class="keyword">case</span> <span class="string">\'*\'</span>: a = a*b; StackPush(nums, &amp;a); <span class="keyword">break</span>;\n        <span class="keyword">case</span> <span class="string">\'/\'</span>: a = b/a; StackPush(nums, &amp;a); <span class="keyword">break</span>;\n        <span class="keyword">default</span>: <span class="keyword">break</span>;\n    }\n};\n\nint <span class="keyword">eval</span>(char *str) {\n    int l = strlen(str);\n    int num;\n    char op;\n    stack *nums = StackCreate(l, sizeof(int));\n    stack *ops = StackCreate(l, sizeof(char));\n    <span class="keyword">for</span> (; *str != <span class="string">\'\\0\'</span>; str++) {\n        <span class="keyword">if</span> (<span class="string">\'0\'</span> &lt;= *str &amp;&amp; *str &lt;= <span class="string">\'9\'</span>) {\n            num = (int)(*str - <span class="string">\'0\'</span>);\n            StackPush(nums, &amp;num);\n        } <span class="keyword">else</span> {\n            <span class="keyword">while</span> (StackIsEmpty(ops) == <span class="number">0</span> &amp;&amp; prior(*(char *)StackPeak(ops), *str) == <span class="number">1</span>) {\n                poppush(nums, ops);\n            }\n            <span class="keyword">if</span> (*str == <span class="string">\')\'</span>) {\n                StackPop(ops);\n            } <span class="keyword">else</span> {\n                op = *str;\n                StackPush(ops, &amp;op);\n            }\n        }\n    }\n    <span class="keyword">while</span> (StackIsEmpty(ops) == <span class="number">0</span>) {\n        poppush(nums, ops);\n    }\n    num = *(int *)StackPeak(nums);\n    StackDestroy(nums);\n    StackDestroy(ops);\n    <span class="keyword">return</span> num;\n};'},111:function(n,e,t){n.exports='int <span class="keyword">eval</span>(char *expr);'},112:function(n,e,t){n.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include "./stack-eval.h"</span>\n\nint main(int argc, char <span class="keyword">const</span> *argv[]) {\n  char s[<span class="number">100</span>];\n  <span class="keyword">while</span> (scanf(<span class="string">"%s"</span>, s) != EOF) {\n    printf(<span class="string">"%s = %d\\n"</span>, s, <span class="keyword">eval</span>(s));\n  }\n  <span class="keyword">return</span> <span class="number">0</span>;\n}'},138:function(n,e,t){function s(){var n=v.string.map(function(n,e){var t=g.iter[0]||0;return{v:n,i:e-t}});h.selectAll("rect.char").data(n).enter().append("rect").attr("class","char").attr("width","100").attr("height","50").transition().duration(y).attr("transform",k().translate(function(n,e){return[100*n.i,0]})),h.selectAll("rect.char").data(n).transition().duration(y).attr("transform",k().translate(function(n,e){return[100*n.i,0]})),h.selectAll("rect.char").data(n).exit().transition().duration(y).remove(),f.selectAll("text.char").data(n).enter().append("text").attr("class","char").attr("transform",k().translate(function(n,e){return[50,30]})).transition().duration(y).attr("transform",k().translate(function(n,e){return[100*n.i+50,30]})).text(function(n){return n.v}),f.selectAll("text.char").data(n).transition().duration(y).attr("transform",k().translate(function(n,e){return[100*n.i+50,30]})).text(function(n){return n.v}),f.selectAll("text.char").data(n).exit().transition().duration(y).remove()}function a(){var n=w.range(g.stack.length);h.selectAll("rect.stack").data(n).enter().append("rect").attr("class","stack").attr("width",100).attr("height",250).attr("transform",k().translate(function(n,e){return[100*e,0]})).transition().duration(y).attr("transform",k().translate(function(n,e){return[100*e,150]})),h.selectAll("rect.stack").data(n).exit().transition().duration(y).remove()}function r(){h.selectAll("rect.stack-top").data(g.stack).enter().append("rect").attr("class","stack-top").attr("width",100).attr("height",50).attr("transform",k().translate(function(n,e){return[100*e,0]})).transition().duration(y).attr("transform",k().translate(function(n,e){return[100*e,150+50*(5-n.length-1)]})),h.selectAll("rect.stack-top").data(g.stack).transition().duration(y).attr("transform",k().translate(function(n,e){return[100*e,150+50*(5-n.length-1)]})),h.selectAll("rect.stack-top").data(g.stack).exit().transition().duration(y).remove(),f.selectAll("text.stack-top").data(g.stack).enter().append("text").attr("class","stack-top").attr("transform",k().translate(function(n,e){return[100*e+50,30]})).transition().duration(y).attr("transform",k().translate(function(n,e){return[100*e+50,150+50*(5-n.length-1)+25+5]})).text(function(){return"栈顶"}),f.selectAll("text.stack-top").data(g.stack).transition().duration(y).attr("transform",k().translate(function(n,e){return[100*e+50,150+50*(5-n.length-1)+25+5]})),f.selectAll("text.stack-top").data(g.stack).exit().transition().duration(y).remove()}function i(){var n=g.stack.reduce(function(n,e,t){return n.concat(e.map(function(n,e){return{v:n,i:t,j:e}}))},[]),e=function(n){return(n.i?"ops":"nums")+n.j};h.selectAll("rect.item").data(n,e).enter().append("rect").attr("class","item").attr("width",100).attr("height",50).attr("transform",k().translate(function(n){return[100*n.i,100]})).transition().duration(y).attr("transform",k().translate(function(n){return[100*n.i,150+50*(5-n.j-1)]})),h.selectAll("rect.item").data(n,e).transition().duration(y).attr("transform",k().translate(function(n){return[100*n.i,150+50*(5-n.j-1)]})),h.selectAll("rect.item").data(n,e).exit().transition().duration(y).remove(),f.selectAll("text.item").data(n,e).enter().append("text").attr("class","item").attr("transform",k().translate(function(n){return[100*n.i+50,130]})).transition().duration(y).attr("transform",k().translate(function(n){return[100*n.i+50,150+50*(5-n.j-1)+25+5]})).text(function(n){return n.v}),f.selectAll("text.item").data(n,e).transition().duration(y).attr("transform",k().translate(function(n){return[100*n.i+50,150+50*(5-n.j-1)+25+5]})).text(function(n){return n.v}),f.selectAll("text.item").data(n,e).exit().transition().duration(y).remove()}function o(){var n=g.peak.reduce(function(n,e,t){return n.concat(e.map(function(n,e){return{v:n,i:t,j:e}}))},[]);h.selectAll("rect.peak").data(n).enter().append("rect").attr("class","peak").attr("width",100).attr("height",50).attr("transform",k().translate(function(n,e){g.stack[n.i].length-1;return[100*n.i,150+50*(5-n.j-1)]})).transition().duration(y).attr("transform",k().translate(function(n,e){return[100*n.i,50+50*(2-n.j-1)]})),h.selectAll("rect.peak").data(n).transition().duration(y).attr("transform",k().translate(function(n,e){return[100*n.i,50+50*(2-n.j-1)]})),h.selectAll("rect.peak").data(n).exit().transition().duration(y).remove(),f.selectAll("text.peak").data(n).enter().append("text").attr("class","peak").attr("transform",k().translate(function(n,e){g.stack[n.i].length-1;return[100*n.i+50,150+50*(5-n.j-1)+25+5]})).transition().duration(y).attr("transform",k().translate(function(n,e){return[100*n.i+50,50+50*(2-n.j-1)+25+5]})).text(function(n){return n.v}),f.selectAll("text.peak").data(n).transition().duration(y).attr("transform",k().translate(function(n,e){return[100*n.i+50,50+50*(2-n.j-1)+25+5]})).text(function(n){return n.v}),f.selectAll("text.peak").data(n).exit().transition().duration(y).remove()}function c(){m.selectAll("rect.char").data(g.iter).enter().append("rect").attr("class","char").attr("width",100).attr("height",50).transition().duration(y).attr("transform",k().translate(function(n){return[0,0]})),m.selectAll("rect.char").data(g.iter).exit().transition().duration(y).remove()}function p(){var n=g.table.map(function(n,e){var t=x[0].indexOf(n);return w.range(7).map(function(n){return e?{r:n,c:t,t:e}:{r:t,c:n,t:e}})}).reduce(function(n,e){return n.concat(e)},[]);m.selectAll("rect.op-grid").data(n).enter().append("rect").attr("class","op-grid").attr("width",function(n){return n.t?0:50}).attr("height",function(n){return n.t?50:0}).attr("transform",k().translate(function(n){return n.t?[200,50+50*n.r]:[200+50*n.c,50]})).transition().duration(y).attr("width",50).attr("height",50).attr("transform",k().translate(function(n){return[200+50*n.c,50+50*n.r]}));var e=m.selectAll("rect.op-grid").data(n).exit(),t=e[0].map(function(n){return n.__data__}).sort(function(n,e){return n.r===e.r?n.c-e.c:n.r-e.r}).reduce(function(n,e,t){return n.s||n.r===e.r&&n.c===e.c?{r:n.r,c:n.c,s:1}:e},[]);t.r=t.r||0,t.c=t.c||0,e.transition().duration(y/2).attr("transform",k().translate(function(n,e,s){return[200+50*t.c,50+50*t.r]})).transition().duration(y/2).remove()}function l(n,e,t){g=n,y=e,v=t}function d(n,e,t){l(n,e,t),s(),a(),r(),i(),o(),c(),p()}function u(){var n=this,e=w.behavior.zoom().scaleExtent([.1,10]).on("zoom",function(){n.svg.attr("transform",k().translate(w.event.translate).scale(w.event.scale))});this.svg=w.select(this.refs.svg.getDOMNode()).append("svg").call(e).append("g"),this.g=this.svg.append("g").attr("transform",k().translate(10,10).scale(1)),this.gbase=this.g.append("g").attr("class","base"),this.ghigh=this.g.append("g").attr("class","high"),this.gtext=this.g.append("g").attr("class","text"),this.gbase.selectAll("rect.op-grid").data(w.range(49).map(function(n){return{r:Math.floor(n/7),c:n%7}})).enter().append("rect").attr("class","op-grid").attr("transform",k().translate(function(n,e){return[200+50*n.c,50+50*n.r]})).attr("width",function(n){return(n.r+n.c)%2?0:50}).attr("height",function(n){return(n.r+n.c)%2?50:0}).transition().duration(.75*this.props.delay).attr("width",50).attr("height",50),this.gtext.selectAll("text.op-grid").data(x.reduce(function(n,e,t){return n.concat(e.map(function(n,e){return{v:n,r:t,c:e}}))},[])).enter().append("text").attr("class","op-grid").attr("transform",k().translate(function(n,e){return[200+50*n.c+25,50+50*n.r+25+5]})).text("").transition().duration(.75*this.props.delay).text(function(n){return n.v}),h=this.gbase,f=this.gtext,m=this.ghigh,v=this.props.others}var h,f,m,g,y,v,w=t(3),k=t(7),x=[["#","+","-","*","/","(",")"],["+",">",">","<","<","<",">"],["-",">",">","<","<","<",">"],["*",">",">",">",">","<",">"],["/",">",">",">",">","<",">"],["(","<","<","<","<","<","<"],[")","/","/","/","/","/","/"]];n.exports={init:u,render:d}}});