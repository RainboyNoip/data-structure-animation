webpackJsonpdsa([8],{1:function(n,e,t){n.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "./util.h"</span>\n\nvoid* SafeMalloc(size_t size) {\n    void* m;\n    <span class="keyword">if</span> ((m = malloc(size))) {\n        <span class="keyword">return</span> m;\n    } <span class="keyword">else</span> {\n        printf(<span class="string">"memory overflow\\n"</span>);\n        <span class="keyword">exit</span>(-<span class="number">1</span>);\n        <span class="keyword">return</span> <span class="number">0</span>;\n    }\n}\n\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">// }</span>\n    memcpy(a, b, size);\n}\n\nvoid MemorySwap(void *a, void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// char t;</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     t = *(char *)a;</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">//     *((char *)b + i) = t;</span>\n    <span class="comment">// }</span>\n    void *t = SafeMalloc(size);\n    memcpy(t, a, size);\n    memcpy(a, b, size);\n    memcpy(b, t, size);\n}\n\nvoid MemoryClear(void *a, size_t size) {\n    memset(a, <span class="number">0</span>, size);\n}\n\nvoid *MemoryAddress(void *a, int i, size_t size) {\n    <span class="keyword">return</span> (char *)a + i*size;\n}'},2:function(n,e,t){n.exports='<span class="comment">#ifndef UTIL_H</span>\n<span class="comment">#define UTIL_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\nvoid * SafeMalloc(size_t size);\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size);\nvoid MemorySwap(void *a, void *b, size_t size);\nvoid MemoryClear(void *a, size_t size);\n\n<span class="comment">#endif</span>'},12:function(n,e,t){n.exports='<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./stack.h"</span>\n\nint StackIsEmpty(stack *s) {\n  <span class="keyword">return</span> s->top > <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;\n}\n\nint StackIsFull(stack *s) {\n  <span class="keyword">return</span> s->top &lt; s->capacity ? <span class="number">0</span> : <span class="number">1</span>;\n}\n\nvoid* StackPop(stack *s) {\n  void *item = <span class="keyword">NULL</span>;\n  <span class="keyword">if</span> (!StackIsEmpty(s)) {\n    item = (char *)s->items + (s->top-<span class="number">1</span>)*s->item_size;\n    s->top--;\n  }\n  <span class="keyword">return</span> item;\n}\n\nvoid* StackPeak(stack *s) {\n  void *item = <span class="keyword">NULL</span>;\n  <span class="keyword">if</span> (!StackIsEmpty(s)) {\n    item = (char *)s->items + (s->top-<span class="number">1</span>)*s->item_size;\n  }\n  <span class="keyword">return</span> item;\n}\n\nvoid* StackPush(stack *s, void *x) {\n  <span class="keyword">if</span> (!StackIsFull(s)) {\n    MemoryCopy((char *)s->items + s->top*s->item_size, x, s->item_size);\n    s->top++;\n    <span class="keyword">return</span> x;\n  }\n  <span class="keyword">return</span> <span class="keyword">NULL</span>;\n}\n\nstack *StackCreate(int n, size_t item_size) {\n  stack *s = SafeMalloc(sizeof(stack));\n  s->capacity = n;\n  s->item_size = item_size;\n  s->top = <span class="number">0</span>;\n  s->items = SafeMalloc(item_size*n);\n  <span class="keyword">return</span> s;\n}\n\nvoid StackDestroy(stack *s) {\n  free(s->items);\n  free(s);\n}'},13:function(n,e,t){n.exports='<span class="comment">#ifndef STACK_H</span>\n<span class="comment">#define STACK_H</span>\n<span class="comment">#include &lt;stddef.h></span>\n\ntypedef struct stack {\n  int top;\n  int capacity;\n  size_t item_size;\n  void *items;\n} stack;\n\nstack *StackCreate(int n, size_t item_size);\nvoid StackDestroy(stack *s);\nint StackIsEmpty(stack *s);\nint StackIsFull(stack *s);\nvoid* StackPop(stack *s);\nvoid* StackPeak(stack *s);\nvoid* StackPush(stack *s, void *x);\n\n<span class="comment">#endif</span>'},36:function(n,e,t){function s(n){currentStatus.topush=void 0===n?[]:[n]}function a(n){currentStatus.stacktop=void 0===n?[]:[1]}function r(n){currentStatus.topeak=[n]}function i(n,e,t){1===e&&(lastStatus=p(currentStatus)),l.push({status:lastStatus,line:n,animation:t,id:u}),u++}function o(){i(l[l.length-1].line,1)}var c,p=t(6),l=[],u=0,d=[],h=5,f=function(){return a(1),i(7,1),0===d.length?!0:(a(),!1)},m=function(){return a(1),i(11,1),d.length===h?!0:(a(),!1)},g=function(){i(16,1),f()||(i(18,1),d.pop()),i(20,1)},y=function(){return i(25,1),f()?void i(28,1):(i(26,1),c=d[d.length-1],r(c),c)},v=function(n){return s(n),i(32,1),m()?void i(37,1):(i(34,1),d.push(n),s(),void i(35,1))},k=function(){d=[],currentStatus.stack=d};currentStatus={},lastStatus={},n.exports={getInitialDescriptions:function(){return this.initialize(!0),v(0),v(50),this.run("push",100)},initialize:function(n){return l=[],u=0,n&&(d=[]),currentStatus={stack:d,topush:[],topeak:[],stacktop:[]},lastStatus=p(currentStatus),this},push:v,pop:g,peak:y,init:function(){k(),i(0)},run:function(n,e){return this.initialize()[n](e),o(),{frames:l}}}},63:function(n,e,t){var s=t(3),a=t(5),r=t(130);n.exports=s.createClass({displayName:"module.exports",getInitialState:function(){return{text:""}},componentDidMount:function(){r.init.bind(this)(),a.runDemo("init"),a.runDemo("push",1,!1)},componentDidUpdate:function(n){this.props!==n&&void 0!==this.props.frame&&r.render(this.props.frame.status,this.props.delay,this.props.others)},render:function(){return s.createElement("div",{className:"wrapper-code"},s.createElement("div",{className:"list"},s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"init"),value:"初始化"}),s.createElement("input",{onChange:this._onChange,value:this.state.text,placeholder:"整数"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"push"),value:"入栈"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"pop"),value:"出栈"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"peak"),value:"栈顶"})),s.createElement("div",{ref:"svg",className:"scene"}))},_onChange:function(n){this.setState({text:n.target.value})},_onClick:function(n){a.runDemo(n,this.state.text)}})},106:function(n,e,t){n.exports="CC=gcc\nCFLAGS=-c -Wall\nLDFLAGS=\nSOURCES=test.c stack.c stack.h ../common/util.c ../common/util.h\nOBJECTS=$(SOURCES:.cpp=.o)\nEXECUTABLE=a.out\n\nall: $(SOURCES) $(EXECUTABLE)\n\n$(EXECUTABLE): $(OBJECTS)\n    $(CC) $(LDFLAGS) $(OBJECTS) -o $@\n\n.cpp.o:\n    $(CC) $(CFLAGS) $&lt; -o $@\n\nclean:\n    rm -rf *.o a.out"},107:function(n,e,t){n.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include "./stack.h"</span>\n\nint main(int argc, char <span class="keyword">const</span> *argv[]) {\n  int cmd;\n  int a;\n  int *b;\n  stack *s = StackCreate(<span class="number">10</span>, sizeof(int));\n  <span class="keyword">while</span> (scanf(<span class="string">"%d"</span>, &amp;cmd) != EOF) {\n    <span class="keyword">switch</span>(cmd) {\n      <span class="keyword">case</span> <span class="number">0</span>:\n        scanf(<span class="string">"%d\\n"</span>, &amp;a);\n        b = StackPush(s, &amp;a);\n        <span class="keyword">if</span> (b == <span class="keyword">NULL</span>) {\n          printf(<span class="string">"push null\\n"</span>);\n        } <span class="keyword">else</span> {\n          printf(<span class="string">"push %d\\n"</span>, *b);\n        }\n        <span class="keyword">break</span>;\n      <span class="keyword">case</span> <span class="number">1</span>:\n        b = StackPeak(s);\n        <span class="keyword">if</span> (b == <span class="keyword">NULL</span>) {\n          printf(<span class="string">"peak null\\n"</span>);\n        } <span class="keyword">else</span> {\n          printf(<span class="string">"peak %d\\n"</span>, *b);\n        }\n        <span class="keyword">break</span>;\n      <span class="keyword">case</span> <span class="number">2</span>:\n        b = StackPop(s);\n        <span class="keyword">if</span> (b == <span class="keyword">NULL</span>) {\n          printf(<span class="string">"pop null\\n"</span>);\n        } <span class="keyword">else</span> {\n          printf(<span class="string">"pop %d\\n"</span>, *b);\n        }\n        <span class="keyword">break</span>;\n      <span class="keyword">default</span>:\n        <span class="keyword">break</span>;\n    }\n  }\n  StackDestroy(s);\n  <span class="keyword">return</span> <span class="number">0</span>;\n};'},130:function(n,e,t){function s(){u.selectAll("rect.stack-top").data([f.stack.length]).enter().append("rect").attr("class","stack-top").attr("width",100).attr("height",50).attr("transform",y().translate(function(){return[0,-50]})).transition().duration(m).attr("transform",y().translate(function(n,e){return[0,50*(5-n-1)]})),u.selectAll("rect.stack-top").data([f.stack.length]).transition().duration(m).attr("transform",y().translate(function(n,e){return[0,50*(5-n-1)]})),d.selectAll("text.stack-top").data([f.stack.length]).enter().append("text").attr("class","stack-top").attr("transform",y().translate(function(n,e){return[50,-20]})).transition().duration(m).attr("transform",y().translate(function(n,e){return[50,50*(5-n-1)+25+5]})).text(function(){return"栈顶"}),d.selectAll("text.stack-top").data([f.stack.length]).transition().duration(m).attr("transform",y().translate(function(n,e){return[50,50*(5-n-1)+25+5]}))}function a(){u.selectAll("rect.item").data(f.stack).enter().append("rect").attr("class","item").attr("width",100).attr("height",50).attr("transform",y().translate(function(n){return[0,-100]})).transition().duration(m).attr("transform",y().translate(function(n,e){return[0,50*(5-e-1)]})),u.selectAll("rect.item").data(f.stack).transition().duration(m).attr("transform",y().translate(function(n,e){return[0,50*(5-e-1)]})),u.selectAll("rect.item").data(f.stack).exit().transition().duration(m).remove(),d.selectAll("text.item").data(f.stack).enter().append("text").attr("class","item").attr("transform",y().translate(function(n){return[50,-70]})).transition().duration(m).attr("transform",y().translate(function(n,e){return[50,50*(5-e-1)+25+5]})).text(function(n){return n}),d.selectAll("text.item").data(f.stack).transition().duration(m).attr("transform",y().translate(function(n,e){return[50,50*(5-e-1)+25+5]})).text(function(n){return n}),d.selectAll("text.item").data(f.stack).exit().transition().duration(m).remove()}function r(){u.selectAll("rect.peak").data(f.topeak).enter().append("rect").attr("class","peak").attr("width",100).attr("height",50).attr("transform",y().translate(function(n,e){var t=f.stack.length-1;return[0,50*(5-t-1)]})).transition().duration(m).attr("transform",y().translate(function(n,e){return[0,-100]})),u.selectAll("rect.peak").data(f.topeak).exit().transition().duration(m).remove(),d.selectAll("text.peak").data(f.topeak).enter().append("text").attr("class","peak").attr("transform",y().translate(function(n,e){var t=f.stack.length-1;return[50,50*(5-t-1)+25+5]})).transition().duration(m).attr("transform",y().translate(function(n,e){return[50,-70]})).text(function(n){return n}),d.selectAll("text.peak").data(f.topeak).text(function(n){return n}),d.selectAll("text.peak").data(f.topeak).exit().transition().duration(m).remove()}function i(){u.selectAll("rect.push").data(f.topush).enter().append("rect").attr("class","push").attr("width",100).attr("height",50).attr("transform",y().translate(function(n,e){return[0,-100]})).style("opacity",0).transition().duration(m).style("opacity",1),u.selectAll("rect.push").data(f.topush).exit().transition().duration(m).remove(),d.selectAll("text.push").data(f.topush).enter().append("text").attr("class","push").attr("transform",y().translate(function(n,e){return[50,-70]})).style("opacity",0).transition().duration(m).style("opacity",1).text(function(n){return n}),d.selectAll("text.push").data(f.topush).text(function(n){return n}),d.selectAll("text.push").data(f.topush).exit().transition().duration(m).remove()}function o(){h.selectAll("rect.stack-top-high").data(f.stacktop).enter().append("rect").attr("class","stack-top-high").attr("width",100).attr("height",50).attr("transform",y().translate(function(n,e){var t=f.stack.length;return[0,50*(5-t-1)]})).style("opacity",0).transition().duration(m).style("opacity",1),h.selectAll("rect.stack-top-high").data(f.stacktop).attr("transform",y().translate(function(n,e){var t=f.stack.length;return[0,50*(5-t-1)]})),h.selectAll("rect.stack-top-high").data(f.stacktop).exit().transition().duration(m).remove()}function c(n,e){f=n,m=e}function p(n,e){c(n,e),s(),a(),r(),i(),o()}function l(){var n=this,e=g.behavior.zoom().scaleExtent([.1,10]).on("zoom",function(){n.svg.attr("transform",y().translate(g.event.translate).scale(g.event.scale))});this.svg=g.select(this.refs.svg.getDOMNode()).append("svg").call(e).append("g"),this.g=this.svg.append("g").attr("transform",y().translate(200,200).scale(1)),this.gbase=this.g.append("g").attr("class","base"),this.ghigh=this.g.append("g").attr("class","high"),this.gtext=this.g.append("g").attr("class","text"),this.gbase.append("rect").attr("class","stack").attr("width",100).attr("height",250).attr("transform",y().translate(function(n,e){return[0,-250]})).transition().duration(.75*this.props.delay).attr("transform",y().translate(function(n,e){return[0,0]})),u=this.gbase,d=this.gtext,h=this.ghigh}var u,d,h,f,m,g=t(4),y=t(7);n.exports={init:l,render:p}}});