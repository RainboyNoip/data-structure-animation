webpackJsonpdsa([1],{9:function(e,t,n){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "./util.h"</span>\n\nvoid* SafeMalloc(size_t size) {\n    void* m;\n    <span class="keyword">if</span> ((m = malloc(size))) {\n        <span class="keyword">return</span> m;\n    } <span class="keyword">else</span> {\n        printf(<span class="string">"memory overflow\\n"</span>);\n        <span class="keyword">exit</span>(-<span class="number">1</span>);\n        <span class="keyword">return</span> <span class="number">0</span>;\n    }\n}\n\n<span class="comment">// FIXME</span>\n<span class="comment">//   stack,queue and other dsa should use dynamically</span>\n<span class="comment">//   allocated memory, which is what util.c provides.</span>\n<span class="comment">//   Also should be included in model-file descripttions.</span>'},10:function(e,t,n){e.exports='<span class="comment">#ifndef UTIL_H</span>\n<span class="comment">#define UTIL_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\nvoid * SafeMalloc(size_t size);\n\n<span class="comment">#endif</span>'},18:function(e,t,n){function r(e,t,n,r){var i={id:g++};return i.key=e,i.val=t,i.left=n,i.right=r,a(i),i}function a(e){null===e.left&&null===e.right?e.size=1:(e.size=0,null!==e.left&&(e.size+=e.left.size),null!==e.right&&(e.size+=e.right.size))}function i(e,t,n){return null===t.left&&null===t.right?void(e.table[e.size++]={key:t.key,val:t.val,code:n}):(i(e,t.left,n+"0"),void i(e,t.right,n+"1"))}function s(e){var t,n,a,i=[],s=[];for(c(51,1),a=0;a<e.length;++a){var n=e.charCodeAt(a);n>=0&&256>n&&(i[n]=(i[n]||0)+1)}for(c(62,1),a=0;256>a;++a)i[a]>0&&(t=String.fromCharCode(a),s.push(r(i[a],t,null,null)));return m.array=s,m.n=s.length,c(70,1),l(s)}function o(e,t){return e.key!==t.key?e.key-t.key:e.id-t.id}function l(e){var t,n,a,s,l,p,f;for(n=e.length,c(86,1),a=new u(o),t=0;n>t;++t)a.insert(e[t]);for(m.array=a.array;c(91,1),a.array.length>1;)c(92),p=a.pop(),c(93),f=a.pop(),c(94),l=r(p.key+f.key,"",p,f),m.pop=l,c(95,1),a.insert(l),m.pop=void 0,c(96,1);return c(97,1),s={root:null},c(98,1),s.root=a.pop(),m.array=[s.root],m.onlyTree=!0,c(99,1),s.size=0,c(100),s.table=[],c(101),s.root&&i(s,s.root,""),c(102),s}function c(e,t,n){1===t&&(lastStatus=m.clone()),h.push({status:lastStatus,line:e,animation:n,id:d}),d++}function p(){c(h[h.length-1].line,1)}function u(e){this.array=[],this.cf=e}var f=n(4),h=[],d=0,m={},g=0;m.clone=function(){return{array:f(this.array)||[],pop:f(this.pop),n:this.n||0,onlyTree:this.onlyTree}},m.init=function(e){this.array=[],this.pop=void 0,this.n=0,this.onlyTree=!1},lastStatus={},e.exports={getInitialDescriptions:function(){return this.initialize(!0),this.run("create","The quick brown fox jumps over the lazy dog")},initialize:function(e){return h=[],d=0,g=0,m.init(e),lastStatus=m.clone(),this},create:s,run:function(e,t){return this.initialize()[e](t),p(),{frames:h,others:{}}}},u.prototype.p=function(e){return 0==e?0:Math.floor((e-1)/2)},u.prototype.l=function(e){return 2*e+1},u.prototype.r=function(e){return 2*e+2},u.prototype.ex=function(e,t){var n=this.array[e];this.array[e]=this.array[t],this.array[t]=n},u.prototype.insert=function(e){this.array.push(e);for(var t=this.array.length-1;0!=t&&this.cf(this.array[t],this.array[this.p(t)])<0;)this.ex(t,this.p(t)),t=this.p(t)},u.prototype.pop=function(){var e,t,n;if(0!==this.array.length){for(n=this.array[0],this.array[0]=this.array[this.array.length-1],this.array.pop(),e=0,t=-1;e!==t;)t=e,void 0!==this.array[this.l(e)]&&this.cf(this.array[this.l(e)],this.array[e])<0&&(t=this.l(e)),void 0!==this.array[this.r(e)]&&this.cf(this.array[this.r(e)],this.array[t])<0&&(t=this.r(e)),t!=e&&(this.ex(e,t),e=t,t=-1);return n}}},26:function(e,t,n){t=e.exports=n(7)(),t.push([e.id,".axis text{display:none}",""])},37:function(e,t,n){var r=n(1),a=n(2);e.exports=r.createClass({displayName:"module.exports",getInitialState:function(){return{text:""}},render:function(){return r.createElement("div",{className:"list"},r.createElement("input",{onChange:this._onChange,value:this.state.text,placeholder:"字符串"}),r.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"create"),value:"编码",title:"编码"}))},_onChange:function(e){this.setState({text:e.target.value})},_onClick:function(e){a.runDemo(e,this.state.text)}})},47:function(e,t,n){e.exports="CC=gcc\nCFLAGS=-c -Wall\nLDFLAGS=\nSOURCES=test.c huffman-tree.c huffman-tree.h ../common/util.c ../common/util.h ../min-heap/min-heap.c ../min-heap/min-heap.h\nOBJECTS=$(SOURCES:.c=.o)\nEXECUTABLE=a.out\n\nall: $(SOURCES) $(EXECUTABLE)\n\n$(EXECUTABLE): $(OBJECTS)\n    $(CC) $(LDFLAGS) $(OBJECTS) -o $@\n\n.cpp.o:\n    $(CC) $(CFLAGS) $&lt; -o $@\n\nclean:\n    rm -rf *.o a.out"},48:function(e,t,n){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "./huffman-tree.h"</span>\n<span class="comment">#include "../min-heap/min-heap.h"</span>\n<span class="comment">#include "../common/util.h"</span>\n\nhuffman_tree_node* _NewNode(int k, char v, huffman_tree_node* l, huffman_tree_node* r) {\n    huffman_tree_node* node = (huffman_tree_node*)SafeMalloc(sizeof(huffman_tree_node));\n    node->key = k;\n    node->val = v;\n    node->left = l;\n    node->right = r;\n    <span class="keyword">return</span> node;\n}\n\nhuffman_tree_item* _NewItem(int k, char v, char* c) {\n    huffman_tree_item* item = (huffman_tree_item*)SafeMalloc(sizeof(huffman_tree_item));\n    item->key = k;\n    item->val = v;\n    item->code = (char*)SafeMalloc(sizeof(c));\n    strcpy(item->code, c);\n    <span class="keyword">return</span> item;\n}\n\nchar* _Append(char* s, char* t) {\n    char* r = (char*)SafeMalloc(sizeof(s)+sizeof(char));\n    strcpy(r,s);\n    strcat(r,t);\n    <span class="keyword">return</span> r;\n}\n\nvoid _Traverse(huffman_tree* t, huffman_tree_node* x, char* s) {\n    <span class="keyword">if</span> (x->left == <span class="keyword">NULL</span> &amp;&amp; x->right == <span class="keyword">NULL</span>) {\n        t->table[t->size++] = _NewItem(x->key, x->val, s);\n        <span class="keyword">return</span>;\n    }\n    _Traverse(t, x->left, _Append(s,<span class="string">"0"</span>));\n    _Traverse(t, x->right, _Append(s,<span class="string">"1"</span>));\n}\n\nhuffman_tree* HuffmanTreeCreate(char *s) {\n    int tbl[<span class="number">256</span>];\n    int i;\n    int n = <span class="number">0</span>;\n    char* s2 = <span class="keyword">NULL</span>;\n    int* tbl2 = <span class="keyword">NULL</span>;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) {\n        tbl[i] = <span class="number">0</span>;\n    }\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; strlen(s); ++i) {\n        <span class="keyword">if</span> (<span class="number">0</span> &lt;= s[i] &amp;&amp; s[i] &lt; <span class="number">256</span>) {\n            <span class="keyword">if</span> (tbl[(int)s[i]] == <span class="number">0</span>) {\n                n++;\n            }\n            tbl[(int)s[i]]++;\n        }\n    }\n    s2 = (char*)SafeMalloc(sizeof(char)*(n+<span class="number">1</span>));\n    tbl2 = (int*)SafeMalloc(sizeof(int)*(n));\n    n = <span class="number">0</span>;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) {\n        <span class="keyword">if</span> (tbl[i] > <span class="number">0</span>) {\n            s2[n] = (char)i;\n            tbl2[n] = tbl[i];\n            n++;\n        }\n    }\n    s2[n] = <span class="string">\'\\0\'</span>;\n    <span class="keyword">return</span> HuffmanTreeCreateWithFreq(s2,tbl2);\n}\n\nint _CompareFn(<span class="keyword">const</span> void* a, <span class="keyword">const</span> void* b) {\n    <span class="keyword">return</span> ((huffman_tree_node*)a)->key - ((huffman_tree_node*)b)->key;\n}\n\nhuffman_tree* HuffmanTreeCreateWithFreq(char* s, int* tbl) {\n    int i;\n    int n;\n    min_heap* h;\n    huffman_tree* t;\n    huffman_tree_node* node;\n    huffman_tree_node* node1;\n    huffman_tree_node* node2;\n    n = strlen(s);\n    h = MinHeapCreate(n, _CompareFn);\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) {\n        node = _NewNode(tbl[i], s[i], <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);\n        MinHeapInsert(h, node);\n    }\n    <span class="keyword">while</span> (h->size > <span class="number">1</span>) {\n        node1 = (huffman_tree_node*)MinHeapPop(h);\n        node2  = (huffman_tree_node*)MinHeapPop(h);\n        node = _NewNode(node1->key + node2->key, node1->val, node1, node2);\n        MinHeapInsert(h, node);\n    }\n    t = (huffman_tree*)SafeMalloc(sizeof(huffman_tree));\n    t->root = (huffman_tree_node*)MinHeapPop(h);\n    t->size = <span class="number">0</span>;\n    t->table = (huffman_tree_item**)SafeMalloc(sizeof(huffman_tree_item*)*n);\n    _Traverse(t, t->root, <span class="string">""</span>);\n    <span class="keyword">return</span> t;\n}'},49:function(e,t,n){e.exports='<span class="comment">#ifndef HUFFMAN_TREE_H</span>\n<span class="comment">#define HUFFMAN_TREE_H</span>\n\ntypedef struct huffman_tree_node {\n  int key;\n  char val;\n  struct huffman_tree_node* left;\n  struct huffman_tree_node* right;\n} huffman_tree_node;\n\ntypedef struct huffman_tree_item {\n  int key;\n  char val;\n  char* code;\n} huffman_tree_item;\n\ntypedef struct huffman_tree {\n  struct huffman_tree_node* root;\n  struct huffman_tree_item** table;\n  int size;\n} huffman_tree;\n\nhuffman_tree* HuffmanTreeCreate(char *);\nhuffman_tree* HuffmanTreeCreateWithFreq(char *, int *);\n\n<span class="comment">#endif</span>'},50:function(e,t,n){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "./huffman-tree.h"</span>\n\nint main(int argc, char <span class="keyword">const</span> *argv[]) {\n  char *s;\n  size_t buf = <span class="number">0</span>;\n  int tbl[<span class="number">100</span>];\n  int i;\n  int l;\n  int type;\n  huffman_tree* t;\n  printf(<span class="string">"0: full text, 1: text with freq > "</span>);\n  scanf(<span class="string">"%d\\n"</span>, &amp;type);\n  <span class="keyword">if</span> (type) {\n    getline(&amp;s, &amp;buf, stdin);\n    l = strlen(s)-<span class="number">1</span>;\n    s[l--] = <span class="string">\'\\0\'</span>;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; l; ++i) {\n      scanf(<span class="string">"%d"</span>, &amp;tbl[i]);\n    }\n    t = HuffmanTreeCreateWithFreq(s, tbl);\n  } <span class="keyword">else</span> {\n    getline(&amp;s, &amp;buf, stdin);\n    l = strlen(s)-<span class="number">1</span>;\n    s[l--] = <span class="string">\'\\0\'</span>;\n    printf(<span class="string">"%s\\n"</span>,s);\n    t = HuffmanTreeCreate(s);\n  }\n  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; t->size; ++i) {\n    printf(<span class="string">"char %c, freq %d, code %s\\n"</span>, t->table[i]->val, t->table[i]->key, t->table[i]->code);\n  }\n  <span class="keyword">return</span> <span class="number">0</span>;\n};'},51:function(e,t,n){e.exports='<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./min-heap.h"</span>\n<span class="comment">#include &lt;stdio.h></span>\n\nmin_heap* MinHeapCreate(int n, int (*CompFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*)) {\n    min_heap* h = (min_heap*)SafeMalloc(sizeof(min_heap));\n    h-><span class="keyword">array</span> = (void**)SafeMalloc(sizeof(void*)*n);\n    h->capacity = n;\n    h->size = <span class="number">0</span>;\n    h->Compare = CompFn;\n    <span class="keyword">return</span> h;\n}\nint _P(int x) {\n    <span class="keyword">return</span> x == <span class="number">0</span> ? <span class="number">0</span> : (x-<span class="number">1</span>)/<span class="number">2</span>;\n}\nint _L(int x) {\n    <span class="keyword">return</span> x*<span class="number">2</span>+<span class="number">1</span>;\n}\nint _R(int x) {\n    <span class="keyword">return</span> x*<span class="number">2</span>+<span class="number">2</span>;\n}\nvoid _Exchange(min_heap* h, int i, int j) {\n    void* tmp = h-><span class="keyword">array</span>[i];\n    h-><span class="keyword">array</span>[i] = h-><span class="keyword">array</span>[j];\n    h-><span class="keyword">array</span>[j] = tmp;\n}\n\nvoid MinHeapInsert(min_heap* h, void* item) {\n    int x = h->size;\n    <span class="keyword">if</span> (x == h->capacity) {\n        <span class="keyword">return</span>;\n    }\n    h-><span class="keyword">array</span>[x] = item;\n    h->size++;\n    <span class="keyword">while</span> (x != <span class="number">0</span> &amp;&amp; h->Compare(h-><span class="keyword">array</span>[x], h-><span class="keyword">array</span>[_P(x)]) &lt; <span class="number">0</span>) {\n        _Exchange(h, x, _P(x));\n        x = _P(x);\n    }\n}\n\nvoid* MinHeapPop(min_heap* h) {\n    int x;\n    int y;\n    void* item;\n    <span class="keyword">if</span> (h->size == <span class="number">0</span>) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    item = h-><span class="keyword">array</span>[<span class="number">0</span>];\n    h-><span class="keyword">array</span>[<span class="number">0</span>] = h-><span class="keyword">array</span>[h->size-<span class="number">1</span>];\n    h-><span class="keyword">array</span>[h->size-<span class="number">1</span>] = <span class="keyword">NULL</span>;\n    h->size--;\n    x = <span class="number">0</span>;\n    y = -<span class="number">1</span>;\n    <span class="keyword">while</span> (x != y) {\n        y = x;\n        <span class="keyword">if</span> (_L(x) &lt; h->size) {\n            <span class="keyword">if</span> (h->Compare(h-><span class="keyword">array</span>[_L(x)], h-><span class="keyword">array</span>[x]) &lt; <span class="number">0</span>) {\n                y = _L(x);\n            }\n        }\n        <span class="keyword">if</span> (_R(x) &lt; h->size) {\n            <span class="keyword">if</span> (h->Compare(h-><span class="keyword">array</span>[_R(x)], h-><span class="keyword">array</span>[y]) &lt; <span class="number">0</span>) {\n                y = _R(x);\n            }\n        }\n        <span class="keyword">if</span> (y != x) {\n            _Exchange(h, x, y);\n            x = y;\n            y = -<span class="number">1</span>;\n        }\n    }\n    <span class="keyword">return</span> item;\n}'},52:function(e,t,n){e.exports='<span class="comment">#ifndef MIN_HEAP_H</span>\n<span class="comment">#define MIN_HEAP_H</span>\n\ntypedef struct min_heap {\n    int size;\n    int capacity;\n    void** <span class="keyword">array</span>;\n    int (*Compare)(<span class="keyword">const</span> void* a, <span class="keyword">const</span> void* b);\n} min_heap;\n\nmin_heap* MinHeapCreate(int n, int (*CompFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*));\nvoid MinHeapInsert(min_heap* h, void* item);\nvoid* MinHeapPop(min_heap* h);\n\n<span class="comment">#endif</span>'},71:function(e,t,n){var r=n(26);"string"==typeof r&&(r=[[e.id,r,""]]);n(8)(r,{})},77:function(e,t,n){function r(e){return e.id}function a(e,t){_=e,b=t}function i(){w.attr("transform","translate(0,"+E+")").transition().style("opacity",_.onlyTree?0:1).call(F)}function s(){function e(e){return e.inner?10:e.inner===!1&&_.onlyTree?N(e.key):z}y.selectAll("rect.node").data(D,r).enter().append("rect").attr("class","node").attr("x",function(e){return e.ex-e.ew/2}).attr("y",function(e){return E}).attr("width",function(e){return e.ew}).attr("height",function(e){return e.inner?10:z}).style("fill",function(e){return e.inner?"black":O(e.id)}),y.selectAll("rect.node").data(D,r).transition().duration(b).attr("x",function(e){return e.x-e.w/2}).attr("y",function(e){return e.y-5}).attr("width",function(e){return e.w}).attr("height",e),y.selectAll("rect.node").data(D,r).exit().remove()}function o(){function e(){this.attr("x1",function(e){return e.x1}).attr("y1",function(e){return e.y1}).attr("x2",function(e){return e.x2}).attr("y2",function(e){return e.y2})}function t(e){this.attr("x",function(e){return(e.x1+e.x2)/2}).attr("y",function(e){return(e.y1+e.y2)/2})}function n(e){var t=e.x1-e.x2,n=e.y1-e.y2,r=Math.sqrt(t*t+n*n);return r/5+"px"}v.selectAll("line.edge").data(A,r).transition().duration(b).call(e),v.selectAll("line.edge").data(A,r).enter().append("line").attr("class","edge").attr("x1",function(e){return e.x1}).attr("y1",function(e){return e.y1}).attr("x2",function(e){return e.x1}).attr("y2",function(e){return e.y1}).attr("stroke","black").attr("stroke-width",3).attr("stroke-opacity",1).transition().duration(b/2).delay(b/2).call(e),v.selectAll("line.edge").data(A,r).exit().remove(),m.selectAll("text.edge").data(A,r).transition().duration(b).call(t).text(function(e){return e.left?"0":"1"}).style("font-size",n),m.selectAll("text.edge").data(A,r).enter().append("text").attr("class","edge").attr("x",function(e){return(e.x1+e.x1)/2}).attr("y",function(e){return(e.y1+e.y1)/2}).style("fill","black").attr("stroke-opacity",1).transition().duration(b/2).delay(b/2).call(t).text(function(e){return e.left?"0":"1"}).style("font-size",n),m.selectAll("text.edge").data(A,r).exit().remove()}function l(){function e(){this.transition().duration(b/2).attr("y",function(e){return B(e.y0+e.y)}).attr("height",function(e){return B(e.y0)-B(e.y0+e.y)}).transition().duration(b/2).attr("x",function(e){return U(e.fi)}).attr("width",function(e){return U.rangeBand()})}function t(){this.transition().duration(b).attr("x",function(e){return U(e.fi)}).attr("width",function(e){return U.rangeBand()}).attr("y",function(e){return B(e.y0+e.y)}).attr("height",function(e){return B(e.y0)-B(e.y0+e.y)})}var n=L;_.onlyTree&&(n=[]),d.selectAll("rect.item").data(n,r).enter().append("rect").attr("class","item").attr("x",function(e){return U(e.fi)}).attr("y",function(e){return E}).attr("width",function(e){return U.rangeBand()}).attr("height",0).style("fill",function(e){return O(e.id)}),d.selectAll("rect.item").data(n,r).call(_.pop?e:t),d.selectAll("rect.item").data(n,r).exit().transition().duration(b).style("opacity",0).remove(),m.selectAll("text.item").data(L,r).enter().append("text").attr("class","item").attr("x",function(e){return e.tx}).attr("y",function(e){return e.ty+20}).style("fill",function(e){return O(e.id)}).text(function(e){return e.val}),m.selectAll("text.item").data(L,r).transition().duration(b).attr("x",function(e){return e.tx}).attr("y",function(e){return e.ty+20}),m.selectAll("text.item").data(L,r).exit().transition().duration(b).style("opacity",0).remove()}function c(e,t,n,r,a,i){if(null!==e){var s={key:e.key,val:e.val,x:n+(t.size-e.size)*a,y:r+(t.size-e.size)*(a>0?a:-a),w:1===e.size?i:10,inner:1!==e.size,id:e.id,ex:C(0>a?0:1)+C.rangeBand()/2,ew:1===e.size?C.rangeBand():10};1===e.size&&L.push({val:e.val,id:e.id,y:e.key,tx:s.x,ty:s.y}),D.push(s),A.push({x1:s.x,y1:s.y,x2:n,y2:r,id:e.id+"-"+t.id,left:e===t.left}),c(e.left,e,s.x,s.y,0>a?a:-a,i),c(e.right,e,s.x,s.y,a>0?a:-a,i)}}function p(){function e(e){for(c(tmpa[t][e],tmpa[t],a,E,"left"===e?-r:r,n);i<L.length;++i)L[i].y0=o,L[i].fi=t,L[i].si=s++,o+=L[i].y}void 0===_.array.sorted&&(_.array.sort(function(e,t){return e.key===t.key?e.id-t.id:e.key-t.key}),_.array.sorted=!0),tmpa=[],D=[],A=[],L=[],_.pop?(offset=1,tmpa.push(_.pop)):offset=0,tmpa=tmpa.concat(_.array),U.rangeRoundBands([0,Math.max(P,P/10*_.n)],.08).domain(T.range(tmpa.length)),I.rangeRoundBands([0,U.rangeBand()],.08),C=U.copy().domain(T.range(tmpa.length+1)),k=T.max(tmpa,function(e){return e.key}),k=k||20,E=Math.max(R,R/10*_.n),B.range([E,0]).domain([0,k]);for(var t=0;t<tmpa.length;++t)if(tmpa[t].size>1){I.domain(T.range(tmpa[t].size));var n=I.rangeBand(),r=(I(1)-I(0))/2,a=U(t)+U.rangeBand()/2,i=L.length,s=0,o=0;e("left"),e("right")}else L.push({val:tmpa[t].val,id:tmpa[t].id,y:tmpa[t].key,y0:0,fi:t,si:0,tx:U(t)+U.rangeBand()/2,ty:E});N.domain([0,T.max(L,function(e){return e.y})])}function u(){function e(){this.transition().duration(b).attr("transform","translate(0,"+(_.onlyTree?-E:0)+")")}gtree.call(e),m.call(e)}function f(e,t){a(e,t),p(),i(),s(),o(),l(),u()}function h(){var e=this,t=T.behavior.zoom().scaleExtent([.1,10]).on("zoom",function(){e.svg.attr("transform",M().translate(T.event.translate).scale(T.event.scale))});this.svg=T.select(this.refs.svg.getDOMNode()).append("svg").call(t).append("g"),this.g=this.svg.append("g").attr("transform",M().translate(100,100).scale(.5)),g=this.g.append("g").attr("class","high"),gtree=this.g.append("g").attr("class","tree"),d=this.g.append("g").attr("class","base"),m=this.g.append("g").attr("class","text"),v=gtree.append("g").attr("class","edges"),y=gtree.append("g").attr("class","nodes"),w=this.g.append("g").attr("class","axis"),x=this.g.append("g").attr("class","axis")}n(71);{var d,m,g,y,v,w,x,_,b,E,k,D,A,L,T=n(3),M=n(5),S={top:40,right:10,bottom:20,left:10},P=720-S.left-S.right,R=500-S.top-S.bottom,U=T.scale.ordinal().rangeRoundBands([0,P],.08),I=T.scale.ordinal(),C=T.scale.ordinal(),B=T.scale.linear().range([R,0]),N=T.scale.linear().range([40,100]),O=T.scale.category20(),z=40,F=T.svg.axis().scale(U).tickSize(0).tickPadding(6).orient("bottom");T.svg.axis().scale(B).tickSubdivide(1).orient("left")}e.exports={init:h,render:f}}});