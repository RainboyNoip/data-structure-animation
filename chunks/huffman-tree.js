webpackJsonpdsa([1],{6:function(e,t,n){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "./util.h"</span>\n\nvoid* SafeMalloc(size_t size) {\n    void* m;\n    <span class="keyword">if</span> ((m = malloc(size))) {\n        <span class="keyword">return</span> m;\n    } <span class="keyword">else</span> {\n        printf(<span class="string">"memory overflow\\n"</span>);\n        <span class="keyword">exit</span>(-<span class="number">1</span>);\n        <span class="keyword">return</span> <span class="number">0</span>;\n    }\n}\n\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">// }</span>\n    memcpy(a, b, size);\n}\n\nvoid MemorySwap(void *a, void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// char t;</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     t = *(char *)a;</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">//     *((char *)b + i) = t;</span>\n    <span class="comment">// }</span>\n    void *t = SafeMalloc(size);\n    memcpy(t, a, size);\n    memcpy(a, b, size);\n    memcpy(b, t, size);\n}\n\nvoid MemoryClear(void *a, size_t size) {\n    memset(a, <span class="number">0</span>, size);\n}\n\nvoid *MemoryAddress(void *a, int i, size_t size) {\n    <span class="keyword">return</span> (char *)a + i*size;\n}'},7:function(e,t,n){e.exports='<span class="comment">#ifndef UTIL_H</span>\n<span class="comment">#define UTIL_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\nvoid * SafeMalloc(size_t size);\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size);\nvoid MemorySwap(void *a, void *b, size_t size);\nvoid MemoryClear(void *a, size_t size);\n\n<span class="comment">#endif</span>'},19:function(e,t,n){function r(e,t,n,r){var s={id:m++,p:null};return s.key=e,s.val=t,s.left=n,null!==n&&(n.p=s),s.right=r,null!==r&&(r.p=s),i(s),s}function i(e){null===e.left&&null===e.right?e.size=1:(e.size=0,null!==e.left&&(e.size+=e.left.size),null!==e.right&&(e.size+=e.right.size))}function s(e){var t,n,i,s={},a=[];for(d.l=e.length,c(51,1),i=0;i<e.length;++i){var n=e.charCodeAt(i);s[n]=(s[n]||0)+1}c(62,1);for(i in s)s[i]>0&&(t=String.fromCharCode(i),a.push(r(s[i],t,null,null)));return d.array=a,d.n=a.length,c(70,1),o(a)}function a(e,t){return e.key!==t.key?e.key-t.key:e.id-t.id}function o(e){var t,n,i,s,o,l,u;for(n=e.length,c(86,1),i=new p(a),d.sorted=!0,t=0;n>t;++t)i.insert(e[t]);for(d.array=i.array;c(91,1),i.array.length>1;)c(92),l=i.pop(),d.hl=1,d.pop=[l],c(93,1),u=i.pop(),d.hl=2,d.pop.push(u),c(94,1),o=r(l.key+u.key,"",l,u),d.pop=[o],d.hl=1,c(95,1),i.insert(o),d.pop=[],d.hl=0;return c(97,1),c(98),c(99),c(100),c(101),d.zo=!0,c(102,1),s}function c(e,t,n){1===t&&(lastStatus=d.clone()),h.push({status:lastStatus,line:e,animation:n,id:f}),f++}function l(){c(h[h.length-1].line,1)}function p(e){this.array=[],this.cf=e}var u=n(4),h=[],f=0,d={},m=0;d.clone=function(){return{array:u(this.array)||[],pop:u(this.pop)||[],n:this.n||0,l:this.l||0,zo:this.zo||!1,sorted:this.sorted||!1,hl:this.hl||0}},d.init=function(e){this.array=[],this.pop=[],this.n=0,this.l=0,this.zo=!1,this.sorted=!1,this.hl=0},lastStatus={},e.exports={getInitialDescriptions:function(){return this.initialize(!0),this.run("create","The quick brown fox jumps over the lazy dog")},initialize:function(e){return h=[],f=0,m=0,d.init(e),lastStatus=d.clone(),this},create:s,run:function(e,t){return this.initialize()[e](t),l(),{frames:h,others:{}}}},p.prototype.p=function(e){return 0==e?0:Math.floor((e-1)/2)},p.prototype.l=function(e){return 2*e+1},p.prototype.r=function(e){return 2*e+2},p.prototype.ex=function(e,t){var n=this.array[e];this.array[e]=this.array[t],this.array[t]=n},p.prototype.insert=function(e){this.array.push(e);for(var t=this.array.length-1;0!=t&&this.cf(this.array[t],this.array[this.p(t)])<0;)this.ex(t,this.p(t)),t=this.p(t)},p.prototype.pop=function(){var e,t,n;if(0!==this.array.length){for(n=this.array[0],this.array[0]=this.array[this.array.length-1],this.array.pop(),e=0,t=-1;e!==t;)t=e,void 0!==this.array[this.l(e)]&&this.cf(this.array[this.l(e)],this.array[e])<0&&(t=this.l(e)),void 0!==this.array[this.r(e)]&&this.cf(this.array[this.r(e)],this.array[t])<0&&(t=this.r(e)),t!=e&&(this.ex(e,t),e=t,t=-1);return n}}},29:function(e,t,n){t=e.exports=n(8)(),t.push([e.id,".axis text{display:none}",""])},43:function(e,t,n){var r=n(1),i=n(2);e.exports=r.createClass({displayName:"module.exports",getInitialState:function(){return{text:""}},render:function(){return r.createElement("div",{className:"list"},r.createElement("input",{onChange:this._onChange,value:this.state.text,placeholder:"字符串"}),r.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"create"),value:"编码",title:"编码"}))},_onChange:function(e){this.setState({text:e.target.value})},_onClick:function(e){i.runDemo(e,this.state.text)}})},59:function(e,t,n){e.exports="CC=gcc\nCFLAGS=-c -Wall\nLDFLAGS=\nSOURCES=test.c huffman-tree.c huffman-tree.h ../common/util.c ../common/util.h ../min-heap/min-heap.c ../min-heap/min-heap.h\nOBJECTS=$(SOURCES:.c=.o)\nEXECUTABLE=a.out\n\nall: $(SOURCES) $(EXECUTABLE)\n\n$(EXECUTABLE): $(OBJECTS)\n    $(CC) $(LDFLAGS) $(OBJECTS) -o $@\n\n.cpp.o:\n    $(CC) $(CFLAGS) $&lt; -o $@\n\nclean:\n    rm -rf *.o a.out"},60:function(e,t,n){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "./huffman-tree.h"</span>\n<span class="comment">#include "../min-heap/min-heap.h"</span>\n<span class="comment">#include "../common/util.h"</span>\n\nhuffman_tree_node* _NewNode(int k, char v, huffman_tree_node* l, huffman_tree_node* r) {\n    huffman_tree_node* node = (huffman_tree_node*)SafeMalloc(sizeof(huffman_tree_node));\n    node->key = k;\n    node->val = v;\n    node->left = l;\n    node->right = r;\n    <span class="keyword">return</span> node;\n}\n\nhuffman_tree_item* _NewItem(int k, char v, char* c) {\n    huffman_tree_item* item = (huffman_tree_item*)SafeMalloc(sizeof(huffman_tree_item));\n    item->key = k;\n    item->val = v;\n    item->code = (char*)SafeMalloc(sizeof(c));\n    strcpy(item->code, c);\n    <span class="keyword">return</span> item;\n}\n\nchar* _Append(char* s, char* t) {\n    char* r = (char*)SafeMalloc(sizeof(s)+sizeof(char));\n    strcpy(r,s);\n    strcat(r,t);\n    <span class="keyword">return</span> r;\n}\n\nvoid _Traverse(huffman_tree* t, huffman_tree_node* x, char* s) {\n    <span class="keyword">if</span> (x->left == <span class="keyword">NULL</span> &amp;&amp; x->right == <span class="keyword">NULL</span>) {\n        t->table[t->size++] = _NewItem(x->key, x->val, s);\n        <span class="keyword">return</span>;\n    }\n    _Traverse(t, x->left, _Append(s,<span class="string">"0"</span>));\n    _Traverse(t, x->right, _Append(s,<span class="string">"1"</span>));\n}\n\nhuffman_tree* HuffmanTreeCreate(char *s) {\n    int tbl[<span class="number">256</span>];\n    int i;\n    int n = <span class="number">0</span>;\n    char* s2 = <span class="keyword">NULL</span>;\n    int* tbl2 = <span class="keyword">NULL</span>;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) {\n        tbl[i] = <span class="number">0</span>;\n    }\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; strlen(s); ++i) {\n        <span class="keyword">if</span> (<span class="number">0</span> &lt;= s[i] &amp;&amp; s[i] &lt; <span class="number">256</span>) {\n            <span class="keyword">if</span> (tbl[(int)s[i]] == <span class="number">0</span>) {\n                n++;\n            }\n            tbl[(int)s[i]]++;\n        }\n    }\n    s2 = SafeMalloc(sizeof(char)*(n+<span class="number">1</span>));\n    tbl2 = SafeMalloc(sizeof(int)*(n));\n    n = <span class="number">0</span>;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) {\n        <span class="keyword">if</span> (tbl[i] > <span class="number">0</span>) {\n            s2[n] = (char)i;\n            tbl2[n] = tbl[i];\n            n++;\n        }\n    }\n    s2[n] = <span class="string">\'\\0\'</span>;\n    <span class="keyword">return</span> HuffmanTreeCreateWithFreq(s2,tbl2);\n}\n\nint _CompareFn(<span class="keyword">const</span> void* a, <span class="keyword">const</span> void* b) {\n    <span class="keyword">return</span> ((huffman_tree_node*)a)->key - ((huffman_tree_node*)b)->key;\n}\n\nhuffman_tree* HuffmanTreeCreateWithFreq(char* s, int* tbl) {\n    int i;\n    int n;\n    min_heap* h;\n    huffman_tree* t;\n    huffman_tree_node* node;\n    huffman_tree_node* node1;\n    huffman_tree_node* node2;\n    n = strlen(s);\n    h = MinHeapCreate(n, sizeof(huffman_tree_node), _CompareFn);\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) {\n        node = _NewNode(tbl[i], s[i], <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);\n        MinHeapInsert(h, node);\n    }\n    <span class="keyword">while</span> (h->size > <span class="number">1</span>) {\n        node1 = (huffman_tree_node*)MinHeapPop(h);\n        node2  = (huffman_tree_node*)MinHeapPop(h);\n        node = _NewNode(node1->key + node2->key, node1->val, node1, node2);\n        MinHeapInsert(h, node);\n    }\n    t = (huffman_tree*)SafeMalloc(sizeof(huffman_tree));\n    t->root = (huffman_tree_node*)MinHeapPop(h);\n    t->size = <span class="number">0</span>;\n    t->table = SafeMalloc(sizeof(huffman_tree_item*)*n);\n    _Traverse(t, t->root, <span class="string">""</span>); MinHeapDestroy(h);\n    <span class="keyword">return</span> t;\n}'},61:function(e,t,n){e.exports='<span class="comment">#ifndef HUFFMAN_TREE_H</span>\n<span class="comment">#define HUFFMAN_TREE_H</span>\n\ntypedef struct huffman_tree_node {\n  int key;\n  char val;\n  struct huffman_tree_node* left;\n  struct huffman_tree_node* right;\n} huffman_tree_node;\n\ntypedef struct huffman_tree_item {\n  int key;\n  char val;\n  char* code;\n} huffman_tree_item;\n\ntypedef struct huffman_tree {\n  struct huffman_tree_node* root;\n  struct huffman_tree_item** table;\n  int size;\n} huffman_tree;\n\nhuffman_tree* HuffmanTreeCreate(char *);\nhuffman_tree* HuffmanTreeCreateWithFreq(char *, int *);\n\n<span class="comment">#endif</span>'},62:function(e,t,n){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "./huffman-tree.h"</span>\n\nint main(int argc, char <span class="keyword">const</span> *argv[]) {\n  char *s;\n  size_t buf = <span class="number">0</span>;\n  int tbl[<span class="number">100</span>];\n  int i;\n  int l;\n  int type;\n  huffman_tree* t;\n  printf(<span class="string">"0: full text, 1: text with freq > "</span>);\n  scanf(<span class="string">"%d\\n"</span>, &amp;type);\n  <span class="keyword">if</span> (type) {\n    getline(&amp;s, &amp;buf, stdin);\n    l = strlen(s)-<span class="number">1</span>;\n    s[l--] = <span class="string">\'\\0\'</span>;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; l; ++i) {\n      scanf(<span class="string">"%d"</span>, &amp;tbl[i]);\n    }\n    t = HuffmanTreeCreateWithFreq(s, tbl);\n  } <span class="keyword">else</span> {\n    getline(&amp;s, &amp;buf, stdin);\n    l = strlen(s)-<span class="number">1</span>;\n    s[l--] = <span class="string">\'\\0\'</span>;\n    printf(<span class="string">"%s\\n"</span>,s);\n    t = HuffmanTreeCreate(s);\n  }\n  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; t->size; ++i) {\n    printf(<span class="string">"char %c, freq %d, code %s\\n"</span>, t->table[i]->val, t->table[i]->key, t->table[i]->code);\n  }\n  <span class="keyword">return</span> <span class="number">0</span>;\n};'},63:function(e,t,n){e.exports='<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./min-heap.h"</span>\n<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n\nmin_heap* MinHeapCreate(int n, size_t item_size, int (*CompFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*)) {\n    min_heap* h = (min_heap*)SafeMalloc(sizeof(min_heap));\n    h-><span class="keyword">array</span> = SafeMalloc(item_size*n);\n    h->capacity = n;\n    h->size = <span class="number">0</span>;\n    h->item_size = item_size;\n    h->Compare = CompFn;\n    <span class="keyword">return</span> h;\n}\n\nvoid MinHeapDestroy(min_heap *h) {\n    free(h-><span class="keyword">array</span>);\n    free(h);\n}\n\nint _P(int x) {\n    <span class="keyword">return</span> x == <span class="number">0</span> ? <span class="number">0</span> : (x-<span class="number">1</span>)/<span class="number">2</span>;\n}\nint _L(int x) {\n    <span class="keyword">return</span> x*<span class="number">2</span>+<span class="number">1</span>;\n}\nint _R(int x) {\n    <span class="keyword">return</span> x*<span class="number">2</span>+<span class="number">2</span>;\n}\nvoid _Exchange(min_heap* h, int i, int j) {\n    MemorySwap(\n        MemoryAddress(h-><span class="keyword">array</span>, i, h->item_size),\n        MemoryAddress(h-><span class="keyword">array</span>, j, h->item_size),\n        h->item_size\n    );\n}\n\nvoid MinHeapInsert(min_heap* h, void* item) {\n    int x = h->size;\n    <span class="keyword">if</span> (x == h->capacity) {\n        <span class="keyword">return</span>;\n    }\n    MemoryCopy(MemoryAddress(h-><span class="keyword">array</span>, x, h->item_size), item, h->item_size)\n    h->size++;\n    <span class="keyword">while</span> (x != <span class="number">0</span> &amp;&amp;\n        h->Compare(MemoryAddress(h-><span class="keyword">array</span>, x, h->item_size), MemoryAddress(h-><span class="keyword">array</span>, _P(x), h->item_size)) &lt; <span class="number">0</span>\n    ) {\n        _Exchange(h, x, _P(x));\n        x = _P(x);\n    }\n}\n\nvoid* MinHeapPop(min_heap* h) {\n    int x;\n    int y;\n    void* item = SafeMalloc(h->item_size);\n    <span class="keyword">if</span> (h->size == <span class="number">0</span>) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    MemoryCopy(item, MemoryAddress(h-><span class="keyword">array</span>, <span class="number">0</span>, h->item_size), h->item_size);\n    MemoryCopy(MemoryAddress(h-><span class="keyword">array</span>, <span class="number">0</span>, h->item_size), MemoryAddress(h-><span class="keyword">array</span>, h->size-<span class="number">1</span>, h->item_size),h->item_size);\n    h->size--;\n    x = <span class="number">0</span>;\n    y = -<span class="number">1</span>;\n    <span class="keyword">while</span> (x != y) {\n        y = x;\n        <span class="keyword">if</span> (_L(x) &lt; h->size &amp;&amp;\n            h->Compare(MemoryAddress(h-><span class="keyword">array</span>, _L(x), h->item_size), MemoryAddress(h-><span class="keyword">array</span>, x, h->item_size)) &lt; <span class="number">0</span>\n        ) {\n            y = _L(x);\n        }\n        <span class="keyword">if</span> (_R(x) &lt; h->size &amp;&amp;\n            h->Compare(MemoryAddress(h-><span class="keyword">array</span>, _R(x), h->item_size), MemoryAddress(h-><span class="keyword">array</span>, y, h->item_size)) &lt; <span class="number">0</span>\n        ) {\n            y = _R(x);\n        }\n        <span class="keyword">if</span> (y != x) {\n            _Exchange(h, x, y);\n            x = y;\n            y = -<span class="number">1</span>;\n        }\n    }\n    <span class="keyword">return</span> item;\n}'},64:function(e,t,n){e.exports='<span class="comment">#ifndef MIN_HEAP_H</span>\n<span class="comment">#define MIN_HEAP_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\ntypedef struct min_heap {\n    int size;\n    int capacity;\n    size_t item_size;\n    void* <span class="keyword">array</span>;\n    int (*Compare)(<span class="keyword">const</span> void* a, <span class="keyword">const</span> void* b);\n} min_heap;\n\nmin_heap* MinHeapCreate(int n, size_t item_size, int (*CompFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*));\nvoid MinHeapInsert(min_heap* h, void* item);\nvoid* MinHeapPop(min_heap* h);\nvoid MinHeapDestroy(min_heap* h);\n\n<span class="comment">#endif</span>'},91:function(e,t,n){var r=n(29);"string"==typeof r&&(r=[[e.id,r,""]]);n(9)(r,{})},100:function(e,t,n){function r(e){return e.id}function i(e,t){v=e,x=t}function s(){function e(e){if(void 0===e.paths){e.paths=[],e.ancestors=[];for(var t=e;null!==t.p;)e.paths.push(t.p.id+"-"+t.id),e.ancestors.push(t.p.id),t=t.p}}function t(t,n,r){e(t);var i=t.paths,s=t.ancestors,a=t.id;E.selectAll("line.edge").style("opacity",function(e){return-1===i.indexOf(e.id)?.3:1}),E.selectAll("text.edge").style("opacity",function(e){return-1===i.indexOf(e.id)?.3:1}),E.selectAll("rect.node").style("opacity",function(e){return-1===s.indexOf(e.id)&&e.id!==a?.3:1}),E.selectAll("text.char").style("opacity",function(e){return-1===s.indexOf(e.id)&&e.id!==a?.3:1}).text(function(e){return a===e.id?e.key:e.val})}function n(e){E.selectAll("line.edge").style("opacity",1),E.selectAll("text.edge").style("opacity",1),E.selectAll("rect.node").style("opacity",1),E.selectAll("text.char").style("opacity",1).text(function(e){return e.val})}var i=_.filter(function(e){return e.inner===!0}),s=_.filter(function(e){return e.inner!==!0});d.selectAll("rect.node").data(s,r).enter().append("rect").attr("class","node").attr("x",function(e){return e.x-e.w/2}).attr("y",function(e){return e.inner?e.y-e.h/2:0}).attr("width",function(e){return e.w}).attr("height",0).style("fill",function(e){return M(e.id)}).on("mouseover",t).on("mouseout",n),d.selectAll("rect.node").data(i,r).enter().append("rect").attr("class","node").attr("x",function(e){return e.x-e.w/2}).attr("y",function(e){return e.inner?e.y-e.h/2:0}).attr("width",function(e){return e.w}).attr("height",0).style("fill",function(e){return"black"}),d.selectAll("rect.node").data(_,r).transition().duration(x).attr("x",function(e){return e.x-e.w/2}).attr("y",function(e){return e.inner?e.y-e.h/2:0}).attr("width",function(e){return e.w}).attr("height",function(e){return e.h}).style("opacity",function(e){return e.o?.3:1}),d.selectAll("rect.node").data(_,r).exit().remove(),h.selectAll("text.node").data(_,r).enter().append("text").attr("class","node").attr("x",function(e){return e.tx}).attr("y",function(e){return e.ty-5}),h.selectAll("text.node").data(_,r).transition().duration(x).attr("x",function(e){return e.tx}).attr("y",function(e){return e.ty-5}).text(function(e){return e.top?e.key:""}).style("opacity",function(e){return e.o?.3:1}),h.selectAll("text.node").data(_,r).exit().remove(),h.selectAll("text.char").data(s,r).enter().append("text").attr("class","char").attr("x",function(e){return e.tx}).attr("y",function(e){return e.h>40?e.h-10:e.h+10}).style("fill",function(e){return e.h>40?M(e.id):"black"}),h.selectAll("text.char").data(_,r).transition().duration(x).attr("x",function(e){return e.tx}).attr("y",function(e){return e.h>40?e.h/2+5:e.h+10}).text(function(e){return e.val}).style("opacity",function(e){return e.o?.3:1}),h.selectAll("text.char").data(_,r).exit().remove()}function a(){function e(e){var t=e.x1-e.x2,n=e.y1-e.y2,r=Math.sqrt(t*t+n*n);return r/5+"px"}m.selectAll("line.edge").data(w,r).enter().append("line").attr("class","edge").attr("x1",function(e){return e.x1}).attr("y1",function(e){return e.y1}).attr("x2",function(e){return e.x1}).attr("y2",function(e){return e.y1}).attr("stroke","black").attr("stroke-width",3).attr("stroke-opacity",1),m.selectAll("line.edge").data(w,r).transition().duration(x).attr("x1",function(e){return e.x1}).attr("y1",function(e){return e.y1}).attr("x2",function(e){return e.x2}).attr("y2",function(e){return e.y2}).style("opacity",function(e){return e.o?.3:1}),m.selectAll("line.edge").data(w,r).exit().remove();var t=v.zo?w:[];h.selectAll("text.edge").data(t,r).enter().append("text").attr("class","edge").attr("x",function(e){return(e.x1+e.x1)/2}).attr("y",function(e){return(e.y1+e.y1)/2}).style("fill","black").style("font-size",e).text(function(e){return e.left?"0":"1"}),h.selectAll("text.edge").data(t,r).transition().duration(x).attr("x",function(e){return(e.x1+e.x2)/2}).attr("y",function(e){return(e.y1+e.y2)/2}).text(function(e){return e.t}).style("font-size",e).style("opacity",function(e){return e.o?.3:1}),h.selectAll("text.edge").data(t,r).exit().remove()}function o(e,t){if(1===e.size)return e.x=A(b++)+A.rangeBand()/2,e.y=0,e.w=A.rangeBand(),e.h=D(e.key),e.tx=e.x,e.ty=0,e.inner=!1,e.o=t,_.push(e),[e.x,e.x];var n=o(e.left,t)[0],r=o(e.right,t)[1];return e.w=L,e.h=L,e.x=(n+r)/2,e.y=e.left.y-(e.size-e.left.size)*A.rangeBand()/2,e.tx=e.x,e.ty=e.y,e.inner=!0,e.o=t,_.push(e),w.push({o:t,x1:e.left.x,y1:e.left.y,x2:e.x,y2:e.y,id:e.id+"-"+e.left.id,t:0}),w.push({o:t,x1:e.right.x,y1:e.right.y,x2:e.x,y2:e.y,id:e.id+"-"+e.right.id,t:1}),[n,r]}function c(){v.sorted&&void 0===v.array.sorted&&(v.array.sort(function(e,t){return e.key===t.key?e.id-t.id:e.key-t.key}),v.array.sorted=!0),array=v.pop.concat(v.array),_=[],w=[],A.rangeRoundBands([0,720],.08).domain(E.range(v.n)),D.range([0,400]).domain([0,v.l]),b=0,array.forEach(function(e,t){e.top=!0;var n=!1;v.pop.length===v.hl&&0!==v.hl&&t>=v.hl&&(n=!0),o(e,n)})}function l(e,t){i(e,t),c(),s(),a()}function p(){var e=this,t=E.behavior.zoom().scaleExtent([.1,10]).on("zoom",function(){e.svg.attr("transform",k().translate(E.event.translate).scale(E.event.scale))});this.svg=E.select(this.refs.svg.getDOMNode()).append("svg").call(t).append("g"),this.g=this.svg.append("g").attr("transform",k().translate(100,200).scale(.5)),f=this.g.append("g").attr("class","high"),gtree=this.g.append("g").attr("class","tree"),u=this.g.append("g").attr("class","base"),h=this.g.append("g").attr("class","text"),m=gtree.append("g").attr("class","edges"),d=gtree.append("g").attr("class","nodes"),y=this.g.append("g").attr("class","axis"),g=this.g.append("g").attr("class","axis")}n(91);var u,h,f,d,m,y,g,v,x,_,w,b,E=n(3),k=n(5),A=E.scale.ordinal(),D=E.scale.linear(),M=E.scale.category20(),L=10;e.exports={init:p,render:l}}});