webpackJsonpdsa([4],{1:function(n,e,t){n.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "./util.h"</span>\n\nvoid* SafeMalloc(size_t size) {\n    void* m;\n    <span class="keyword">if</span> ((m = malloc(size))) {\n        <span class="keyword">return</span> m;\n    } <span class="keyword">else</span> {\n        printf(<span class="string">"memory overflow\\n"</span>);\n        <span class="keyword">exit</span>(-<span class="number">1</span>);\n        <span class="keyword">return</span> <span class="number">0</span>;\n    }\n}\n\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">// }</span>\n    memcpy(a, b, size);\n}\n\nvoid MemorySwap(void *a, void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// char t;</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     t = *(char *)a;</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">//     *((char *)b + i) = t;</span>\n    <span class="comment">// }</span>\n    void *t = SafeMalloc(size);\n    memcpy(t, a, size);\n    memcpy(a, b, size);\n    memcpy(b, t, size);\n}\n\nvoid MemoryClear(void *a, size_t size) {\n    memset(a, <span class="number">0</span>, size);\n}\n\nvoid *MemoryAddress(void *a, int i, size_t size) {\n    <span class="keyword">return</span> (char *)a + i*size;\n}'},2:function(n,e,t){n.exports='<span class="comment">#ifndef UTIL_H</span>\n<span class="comment">#define UTIL_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\nvoid * SafeMalloc(size_t size);\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size);\nvoid MemorySwap(void *a, void *b, size_t size);\nvoid MemoryClear(void *a, size_t size);\n\n<span class="comment">#endif</span>'},13:function(n,e,t){n.exports='<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./min-heap.h"</span>\n\nmin_heap* MinHeapCreate(int n, size_t item_size, int (*CompFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*)) {\n    int i;\n    min_heap* h = (min_heap*)SafeMalloc(sizeof(min_heap));\n    h-><span class="keyword">array</span> = SafeMalloc(n * sizeof(min_heap_pair));\n    h->capacity = n;\n    h->size = <span class="number">0</span>;\n    h->item_size = item_size;\n    h->Compare = CompFn;\n    h->map = SafeMalloc(n*sizeof(int));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) {\n        h-><span class="keyword">array</span>[i].item = <span class="keyword">NULL</span>;\n        h->map[i] = -<span class="number">1</span>;\n    }\n    <span class="keyword">return</span> h;\n}\n\nvoid MinHeapDestroy(min_heap *h) {\n    int i;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; h->capacity; ++i) {\n        <span class="keyword">if</span> (h-><span class="keyword">array</span>[i].item != <span class="keyword">NULL</span>) {\n            free(h-><span class="keyword">array</span>[i].item);\n        }\n    }\n    free(h-><span class="keyword">array</span>);\n    free(h->map);\n    free(h);\n}\n\nint _P(int x) {\n    <span class="keyword">return</span> x == <span class="number">0</span> ? <span class="number">0</span> : (x-<span class="number">1</span>)/<span class="number">2</span>;\n}\nint _L(int x) {\n    <span class="keyword">return</span> x*<span class="number">2</span>+<span class="number">1</span>;\n}\nint _R(int x) {\n    <span class="keyword">return</span> x*<span class="number">2</span>+<span class="number">2</span>;\n}\nvoid _Exchange(min_heap* h, int i, int j) {\n    min_heap_pair tmp;\n    tmp = h-><span class="keyword">array</span>[i];\n    h-><span class="keyword">array</span>[i] = h-><span class="keyword">array</span>[j];\n    h-><span class="keyword">array</span>[j] = tmp;\n    h->map[h-><span class="keyword">array</span>[i].key] = i;\n    h->map[h-><span class="keyword">array</span>[j].key] = j;\n}\n\nvoid _Swim(min_heap *h, int x) {\n    <span class="keyword">while</span> (x != <span class="number">0</span> &amp;&amp; h->Compare(h-><span class="keyword">array</span>[x].item, h-><span class="keyword">array</span>[_P(x)].item) &lt; <span class="number">0</span>) {\n        _Exchange(h, x, _P(x));\n        x = _P(x);\n    }\n}\n\nvoid _Sink(min_heap *h, int x) {\n    int y = -<span class="number">1</span>;\n    <span class="keyword">while</span> (x != y) {\n        y = x;\n        <span class="keyword">if</span> (_L(x) &lt; h->size &amp;&amp; h->Compare(h-><span class="keyword">array</span>[_L(x)].item, h-><span class="keyword">array</span>[x].item) &lt; <span class="number">0</span>) {\n            y = _L(x);\n        }\n        <span class="keyword">if</span> (_R(x) &lt; h->size &amp;&amp; h->Compare(h-><span class="keyword">array</span>[_R(x)].item, h-><span class="keyword">array</span>[y].item) &lt; <span class="number">0</span>) {\n            y = _R(x);\n        }\n        <span class="keyword">if</span> (y != x) {\n            _Exchange(h, x, y);\n            x = y;\n            y = -<span class="number">1</span>;\n        }\n    }\n}\n\nvoid MinHeapInsert(min_heap* h, void* item, int id) {\n    int x = h->size;\n    <span class="keyword">if</span> (x == h->capacity) {\n        <span class="keyword">return</span>;\n    }\n    h-><span class="keyword">array</span>[x].key = id;\n    h->map[id] = x;\n    <span class="keyword">if</span> (h-><span class="keyword">array</span>[x].item == <span class="keyword">NULL</span>) {\n        h-><span class="keyword">array</span>[x].item = SafeMalloc(h->item_size);\n    }\n    MemoryCopy(h-><span class="keyword">array</span>[x].item, item, h->item_size);\n    h->size++;\n    _Swim(h, x);\n}\n\nvoid* MinHeapPop(min_heap* h) {\n    void* item = SafeMalloc(h->item_size);\n    <span class="keyword">if</span> (h->size == <span class="number">0</span>) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    MemoryCopy(item, h-><span class="keyword">array</span>[<span class="number">0</span>].item, h->item_size);\n    h->map[h-><span class="keyword">array</span>[<span class="number">0</span>].key] = -<span class="number">1</span>;\n    MemoryCopy(h-><span class="keyword">array</span>[<span class="number">0</span>].item, h-><span class="keyword">array</span>[h->size-<span class="number">1</span>].item, h->item_size);\n    h-><span class="keyword">array</span>[<span class="number">0</span>].key = h-><span class="keyword">array</span>[h->size-<span class="number">1</span>].key;\n    h->map[h-><span class="keyword">array</span>[<span class="number">0</span>].key] = <span class="number">0</span>;\n    free(h-><span class="keyword">array</span>[h->size-<span class="number">1</span>].item);\n    h-><span class="keyword">array</span>[h->size-<span class="number">1</span>].item = <span class="keyword">NULL</span>;\n    h->size--;\n    _Sink(h, <span class="number">0</span>);\n    <span class="keyword">return</span> item;\n}\n\nvoid *MinHeapUpdate(min_heap *h, void *item, int id) {\n    int i;\n    int rc;\n    <span class="keyword">if</span> (id &lt; <span class="number">0</span> || id >= h->capacity) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    i = h->map[id];\n    rc = h->Compare(h-><span class="keyword">array</span>[i].item, item);\n    MemoryCopy(h-><span class="keyword">array</span>[i].item, item, h->item_size);\n    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) {\n        _Sink(h, i);\n        <span class="keyword">return</span> item;\n    } <span class="keyword">else</span> <span class="keyword">if</span> (rc > <span class="number">0</span>) {\n        _Swim(h, i);\n        <span class="keyword">return</span> item;\n    }\n    <span class="keyword">return</span> <span class="keyword">NULL</span>;\n}'},14:function(n,e,t){n.exports='<span class="comment">#ifndef MIN_HEAP_H</span>\n<span class="comment">#define MIN_HEAP_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\ntypedef struct min_heap_pair {\n    void *item;\n    int key;\n} min_heap_pair;\n\ntypedef struct min_heap {\n    int size;\n    int capacity;\n    size_t item_size;\n    min_heap_pair* <span class="keyword">array</span>;\n    int (*Compare)(<span class="keyword">const</span> void* a, <span class="keyword">const</span> void* b);\n    int* map;\n} min_heap;\n\nmin_heap* MinHeapCreate(int n, size_t item_size, int (*CompFn)(<span class="keyword">const</span> void*, <span class="keyword">const</span> void*));\nvoid MinHeapInsert(min_heap* h, void* item, int id);\nvoid* MinHeapPop(min_heap* h);\nvoid MinHeapDestroy(min_heap* h);\nvoid *MinHeapUpdate(min_heap *h, void *item, int id);\n\n<span class="comment">#endif</span>'},20:function(n,e,t){function s(n){this.array=[],this.cf=n,this.map=[]}s.prototype.p=function(n){return 0==n?0:Math.floor((n-1)/2)},s.prototype.l=function(n){return 2*n+1},s.prototype.r=function(n){return 2*n+2},s.prototype.ex=function(n,e){var t=this.array[n];this.array[n]=this.array[e],this.array[e]=t,this.map[this.array[n].k]=n,this.map[this.array[e].k]=e},s.prototype.swim=function(n){for(;0!=n&&this.cf(this.array[n].v,this.array[this.p(n)].v)<0;)this.ex(n,this.p(n)),n=this.p(n)},s.prototype.sink=function(n){for(var e=-1;n!==e;)e=n,void 0!==this.array[this.l(n)]&&this.cf(this.array[this.l(n)].v,this.array[n].v)<0&&(e=this.l(n)),void 0!==this.array[this.r(n)]&&this.cf(this.array[this.r(n)].v,this.array[e].v)<0&&(e=this.r(n)),e!=n&&(this.ex(n,e),n=e,e=-1)},s.prototype.insert=function(n,e){this.array.push({v:n,k:e}),this.map[e]=this.array.length-1,this.swim(this.array.length-1)},s.prototype.pop=function(){if(0!==this.array.length){var n=this.array[0];return this.ex(0,this.array.length-1),this.array.pop(),this.map[n.k]=void 0,this.sink(0),n.v}},s.prototype.update=function(n,e){if(!(0>e||e>=this.array.length)){var t=this.map[e],s=this.cf(this.array[t].v,n);this.array[t].v=n,0>s?this.sink(t):s>0&&this.swim(t)}},s.prototype.forceUpdate=function(n){var e=this.map[n];this.sink(e),this.swim(e)},n.exports=s},28:function(n,e,t){function s(n,e,t,s){var r={id:m++,p:null};return r.key=n,r.val=e,r.left=t,null!==t&&(t.p=r),r.right=s,null!==s&&(s.p=r),a(r),r}function a(n){null===n.left&&null===n.right?n.size=1:(n.size=0,null!==n.left&&(n.size+=n.left.size),null!==n.right&&(n.size+=n.right.size))}function r(n){var e,t,a,r={},i=[];for(f.l=n.length,p(51,1),a=0;a<n.length;++a){var t=n.charCodeAt(a);r[t]=(r[t]||0)+1}p(62,1);for(a in r)r[a]>0&&(e=String.fromCharCode(a),i.push(s(r[a],e,null,null)));return f.array=i,f.n=i.length,p(70,1),o(i)}function i(n,e){return n.key!==e.key?n.key-e.key:n.id-e.id}function o(n){var e,t,a,r,o,l,d;for(t=n.length,p(86,1),a=new g(i),f.sorted=!0,e=0;t>e;++e)a.insert(n[e]);for(c(a);p(91,1),a.array.length>1;)p(92),l=a.pop(),c(a),f.hl=1,f.pop=[l],p(93,1),d=a.pop(),c(a),f.hl=2,f.pop.push(d),p(94,1),o=s(l.key+d.key,"",l,d),f.pop=[o],f.hl=1,p(95,1),a.insert(o),c(a),f.pop=[],f.hl=0;return p(97,1),p(98),p(99),p(100),p(101),f.zo=!0,p(102,1),r}function c(n){f.array=n.array.map(function(n){return n.v})}function p(n,e,t){1===e&&(lastStatus=f.clone()),u.push({status:lastStatus,line:n,animation:t,id:h}),h++}function l(){p(u[u.length-1].line,1)}var d=t(6),u=[],h=0,f={},m=0,g=t(20);f.clone=function(){return{array:d(this.array)||[],pop:d(this.pop)||[],n:this.n||0,l:this.l||0,zo:this.zo||!1,sorted:this.sorted||!1,hl:this.hl||0}},f.init=function(n){this.array=[],this.pop=[],this.n=0,this.l=0,this.zo=!1,this.sorted=!1,this.hl=0},lastStatus={},n.exports={getInitialDescriptions:function(){return this.initialize(!0),this.run("create","The quick brown fox jumps over the lazy dog")},initialize:function(n){return u=[],h=0,m=0,f.init(n),lastStatus=f.clone(),this},create:r,run:function(n,e){return this.initialize()[n](e),l(),{frames:u,others:{}}}}},41:function(n,e,t){e=n.exports=t(8)(),e.push([n.id,".axis text{display:none}",""])},57:function(n,e,t){var s=t(4),a=t(5),r=t(130);n.exports=s.createClass({displayName:"module.exports",getInitialState:function(){return{text:""}},componentDidMount:function(){r.init.bind(this)(),a.runDemo("create","Huffman Tree",!1)},componentDidUpdate:function(n){this.props!==n&&void 0!==this.props.frame&&r.render(this.props.frame.status,this.props.delay,this.props.others)},render:function(){return s.createElement("div",{className:"wrapper-code"},s.createElement("div",{className:"list"},s.createElement("input",{onChange:this._onChange,value:this.state.text,placeholder:"字符串"}),s.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"create"),value:"编码",title:"编码"})),s.createElement("div",{ref:"svg",className:"scene"}))},_onChange:function(n){this.setState({text:n.target.value})},_onClick:function(n){a.runDemo(n,this.state.text)}})},79:function(n,e,t){n.exports="CC=gcc\nCFLAGS=-c -Wall\nLDFLAGS=\nSOURCES=test.c huffman-tree.c huffman-tree.h ../common/util.c ../common/util.h ../min-heap/min-heap.c ../min-heap/min-heap.h\nOBJECTS=$(SOURCES:.c=.o)\nEXECUTABLE=a.out\n\nall: $(SOURCES) $(EXECUTABLE)\n\n$(EXECUTABLE): $(OBJECTS)\n    $(CC) $(LDFLAGS) $(OBJECTS) -o $@\n\n.cpp.o:\n    $(CC) $(CFLAGS) $&lt; -o $@\n\nclean:\n    rm -rf *.o a.out"},80:function(n,e,t){n.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "./huffman-tree.h"</span>\n<span class="comment">#include "../min-heap/min-heap.h"</span>\n<span class="comment">#include "../common/util.h"</span>\n\nhuffman_tree_node* _NewNode(int k, char v, huffman_tree_node* l, huffman_tree_node* r) {\n    huffman_tree_node* node = (huffman_tree_node*)SafeMalloc(sizeof(huffman_tree_node));\n    node->key = k;\n    node->val = v;\n    node->left = l;\n    node->right = r;\n    <span class="keyword">return</span> node;\n}\n\nhuffman_tree_item* _NewItem(int k, char v, char* c) {\n    huffman_tree_item* item = (huffman_tree_item*)SafeMalloc(sizeof(huffman_tree_item));\n    item->key = k;\n    item->val = v;\n    item->code = (char*)SafeMalloc(sizeof(c));\n    strcpy(item->code, c);\n    <span class="keyword">return</span> item;\n}\n\nchar* _Append(char* s, char* t) {\n    char* r = (char*)SafeMalloc(sizeof(s)+sizeof(char));\n    strcpy(r,s);\n    strcat(r,t);\n    <span class="keyword">return</span> r;\n}\n\nvoid _Traverse(huffman_tree* t, huffman_tree_node* x, char* s) {\n    <span class="keyword">if</span> (x->left == <span class="keyword">NULL</span> &amp;&amp; x->right == <span class="keyword">NULL</span>) {\n        t->table[t->size++] = _NewItem(x->key, x->val, s);\n        <span class="keyword">return</span>;\n    }\n    _Traverse(t, x->left, _Append(s,<span class="string">"0"</span>));\n    _Traverse(t, x->right, _Append(s,<span class="string">"1"</span>));\n}\n\nhuffman_tree* HuffmanTreeCreate(char *s) {\n    int tbl[<span class="number">256</span>];\n    int i;\n    int n = <span class="number">0</span>;\n    char* s2 = <span class="keyword">NULL</span>;\n    int* tbl2 = <span class="keyword">NULL</span>;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) {\n        tbl[i] = <span class="number">0</span>;\n    }\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; strlen(s); ++i) {\n        <span class="keyword">if</span> (<span class="number">0</span> &lt;= s[i] &amp;&amp; s[i] &lt; <span class="number">256</span>) {\n            <span class="keyword">if</span> (tbl[(int)s[i]] == <span class="number">0</span>) {\n                n++;\n            }\n            tbl[(int)s[i]]++;\n        }\n    }\n    s2 = SafeMalloc(sizeof(char)*(n+<span class="number">1</span>));\n    tbl2 = SafeMalloc(sizeof(int)*(n));\n    n = <span class="number">0</span>;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) {\n        <span class="keyword">if</span> (tbl[i] > <span class="number">0</span>) {\n            s2[n] = (char)i;\n            tbl2[n] = tbl[i];\n            n++;\n        }\n    }\n    s2[n] = <span class="string">\'\\0\'</span>;\n    <span class="keyword">return</span> HuffmanTreeCreateWithFreq(s2,tbl2);\n}\n\nint _CompareFn(<span class="keyword">const</span> void* a, <span class="keyword">const</span> void* b) {\n    <span class="keyword">return</span> ((huffman_tree_node*)a)->key - ((huffman_tree_node*)b)->key;\n}\n\nhuffman_tree* HuffmanTreeCreateWithFreq(char* s, int* tbl) {\n    int i;\n    int n;\n    min_heap* h;\n    huffman_tree* t;\n    huffman_tree_node* node;\n    huffman_tree_node* node1;\n    huffman_tree_node* node2;\n    n = strlen(s);\n    h = MinHeapCreate(n, sizeof(huffman_tree_node), _CompareFn);\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) {\n        node = _NewNode(tbl[i], s[i], <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);\n        MinHeapInsert(h, node, <span class="number">0</span>);\n    }\n    <span class="keyword">while</span> (h->size > <span class="number">1</span>) {\n        node1 = (huffman_tree_node*)MinHeapPop(h);\n        node2  = (huffman_tree_node*)MinHeapPop(h);\n        node = _NewNode(node1->key + node2->key, node1->val, node1, node2);\n        MinHeapInsert(h, node, <span class="number">0</span>);\n    }\n    t = (huffman_tree*)SafeMalloc(sizeof(huffman_tree));\n    t->root = (huffman_tree_node*)MinHeapPop(h);\n    t->size = <span class="number">0</span>;\n    t->table = SafeMalloc(sizeof(huffman_tree_item*)*n);\n    _Traverse(t, t->root, <span class="string">""</span>); MinHeapDestroy(h);\n    <span class="keyword">return</span> t;\n}'},81:function(n,e,t){n.exports='<span class="comment">#ifndef HUFFMAN_TREE_H</span>\n<span class="comment">#define HUFFMAN_TREE_H</span>\n\ntypedef struct huffman_tree_node {\n  int key;\n  char val;\n  struct huffman_tree_node* left;\n  struct huffman_tree_node* right;\n} huffman_tree_node;\n\ntypedef struct huffman_tree_item {\n  int key;\n  char val;\n  char* code;\n} huffman_tree_item;\n\ntypedef struct huffman_tree {\n  struct huffman_tree_node* root;\n  struct huffman_tree_item** table;\n  int size;\n} huffman_tree;\n\nhuffman_tree* HuffmanTreeCreate(char *);\nhuffman_tree* HuffmanTreeCreateWithFreq(char *, int *);\n\n<span class="comment">#endif</span>'},82:function(n,e,t){n.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "./huffman-tree.h"</span>\n\nint main(int argc, char <span class="keyword">const</span> *argv[]) {\n  char *s;\n  size_t buf = <span class="number">0</span>;\n  int tbl[<span class="number">100</span>];\n  int i;\n  int l;\n  int type;\n  huffman_tree* t;\n  printf(<span class="string">"0: full text, 1: text with freq > "</span>);\n  scanf(<span class="string">"%d\\n"</span>, &amp;type);\n  <span class="keyword">if</span> (type) {\n    getline(&amp;s, &amp;buf, stdin);\n    l = strlen(s)-<span class="number">1</span>;\n    s[l--] = <span class="string">\'\\0\'</span>;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; l; ++i) {\n      scanf(<span class="string">"%d"</span>, &amp;tbl[i]);\n    }\n    t = HuffmanTreeCreateWithFreq(s, tbl);\n  } <span class="keyword">else</span> {\n    getline(&amp;s, &amp;buf, stdin);\n    l = strlen(s)-<span class="number">1</span>;\n    s[l--] = <span class="string">\'\\0\'</span>;\n    printf(<span class="string">"%s\\n"</span>,s);\n    t = HuffmanTreeCreate(s);\n  }\n  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; t->size; ++i) {\n    printf(<span class="string">"char %c, freq %d, code %s\\n"</span>, t->table[i]->val, t->table[i]->key, t->table[i]->code);\n  }\n  <span class="keyword">return</span> <span class="number">0</span>;\n};'},118:function(n,e,t){var s=t(41);"string"==typeof s&&(s=[[n.id,s,""]]);t(9)(s,{})},130:function(n,e,t){function s(n){return n.id}function a(n,e){v=n,w=e}function r(){function n(n){if(void 0===n.paths){n.paths=[],n.ancestors=[];for(var e=n;null!==e.p;)n.paths.push(e.p.id+"-"+e.id),n.ancestors.push(e.p.id),e=e.p}}function e(e,t,s){n(e);var a=e.paths,r=e.ancestors,i=e.id;b.selectAll("line.edge").style("opacity",function(n){return-1===a.indexOf(n.id)?.3:1}),b.selectAll("text.edge").style("opacity",function(n){return-1===a.indexOf(n.id)?.3:1}),b.selectAll("rect.node").style("opacity",function(n){return-1===r.indexOf(n.id)&&n.id!==i?.3:1}),b.selectAll("text.char").style("opacity",function(n){return-1===r.indexOf(n.id)&&n.id!==i?.3:1}).text(function(n){return i===n.id?n.key:n.val})}function t(n){b.selectAll("line.edge").style("opacity",1),b.selectAll("text.edge").style("opacity",1),b.selectAll("rect.node").style("opacity",1),b.selectAll("text.char").style("opacity",1).text(function(n){return n.val})}var a=k.filter(function(n){return n.inner===!0}),r=k.filter(function(n){return n.inner!==!0});f.selectAll("rect.node").data(r,s).enter().append("rect").attr("class","node").attr("x",function(n){return n.x-n.w/2}).attr("y",function(n){return n.inner?n.y-n.h/2:0}).attr("width",function(n){return n.w}).attr("height",0).style("fill",function(n){return z(n.id)}).on("mouseover",e).on("mouseout",t),f.selectAll("rect.node").data(a,s).enter().append("rect").attr("class","node").attr("x",function(n){return n.x-n.w/2}).attr("y",function(n){return n.inner?n.y-n.h/2:0}).attr("width",function(n){return n.w}).attr("height",0).style("fill",function(n){return"black"}),f.selectAll("rect.node").data(k,s).transition().duration(w).attr("x",function(n){return n.x-n.w/2}).attr("y",function(n){return n.inner?n.y-n.h/2:0}).attr("width",function(n){return n.w}).attr("height",function(n){return n.h}).style("opacity",function(n){return n.o?.3:1}),f.selectAll("rect.node").data(k,s).exit().remove(),u.selectAll("text.node").data(k,s).enter().append("text").attr("class","node").attr("x",function(n){return n.tx}).attr("y",function(n){return n.ty-5}),u.selectAll("text.node").data(k,s).transition().duration(w).attr("x",function(n){return n.tx}).attr("y",function(n){return n.ty-5}).text(function(n){return n.top?n.key:""}).style("opacity",function(n){return n.o?.3:1}),u.selectAll("text.node").data(k,s).exit().remove(),u.selectAll("text.char").data(r,s).enter().append("text").attr("class","char").attr("x",function(n){return n.tx}).attr("y",function(n){return n.h>40?n.h-10:n.h+10}).style("fill",function(n){return n.h>40?z(n.id):"black"}),u.selectAll("text.char").data(k,s).transition().duration(w).attr("x",function(n){return n.tx}).attr("y",function(n){return n.h>40?n.h/2+5:n.h+10}).text(function(n){return n.val}).style("opacity",function(n){return n.o?.3:1}),u.selectAll("text.char").data(k,s).exit().remove()}function i(){function n(n){var e=n.x1-n.x2,t=n.y1-n.y2,s=Math.sqrt(e*e+t*t);return s/5+"px"}m.selectAll("line.edge").data(x,s).enter().append("line").attr("class","edge").attr("x1",function(n){return n.x1}).attr("y1",function(n){return n.y1}).attr("x2",function(n){return n.x1}).attr("y2",function(n){return n.y1}).attr("stroke","black").attr("stroke-width",3).attr("stroke-opacity",1),m.selectAll("line.edge").data(x,s).transition().duration(w).attr("x1",function(n){return n.x1}).attr("y1",function(n){return n.y1}).attr("x2",function(n){return n.x2}).attr("y2",function(n){return n.y2}).style("opacity",function(n){return n.o?.3:1}),m.selectAll("line.edge").data(x,s).exit().remove();var e=v.zo?x:[];u.selectAll("text.edge").data(e,s).enter().append("text").attr("class","edge").attr("x",function(n){return(n.x1+n.x1)/2}).attr("y",function(n){return(n.y1+n.y1)/2}).style("fill","black").style("font-size",n).text(function(n){return n.left?"0":"1"}),u.selectAll("text.edge").data(e,s).transition().duration(w).attr("x",function(n){return(n.x1+n.x2)/2}).attr("y",function(n){return(n.y1+n.y2)/2}).text(function(n){return n.t}).style("font-size",n).style("opacity",function(n){return n.o?.3:1}),u.selectAll("text.edge").data(e,s).exit().remove()}function o(n,e){if(1===n.size)return n.x=L(_++)+L.rangeBand()/2,n.y=0,n.w=L.rangeBand(),n.h=S(n.key),n.tx=n.x,n.ty=0,n.inner=!1,n.o=e,k.push(n),[n.x,n.x];var t=o(n.left,e)[0],s=o(n.right,e)[1];return n.w=A,n.h=A,n.x=(t+s)/2,n.y=n.left.y-(n.size-n.left.size)*L.rangeBand()/2,n.tx=n.x,n.ty=n.y,n.inner=!0,n.o=e,k.push(n),x.push({o:e,x1:n.left.x,y1:n.left.y,x2:n.x,y2:n.y,id:n.id+"-"+n.left.id,t:0}),x.push({o:e,x1:n.right.x,y1:n.right.y,x2:n.x,y2:n.y,id:n.id+"-"+n.right.id,t:1}),[t,s]}function c(){v.sorted&&void 0===v.array.sorted&&(v.array.sort(function(n,e){return n.key===e.key?n.id-e.id:n.key-e.key}),v.array.sorted=!0),array=v.pop.concat(v.array),k=[],x=[],L.rangeRoundBands([0,720],.08).domain(b.range(v.n)),S.range([0,400]).domain([0,v.l]),_=0,array.forEach(function(n,e){n.top=!0;var t=!1;v.pop.length===v.hl&&0!==v.hl&&e>=v.hl&&(t=!0),o(n,t)})}function p(n,e){a(n,e),c(),r(),i()}function l(){var n=this,e=b.behavior.zoom().scaleExtent([.1,10]).on("zoom",function(){n.svg.attr("transform",E().translate(b.event.translate).scale(b.event.scale))});this.svg=b.select(this.refs.svg.getDOMNode()).append("svg").call(e).append("g"),this.g=this.svg.append("g").attr("transform",E().translate(100,200).scale(.5)),h=this.g.append("g").attr("class","high"),gtree=this.g.append("g").attr("class","tree"),d=this.g.append("g").attr("class","base"),u=this.g.append("g").attr("class","text"),m=gtree.append("g").attr("class","edges"),f=gtree.append("g").attr("class","nodes"),g=this.g.append("g").attr("class","axis"),y=this.g.append("g").attr("class","axis")}t(118);var d,u,h,f,m,g,y,v,w,k,x,_,b=t(3),E=t(7),L=b.scale.ordinal(),S=b.scale.linear(),z=b.scale.category20(),A=10;n.exports={init:l,render:p}}});