webpackJsonpdsa([10],{2:function(e,n,t){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "./util.h"</span>\n\nvoid* SafeMalloc(size_t size) {\n    void* m;\n    <span class="keyword">if</span> ((m = malloc(size))) {\n        <span class="keyword">return</span> m;\n    } <span class="keyword">else</span> {\n        printf(<span class="string">"memory overflow\\n"</span>);\n        <span class="keyword">exit</span>(-<span class="number">1</span>);\n        <span class="keyword">return</span> <span class="number">0</span>;\n    }\n}\n\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">// }</span>\n    memcpy(a, b, size);\n}\n\nvoid MemorySwap(void *a, void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// char t;</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     t = *(char *)a;</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">//     *((char *)b + i) = t;</span>\n    <span class="comment">// }</span>\n    void *t = SafeMalloc(size);\n    memcpy(t, a, size);\n    memcpy(a, b, size);\n    memcpy(b, t, size);\n}\n\nvoid MemoryClear(void *a, size_t size) {\n    memset(a, <span class="number">0</span>, size);\n}\n\nvoid *MemoryAddress(void *a, int i, size_t size) {\n    <span class="keyword">return</span> (char *)a + i*size;\n}'},3:function(e,n,t){e.exports='<span class="comment">#ifndef UTIL_H</span>\n<span class="comment">#define UTIL_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\nvoid * SafeMalloc(size_t size);\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size);\nvoid MemorySwap(void *a, void *b, size_t size);\nvoid MemoryClear(void *a, size_t size);\n\n<span class="comment">#endif</span>'},33:function(e,n,a){function s(){return{id:q++,nil:!0,key:"nil",color:B}}function r(e){b(),w(e),k(e,"left");var n;M(23,1),n=e.right,b(n,e),M(24,1),e.right=n.left,z(e,"right"),b(e,n.left),M(25,1),n.left.nil!==!0&&(M(26,1),n.left.p=e,z(n.left,"p"),b(n.left,e)),M(28,1),n.p=e.p,z(n,"p"),b(n,e.p),M(29,1),e.p.nil?(M(30,1),O.root=n,b(n)):(M(31,1),e===e.p.left?(M(32,1),e.p.left=n,z(e.p,"left")):(M(34,1),e.p.right=n,z(e.p,"right"))),M(36,1),n.left=e,z(n,"left"),b(n,e),M(37,1),e.p=n,z(e,"p"),b(e,n),M(37,1),b(),_(),L(),k()}function i(e){b(),w(e),k(e,"right");var n;M(42,1),n=e.left,b(n,e),M(43,1),e.left=n.right,z(e,"left"),b(e,n.right),M(44,1),n.right.nil!==!0&&(M(45,1),n.right.p=e,z(n.right,"p"),b(n.right,e)),M(47,1),n.p=e.p,z(n,"p"),b(n,e.p),M(48,1),e.p.nil?(M(49,1),O.root=n,b(n)):(M(50,1),e===e.p.right?(M(51,1),e.p.right=n,z(e.p,"right")):(M(53,1),e.p.left=n,z(e.p,"left"))),M(55,1),n.right=e,z(n,"right"),b(n,e),M(56,1),e.p=n,z(e,"p"),b(e,n),M(56,1),b(),_(),L(),k()}function o(e){for(var n;M(61,1),_(e),b(e,e.p),e.p.color===R;)M(62,1),_(e.p.p),e.p===e.p.p.left?(M(63,1),n=e.p.p.right,M(64,1),b(n),n.color===R?(M(65,1),e.p.color=B,x(e.p),b(n,e.p),M(66,1),n.color=B,x(n),M(67,1),e.p.p.color=R,x(e.p.p),b(n,e.p,e.p.p),M(68,1),e=e.p.p,b(e)):(M(70,1),b(e.p,e),e===e.p.right&&(M(71,1),e=e.p,b(e),M(72,1),r(e)),M(74,1),e.p.color=B,x(e.p),b(e.p),M(75,1),e.p.p.color=R,x(e.p.p),b(e.p.p),M(76,1),i(e.p.p))):(M(79,1),n=e.p.p.left,M(80,1),b(n),n.color===R?(M(81,1),e.p.color=B,x(e.p),b(n,e.p),M(82,1),n.color=B,x(n),M(83,1),e.p.p.color=R,x(e.p.p),b(n,e.p,e.p.p),M(84,1),e=e.p.p,b(e)):(M(86,1),b(e.p,e),e===e.p.left&&(M(87,1),e=e.p,b(e),M(88,1),i(e),b(),_(),L()),M(90,1),e.p.color=B,x(e.p),b(e.p),M(91,1),e.p.p.color=R,x(e.p.p),b(e.p.p),M(92,1),r(e.p.p),b(),_(),L()));M(96,1),O.root.color=B,L(),b(),_()}function c(e){var n,t;for(M(102),t=O.nil,M(103),n=O.root;M(104,1),_(n),n.nil!==!0;)M(105,1),t=n,M(106),e.key<n.key?(M(107,1),n=n.left,C(e,n)):(M(109,1),n=n.right,C(e,n));_(t),M(112,1),e.p=t,z(e,"p"),M(113,1),t===O.nil?(M(114,1),O.root=e):(M(115,1),e.key<t.key?(M(116,1),t.left=e,z(t,"left")):(M(118,1),t.right=e,z(t,"right"))),_(e),M(120,1),e.left=s(),L(),z(e,"left"),M(121,1),e.right=s(),L(),z(e,"right"),M(122,1),e.color=R,x(e),z(),M(123,1),o(e)}function l(e){var n={};M(128),n.id=q++,M(129),n.key=e,C(n,O.root),M(130,1),c(n)}function p(e,n){w(n),M(134,1),e.p.nil?(M(135,1),O.root=n):(M(136,1),e===e.p.left?(M(137,1),e.p.left=n,z(e.p,"left"),b(e.p,n)):(M(139,1),e.p.right=n,z(e.p,"right"),b(e.p,n))),M(141,1),n.p=e.p,z(n,"p"),b(n,e.p),S(n,e),M(141,1),_(),b()}function d(e,n){b(e);for(var a,s;M(147,1),b(e),e!==O.root&&e.color===B;)M(148,1),e===e.p.left?(M(149,1),s=e.p.right,M(150,1),b(e,s),s.color===R&&(M(151,1),s.color=B,x(s),b(e,s),M(152,1),e.p.color=R,x(e.p),E(e,s,e.p),M(153,1),r(e.p),b(e),C(n,e),M(154,1),s=e.p.right),M(156,1),b(e,s.left,s.right),s.left.color===B&&s.right.color===B?(M(157,1),s.color=R,x(s),E(s),M(158,1),e=e.p,b(e),C(n,e)):(M(160,1),b(e,s.right),s.right.color===B&&(M(161,1),s.left.color=B,x(s.left),E(s.left),M(162,1),s.color=R,x(s),E(s),M(163,1),i(s),b(e),C(n,e),M(164,1),s=e.p.right),M(166,1),a=e.p.color,C(n,e.p),E(e.p),M(167,1),e.p.color=B,x(e.p),n.color=a,C(n,e.p),M(168,1),s.color=a,x(s),E(s),n.color=B,C(n,s),M(169,1),s.right.color=B,x(s.right),E(s.right),n.color=R,C(n,s.right),M(170,1),r(e.p),b(s.right),C(n,s.right),M(171,1),e=O.root,b(e))):(M(174,1),s=e.p.left,M(175,1),b(e,s),s.color===R&&(M(176,1),s.color=B,x(s),b(e,s),M(177,1),e.p.color=R,x(e.p),E(e,s,e.p),M(178,1),i(e.p),b(e),C(n,e),M(179,1),s=e.p.left),M(181,1),b(e,s.left,s.right),s.right.color===B&&s.left.color===B?(M(182,1),s.color=R,x(s),E(s),M(183,1),e=e.p,b(e),C(n,e)):(M(185,1),b(e,s.left),s.left.color===B&&(M(186,1),s.right.color=B,x(s.right),E(s.right),M(187,1),s.color=R,x(s),E(s),M(188,1),r(t,s),b(e),C(n,e),M(189,1),s=e.p.left),M(191,1),a=e.p.color,E(e.p),M(192,1),e.p.color=B,x(e.p),n.color=a,C(n,e.p),M(193,1),s.color=a,x(s),E(s),n.color=B,C(n,s),M(194,1),s.left.color=B,x(s.left),E(s.left),E(s.left),n.color=R,C(n,s.left),M(195,1),i(e.p),b(s.right),C(n,s.right),M(196,1),e=O.root,b(e)));M(200,1),e.color=B,x(e),C()}function u(e,n){var t={id:n,key:"min"};for(C(t,e),b(e);M(204,1),E(e.left),e.left.nil!==!0;)M(205,1),e=e.left,b(e),C(t,e);return M(207,1),b(e),e}function m(e){_(e),b(e);var n,t,a,s={id:q++,extra:!0,key:""};M(214,1),t=e,C(s,e),M(215,1),a=t.color,s.color=t.color,C(s,e),M(216,1),b(e,e.left),e.left.nil?(M(217,1),n=e.right,b(e),M(218,1),p(e,e.right),L()):(M(219,1),b(e,e.right),e.right.nil?(M(220,1),n=e.left,b(e),M(221,1),p(e,e.left),L()):(b(e),M(223,1),t=u(e.right,s.id),delete s.color,C(s,t),b(t),M(224,1),a=t.color,s.color=t.color,C(s,t),M(225,1),n=t.right,M(226,1),t.p===e?(M(227,1),n.p=t,z(n,"p"),E(n)):(M(229,1),p(t,t.right),b(t),M(230,1),t.right=e.right,z(t,"right"),b(t,e.right),S(t,e),M(231,1),t.right.p=t,z(t.right,"p")),M(233,1),p(e,t),b(t),M(234,1),t.left=e.left,z(t,"left"),b(t,e.left),M(235,1),t.left.p=t,z(t.left,"p"),b(t.left,t),M(236,1),t.color=e.color,x(t),L())),C(s,n),_(),b(),M(238,1),b(s),a===B&&(M(239,1),d(n,s)),M(240,1),C(),b(),_()}function h(e,n){var t={id:q++,key:n};for(C(t,O.root);M(244,1),_(e),e.nil!==!0&&n!==e.key;)M(245,1),n<e.key?(M(246,1),e=e.left,C(t,e)):(M(248,1),e=e.right,C(t,e));return _(),b(e),M(251,1),C(),e}function f(e){M(255,1),D=h(O.root,e),M(256,1),C({id:q,key:D.nil!==!0?e:"X"},D)}function g(e){M(259,1);var n=h(O.root,e);M(260,1),n.nil!==!0&&(M(261,1),m(n)),b(),_()}function y(e,n){n.key="递归",C(n,e),M(266,1),e.nil!==!0&&(M(267,1),y(e.left,n),n.key="回溯",C(n,e),M(268,1),E(e),M(269,1),y(e.right,n),n.key="回溯",C(n,e),M(270,1)),M(271,1)}function v(){var e={id:q++,key:"指针"};b(e),M(274,1),y(O.root,e),M(275,1),e.key="完成",C(e,O.root)}function k(e,n){if(void 0===e)U.ro=void 0;else{var t="left"===n?"right":"left",a=[e.id,e[t].id,e[t][t].id,e[t][n].id,e[n].id];U.ro={ids:a,type:n}}}function x(e){void 0===e?U.co={}:(U.co=U.co||{},U.co[e.id]=e.color)}function w(e){U.hls.push(e.id)}function _(e){U.hls.pop(),void 0!==e&&w(e)}function b(){0===arguments.length?U.hl=[]:U.hl=Array.prototype.map.call(arguments,function(e){return e.id})}function E(e){U.hl.push(e.id)}function z(e,n){if(void 0===e)U.ne={};else{var t=e.id+n;U.ne=U.ne||{},U.ne[t]=e[n].id,U.ne.curr=t}}function S(e,n){void 0===e?U.np={}:(U.np=U.np||{},U.np[e.id]=n.id)}function C(e,n){0===arguments.length?U.nn=void 0:U.nn={id:e.id,key:e.key,color:e.color,ref:n.id,extra:e.extra}}function L(){x(),z(),S(),C(),U.lastTree=T(O)}function A(){}function M(e,n,t){1===n&&(lastStatus=U.clone()),I.push({status:lastStatus,line:e,animation:t,id:P}),P++}function N(){M(I[I.length-1].line,1)}var D,T=a(6),I=[],P=0,U={},q=0,R=1,B=0,O={nil:s()};O.root=O.nil,U.clone=function(){return void 0===this.lastTree&&(this.lastTree=T(O)),{tree:this.lastTree,hl:T(this.hl)||[],hls:T(this.hls)||[],ne:T(this.ne)||{},np:T(this.np)||{},nn:T(this.nn),co:T(this.co)||{},ro:T(this.ro)||void 0}},U.init=function(e){e&&(O.root=O.nil),this.hl=[],this.hls=[],this.ne={},this.np={},this.nn=void 0,this.co={},this.ro=void 0},lastStatus={},e.exports={getInitialDescriptions:function(){return this.initialize(!0),l(10),l(1),l(2),l(3),l(4),l(5),this.run("insert","6")},initialize:function(e){return I=[],P=0,U.init(e),lastStatus=U.clone(),this},insert:l,inorder:v,"delete":g,search:f,check:A,run:function(e,n){return this.initialize()[e](isNaN(parseInt(n))?0:parseInt(n)),N(),{frames:I,others:{}}}}},69:function(e,n,t){var a=t(1);e.exports=a.createClass({displayName:"module.exports",render:function(){var e={display:this.props.show?"block":"none"};return a.createElement("svg",{className:"legend",width:"210",height:"210",style:e},a.createElement("rect",{className:"outline",stroke:"black",x:"0",y:"0",width:"200",height:"190"}),a.createElement("g",{transform:"translate(15,20)"},a.createElement("g",{transform:"translate(0,0)"},a.createElement("g",{transform:"scale(0.5)"},a.createElement("path",{d:"M0,0L50,0",className:"edge painter-selected",markerEnd:"url(#arrow-end)"}))),a.createElement("g",{transform:"translate(0,25)"},a.createElement("g",{transform:"scale(0.5)"},a.createElement("path",{d:"M0,0L50,0",className:"ine"}))),a.createElement("g",{transform:"translate(6,50)"},a.createElement("circle",{cx:"0",cy:"0",r:"6",className:"node highlighted"})),a.createElement("g",{transform:"translate(6,75)"},a.createElement("circle",{cx:"0",cy:"0",r:"6",className:"node visited"})),a.createElement("g",{transform:"translate(6,100)"},a.createElement("circle",{r:"6",className:"node"}),a.createElement("path",{d:"M0,0L0,-6A6,6 0 0,1 5.19,3Z",className:"inq"})),a.createElement("g",{transform:"translate(6,125)"},a.createElement("circle",{r:"6",className:"node"}),a.createElement("text",{x:"2",y:"-2",fontSize:"10px"},"[a]")),a.createElement("g",{transform:"translate(6,150)"},a.createElement("circle",{r:"6",className:"node"}),a.createElement("text",{x:"2",y:"-2",fontSize:"10px"},"(a,b)")),a.createElement("g",{transform:"translate(0,5)"},a.createElement("text",{x:"40",y:"0"},"当前边"),a.createElement("text",{x:"40",y:"25"},"遍历边"),a.createElement("text",{x:"40",y:"50"},"当前结点"),a.createElement("text",{x:"40",y:"75"},"已访问的结点"),a.createElement("text",{x:"40",y:"100"},"访问中的结点"),a.createElement("text",{x:"40",y:"125"},"结点拓扑序号"),a.createElement("text",{x:"40",y:"150"},"时间戳和最远结点"))))}})},70:function(e,n,t){var a=t(1),s=t(5),r=t(149),i=t(69);e.exports=a.createClass({displayName:"module.exports",getInitialState:function(){return{text:"",demo:"insert",help:!0}},componentDidMount:function(){r.init.bind(this)(),s.runDemo("insert",10),s.runDemo("insert",1),s.runDemo("insert",2),s.runDemo("insert",3),s.runDemo("insert",4),s.runDemo("insert",5,!1)},componentDidUpdate:function(e){this.props!==e&&void 0!==this.props.frame&&r.render(this.props.frame.status,this.props.delay,this.props.others)},render:function(){var e=[{button:{demo:"search",onClick:this._onClick.bind(this,"search"),value:"查找"},items:[{onChange:this._onChange,value:this.state.text,placeholder:"数字"}]},{button:{demo:"insert",onClick:this._onClick.bind(this,"insert"),value:"插入"},items:[{onChange:this._onChange,value:this.state.text,placeholder:"数字"}]},{button:{demo:"delete",onClick:this._onClick.bind(this,"delete"),value:"删除"},items:[{onChange:this._onChange,value:this.state.text,placeholder:"数字"}]},{button:{demo:"inorder",onClick:this._onClick.bind(this,"inorder"),value:"中序遍历"}},{button:{help:this.state.help,onClick:this._onHelp,value:"帮助"}}],n=this;return a.createElement("div",{className:"wrapper-code"},a.createElement("div",{className:"list"},e.map(function(e,t){var s="input-group"+(e.button.help||e.button.demo===n.state.demo?" input-current":""),r=e.items?e.items:[];return a.createElement("div",{key:t,className:s},a.createElement("input",{className:"input-button",readOnly:!0,onClick:e.button.onClick,value:e.button.value,title:e.button.value}),a.createElement("div",null,r.map(function(e,n){return a.createElement("input",{key:n,className:"input-item",onChange:e.onChange,value:e.value,title:e.value,placeholder:e.placeholder})})))})),a.createElement("div",{ref:"svg",className:"scene"}),a.createElement(i,{show:this.state.help}))},_onChange:function(e){this.setState({text:e.target.value})},_onClick:function(e){this.setState({demo:e}),s.runDemo(e,this.state.text)},_onHelp:function(){this.setState({help:!this.state.help})}})},107:function(e,n,t){e.exports="CC=gcc\nCFLAGS=-c -Wall\nLDFLAGS=\nSOURCES=test.c rb-tree.c rb-tree.h ../common/util.c ../common/util.h\nOBJECTS=$(SOURCES:.c=.o)\nEXECUTABLE=a.out\n\nall: $(SOURCES) $(EXECUTABLE)\n\n$(EXECUTABLE): $(OBJECTS)\n    $(CC) $(LDFLAGS) $(OBJECTS) -o $@\n\n.cpp.o:\n    $(CC) $(CFLAGS) $&lt; -o $@\n\nclean:\n    rm -rf *.o a.out"},108:function(e,n,t){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "./rb-tree.h"</span>\n<span class="comment">#include "../common/util.h"</span>\n\nint _RED = <span class="number">1</span>;\nint _BLACK = <span class="number">0</span>;\n\nrb_tree * RBTreeCreate() {\n    rb_tree* newTree;\n    rb_tree_node* newNode;\n    newTree = (rb_tree*) SafeMalloc(sizeof(rb_tree));\n    newTree->nil = newNode = (rb_tree_node*) SafeMalloc(sizeof(rb_tree_node));\n    newNode->left = newNode->right = newNode->p = newNode;\n    newNode->key = <span class="number">0</span>;\n    newNode->color = _BLACK;\n    newTree->root = newTree->nil;\n    <span class="keyword">return</span> newTree;\n}\n\nvoid _LeftRotate(rb_tree* t, rb_tree_node* x) {\n    rb_tree_node* y;\n    y = x->right;\n    x->right = y->left;\n    <span class="keyword">if</span> (y->left != t->nil) {\n        y->left->p = x;\n    }\n    y->p = x->p;\n    <span class="keyword">if</span> (x->p == t->nil) {\n        t->root = y;\n    } <span class="keyword">else</span> <span class="keyword">if</span> (x == x->p->left) {\n        x->p->left = y;\n    } <span class="keyword">else</span> {\n        x->p->right = y;\n    }\n    y->left = x;\n    x->p = y;\n}\n\nvoid _RightRotate(rb_tree* t, rb_tree_node* y) {\n    rb_tree_node* x;\n    x = y->left;\n    y->left = x->right;\n    <span class="keyword">if</span> (x->right != t->nil) {\n        x->right->p = y;\n    }\n    x->p = y->p;\n    <span class="keyword">if</span> (y->p == t->nil) {\n        t->root = x;\n    } <span class="keyword">else</span> <span class="keyword">if</span> (y == y->p->right) {\n        y->p->right = x;\n    } <span class="keyword">else</span> {\n        y->p->left = x;\n    }\n    x->right = y;\n    y->p = x;\n}\n\nvoid _InsertFixUp(rb_tree* t, rb_tree_node *z) {\n    rb_tree_node *y;\n    <span class="keyword">while</span> (z->p->color == _RED) {\n        <span class="keyword">if</span> (z->p == z->p->p->left) {\n            y = z->p->p->right;\n            <span class="keyword">if</span> (y->color == _RED) {\n                z->p->color = _BLACK;\n                y->color = _BLACK;\n                z->p->p->color = _RED;\n                z = z->p->p;\n            } <span class="keyword">else</span> {\n                <span class="keyword">if</span> (z == z->p->right) {\n                    z= z->p;\n                    _LeftRotate(t, z);\n                }\n                z->p->color = _BLACK;\n                z->p->p->color = _RED;\n                _RightRotate(t, z->p->p);\n            }\n        } <span class="keyword">else</span> {\n            y = z->p->p->left;\n            <span class="keyword">if</span> (y->color == _RED) {\n                z->p->color = _BLACK;\n                y->color = _BLACK;\n                z->p->p->color = _RED;\n                z = z->p->p;\n            } <span class="keyword">else</span> {\n                <span class="keyword">if</span> (z == z->p->left) {\n                    z= z->p;\n                    _RightRotate(t, z);\n                }\n                z->p->color = _BLACK;\n                z->p->p->color = _RED;\n                _LeftRotate(t, z->p->p);\n            }\n        }\n    }\n    t->root->color = _BLACK;\n}\n\nvoid _Insert(rb_tree* t, rb_tree_node* z) {\n    rb_tree_node* x;\n    rb_tree_node* y;\n    y = t->nil;\n    x = t->root;\n    <span class="keyword">while</span> (x != t->nil) {\n        y = x;\n        <span class="keyword">if</span> (z->key &lt; x->key) {\n            x = x->left;\n        } <span class="keyword">else</span> {\n            x = x->right;\n        }\n    }\n    z->p = y;\n    <span class="keyword">if</span> (y == t->nil) {\n        t->root = z;\n    } <span class="keyword">else</span> <span class="keyword">if</span> (z->key &lt; y->key) {\n        y->left = z;\n    } <span class="keyword">else</span> {\n        y->right = z;\n    }\n    z->left = t->nil;\n    z->right = t->nil;\n    z->color = _RED;\n    _InsertFixUp(t, z);\n}\n\nvoid RBTreeInsert(rb_tree* t, int key) {\n    rb_tree_node* newNode;\n    newNode = (rb_tree_node*) SafeMalloc(sizeof(rb_tree_node));\n    newNode->key = key;\n    _Insert(t, newNode);\n}\n\nvoid _Transplant(rb_tree* t, rb_tree_node* u, rb_tree_node* v) {\n    <span class="keyword">if</span> (u->p == t->nil) {\n        t->root = v;\n    } <span class="keyword">else</span> <span class="keyword">if</span> (u == u->p->left) {\n        u->p->left = v;\n    } <span class="keyword">else</span> {\n        u->p->right = v;\n    }\n    v->p = u->p;\n}\n\nvoid _DeleteFixUp(rb_tree* t, rb_tree_node* x) {\n    int tmp;\n    rb_tree_node* w;\n    <span class="keyword">while</span> (x != t->root &amp;&amp; x->color == _BLACK) {\n        <span class="keyword">if</span> (x == x->p->left) {\n            w = x->p->right;\n            <span class="keyword">if</span> (w->color == _RED) {\n                w->color = _BLACK;\n                x->p->color = _RED;\n                _LeftRotate(t, x->p);\n                w = x->p->right;\n            }\n            <span class="keyword">if</span> (w->left->color == _BLACK &amp;&amp; w->right->color == _BLACK) {\n                w->color = _RED;\n                x = x->p;\n            } <span class="keyword">else</span> {\n                <span class="keyword">if</span> (w->right->color == _BLACK) {\n                    w->left->color = _BLACK;\n                    w->color = _RED;\n                    _RightRotate(t, w);\n                    w = x->p->right;\n                }\n                tmp = x->p->color;\n                x->p->color = _BLACK;\n                w->color = tmp;\n                w->right->color = _BLACK;\n                _LeftRotate(t, x->p);\n                x = t->root;\n            }\n        } <span class="keyword">else</span> {\n            w = x->p->left;\n            <span class="keyword">if</span> (w->color == _RED) {\n                w->color = _BLACK;\n                x->p->color = _RED;\n                _RightRotate(t, x->p);\n                w = x->p->left;\n            }\n            <span class="keyword">if</span> (w->right->color == _BLACK &amp;&amp; w->left->color == _BLACK) {\n                w->color = _RED;\n                x = x->p;\n            } <span class="keyword">else</span> {\n                <span class="keyword">if</span> (w->left->color == _BLACK) {\n                    w->right->color = _BLACK;\n                    w->color = _RED;\n                    _LeftRotate(t,w);\n                    w = x->p->left;\n                }\n                tmp = x->p->color;\n                x->p->color = _BLACK;\n                w->color = tmp;\n                w->left->color = _BLACK;\n                _RightRotate(t, x->p);\n                x = t->root;\n            }\n        }\n    }\n    x->color =_BLACK;\n}\n\nrb_tree_node* _Minimum(rb_tree* t, rb_tree_node *z) {\n    <span class="keyword">while</span> (z->left != t->nil) {\n        z = z->left;\n    }\n    <span class="keyword">return</span> z;\n}\n\nvoid _Delete(rb_tree* t, rb_tree_node *z) {\n    rb_tree_node* x;\n    rb_tree_node* y;\n    int y_original_color;\n    y = z;\n    y_original_color = y->color;\n    <span class="keyword">if</span> (z->left == t->nil) {\n        x = z->right;\n        _Transplant(t, z, z->right);\n    } <span class="keyword">else</span> <span class="keyword">if</span> (z->right == t->nil) {\n        x = z->left;\n        _Transplant(t, z, z->left);\n    } <span class="keyword">else</span> {\n        y = _Minimum(t, z->right);\n        y_original_color = y->color;\n        x = y->right;\n        <span class="keyword">if</span> (y->p == z) {\n            x->p = y;\n        } <span class="keyword">else</span> {\n            _Transplant(t, y, y->right);\n            y->right = z->right;\n            y->right->p = y;\n        }\n        _Transplant(t, z, y);\n        y->left = z->left;\n        y->left->p = y;\n        y->color = z->color;\n    }\n    <span class="keyword">if</span> (y_original_color == _BLACK) {\n        _DeleteFixUp(t, x);\n    }\n}\n\nrb_tree_node* _Search(rb_tree* t, rb_tree_node* x, int k) {\n    <span class="keyword">while</span> (x != t->nil &amp;&amp; k != x->key) {\n        <span class="keyword">if</span> (k &lt; x->key) {\n            x = x->left;\n        } <span class="keyword">else</span> {\n            x = x->right;\n        }\n    }\n    <span class="keyword">return</span> x;\n}\n\nrb_tree_node* RBTreeSearch(rb_tree* t, int k) {\n    <span class="keyword">return</span> _Search(t, t->root, k);\n}\n\nvoid RBTreeDelete(rb_tree* t, int key) {\n    rb_tree_node* newNode = _Search(t, t->root, key);\n    <span class="keyword">if</span> (newNode != t->nil) {\n        _Delete(t, newNode);\n    }\n}\n\nvoid _InorderWalk(rb_tree* t, rb_tree_node* x) {\n    <span class="keyword">if</span> (x != t->nil) {\n        _InorderWalk(t, x->left);\n        printf(<span class="string">"%d "</span>, x->key);\n        _InorderWalk(t, x->right);\n    }\n}\n\nvoid RBTreeInorderWalk(rb_tree* t) {\n    _InorderWalk(t, t->root);\n    printf(<span class="string">"\\n"</span>);\n}\n\nvoid _Destroy(rb_tree* t, rb_tree_node* x) {\n    <span class="keyword">if</span> (x != t->nil) {\n        _Destroy(t, x->left);\n        _Destroy(t, x->right);\n        free(x);\n    }\n}\n\nvoid RBTreeDestroy(rb_tree* t) {\n    _Destroy(t, t->root);\n    free(t->nil);\n}'},109:function(e,n,t){e.exports='<span class="comment">#ifndef RB_TREE_H</span>\n<span class="comment">#define RB_TREE_H</span>\n\ntypedef struct rb_tree_node {\n    int key;\n    int color;\n    struct rb_tree_node* left;\n    struct rb_tree_node* right;\n    struct rb_tree_node* p;\n} rb_tree_node;\n\ntypedef struct rb_tree {\n    rb_tree_node* root;\n    rb_tree_node* nil;\n} rb_tree;\n\nrb_tree* RBTreeCreate();\nvoid RBTreeInsert(rb_tree*, int);\nvoid RBTreeDelete(rb_tree*, int);\nvoid RBTreeDestroy(rb_tree*);\nrb_tree_node* RBTreeSearch(rb_tree*, int);\nvoid RBTreeInorderWalk(rb_tree*);\n\n<span class="comment">#endif</span>'},110:function(e,n,t){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include "./rb-tree.h"</span>\n\nint main(int argc, char <span class="keyword">const</span> *argv[]) {\n  int i;\n  int k;\n  rb_tree* rbTree = RBTreeCreate();\n  <span class="keyword">while</span> (scanf(<span class="string">"%d"</span>, &amp;i) != EOF) {\n    scanf(<span class="string">"%d"</span>, &amp;k);\n    <span class="keyword">switch</span> (i) {\n      <span class="keyword">case</span> <span class="number">0</span>:\n        RBTreeInsert(rbTree, k);\n        <span class="keyword">break</span>;\n      <span class="keyword">case</span> <span class="number">1</span>:\n        RBTreeDelete(rbTree, k);\n        <span class="keyword">break</span>;\n      <span class="keyword">case</span> <span class="number">2</span>:\n        RBTreeSearch(rbTree, k);\n        <span class="keyword">break</span>;\n    }\n    RBTreeInorderWalk(rbTree);\n  }\n  RBTreeDestroy(rbTree);\n  <span class="keyword">return</span> <span class="number">0</span>;\n};'},149:function(e,n,t){function a(){return S.hls.length+1+(S.hl.length?1:0)}function s(e){if(void 0===e.color)return"deepskyblue";var n=T[e.id]+1,t=S.hls.length+1+(S.hl.length?1:0);return t>n&&(n=1),j[e.color](n/t)}function r(e){var n=Math.min(T[e.from],T[e.to])+1,t=S.hls.length+1+(S.hl.length?1:0);return t>n&&(n=1),L.interpolate(0,1)(n/t)}function i(e,n,t){M[e.id]=M[e.id]||{},M[e.id].curr=n}function o(e,n){var t=e.id,a=e[n]?e[n].id:void 0,s=t+n;return void 0!==S.ne[s]&&(a=S.ne[s]),{from:e.id,to:a,type:n,id:s,unconditional:e.nil}}function c(e){I.push(e.id);var n=e.color;return void 0!==S.co[e.id]&&(n=S.co[e.id]),{extra:e.extra,color:n,v:e.key,id:e.id}}function l(e,n){n=n||e.p.id,void 0===M[e.id].prev&&(void 0===M[n]?M[e.id].prev=M[e.id].curr:M[e.id].prev=M[n].prev||M[e.id].curr),(e.p||S.ne[e.id+"p"])&&D.push(o(e,"p")),e.id===S.hl&&(hide=!1),N.push(c(e)),e.left&&(D.push(o(e,"left")),l(e.left,e.id)),e.right&&(D.push(o(e,"right")),l(e.right,e.id)),e.id===S.hl&&(hide=!0)}function p(){N=[],D=[],I=[],T={},T[S.tree.nil.id]=-1===S.hl.indexOf(S.tree.nil.id)?0:a()-1,d(S.tree.root,0);for(var e in M)M[e].prev=M[e].curr;i(S.tree.nil,{x:0,y:1.5*-U}),M[S.tree.nil.id].prev=M[S.tree.nil.id].curr,S.tree.root.nil!==!0&&(i(S.tree.root,{x:0,y:0}),u(S.tree.root.left,0,0,-P,R),u(S.tree.root.right,0,0,P,R)),N.push(c(S.tree.nil)),S.tree.root.nil!==!0&&l(S.tree.root);var n={};for(var t in S.np)n[t]=M[S.np[t]].curr.y;for(var t in S.np)M[t].curr.y=n[t];S.nn&&(N.push(c(S.nn)),i(S.nn,{x:M[S.nn.ref].curr.x,y:M[S.nn.ref].curr.y-(S.nn.extra?U/3:U/2)},1),void 0===M[S.nn.id].prev&&(M[S.nn.id].prev=M[S.nn.ref].curr),void 0!==S.ne[S.nn.id+"p"]&&D.push(o(S.nn,"p")),-1!==S.hl.indexOf(S.nn.id)?T[S.nn.id]=a()-1:T[S.nn.id]=T[S.nn.ref]);for(var t=0;t<D.length;++t){var s=D[t].from,r=D[t].to,p=M[r].curr.x-M[s].curr.x,m=M[r].curr.y-M[s].curr.y,h=Math.sqrt(p*p+m*m),f=O*B;q+f>h?(D[t].dx=0,D[t].dy=0):(D[t].dx=p*(q+f)/h,D[t].dy=m*(q+f)/h)}Object.keys(M).filter(function(e){return-1===I.indexOf(+e)}).forEach(function(e){delete M[e]})}function d(e,n){-1!==S.hls.indexOf(e.id)&&(n=S.hls.lastIndexOf(e.id)+1),-1!==S.hl.indexOf(e.id)?T[e.id]=S.hls.length+1:T[e.id]=n,e.left&&d(e.left,n),e.right&&d(e.right,n)}function u(e,n,t,a,s){if(void 0!==e){var r,o;0>a?(r="right",o="left"):(r="left",o="right");var c=U;return e.nil||void 0===e[r]?i(e,{x:t+a,y:n+c}):i(e,{x:u(e[r],n+c,t,a,e.color)+a,y:n+c}),e.nil||void 0===e[o]?M[e.id].curr.x:u(e[o],n+c,M[e.id].curr.x,a,e.color)}}function m(){E.selectAll("circle.node").data(N,function(e){return e.id}).enter().append("circle").attr("class","node").attr("cx",function(e){return M[e.id].prev.x}).attr("cy",function(e){return M[e.id].prev.y}).attr("r",function(e){return e.extra?q/2:q}).style("fill",function(e){return e.color?"red":"black"}),E.selectAll("circle.node").data(N,function(e){return e.id}).transition().duration(C).attr("cx",function(e){return M[e.id].curr.x}).attr("cy",function(e){return M[e.id].curr.y}).attr("r",function(e){return e.extra?q/2:q}).style("fill",s),E.selectAll("circle.node").data(N,function(e){return e.id}).exit().transition().duration(C).style("opacity",0).remove()}function h(){z.selectAll("line.edge").data(D,function(e){return e.id}).enter().append("line").attr("class","edge").attr("stroke-width",B).attr("x1",function(e){return M[e.from].prev.x+e.dx}).attr("y1",function(e){return M[e.from].prev.y+e.dy}).attr("x2",function(e){return M[e.from].prev.x+e.dx}).attr("y2",function(e){return M[e.from].prev.y+e.dy}).classed("parent",function(e){return"p"===e.type?!0:!1}).classed("child",function(e){return"p"!==e.type?!0:!1}),z.selectAll("line.edge").data(D,function(e){return e.id}).style("marker-end",function(e){return e.id===S.ne.curr?"url(#"+e.type+"-end)":null}).transition().duration(C).attr("x1",function(e){return M[e.from].curr.x+e.dx}).attr("y1",function(e){return M[e.from].curr.y+e.dy}).attr("x2",function(e){return M[e.to].curr.x-e.dx}).attr("y2",function(e){return M[e.to].curr.y-e.dy}).style("opacity",r).style("stroke-dasharray",function(e){return e.unconditional?"5 5":null}),z.selectAll("line.edge").data(D,function(e){return e.id}).exit().transition().duration(C).style("opacity",0).remove()}function f(){_.selectAll("text.node").data(N,function(e){return e.id}).enter().append("text").attr("class","node").attr("x",function(e){return M[e.id].prev.x}).attr("y",function(e){return M[e.id].prev.y}).attr("dy",5),_.selectAll("text.node").data(N,function(e){return e.id}).transition().duration(C).attr("x",function(e){return M[e.id].curr.x}).attr("y",function(e){return M[e.id].curr.y}).style("fill",s).text(function(e){return e.v}),_.selectAll("text.node").data(N,function(e){return e.id}).exit().transition().duration(C).style("opacity",0).remove()}function g(){var e=S.ro?[S.ro.ids]:[];b.selectAll("path.rot").data(e).enter().append("path").attr("class","rot").attr("d",function(e){return this.__prev__=e,"M"+e.map(function(e){return[M[e].curr.x,M[e].curr.y]}).join("L")}).style("fill-opacity",.05).style("opacity",0).transition().duration(C).style("opacity",1),b.selectAll("path.rot").data(e).attr("d",function(e){return this.__prev__=e,"M"+e.map(function(e){return[M[e].curr.x,M[e].curr.y]}).join("L")}),b.selectAll("path.rot").data(e).exit().transition().duration(C).attr("d",function(){for(var e=this.__prev__,n=0;n<e.length;++n)if(void 0===M[e[n]])return"";return"M"+e.map(function(e){return[M[e].curr.x,M[e].curr.y]}).join("L")}).style("opacity",0).remove()}function y(){function e(e){return function(n){return n.reduce(function(n,t){return n+M[t].curr[e]},0)/n.length}}var n=S.ro?[S.ro.ids]:[];_.selectAll("text.rot").data(n).enter().append("text").attr("class","rot").attr("x",e("x")).attr("y",e("y")).attr("dy",5).text(function(){return"left"===S.ro.type?"左旋":"右旋"}).style("fill-opacity",.5),_.selectAll("text.rot").data(n).attr("x",e("x")).attr("y",e("y")).text(function(){return"left"===S.ro.type?"左旋":"右旋"}),_.selectAll("text.rot").data(n).exit().transition().duration(C).style("opacity",0).remove()}function v(e,n){S=e,C=n}function k(e,n){v(e,n),p(),h(),m(),f(),g(),y()}function x(){var e=this,n=L.behavior.zoom().scaleExtent([.1,10]).on("zoom",function(){e.svg.attr("transform",A().translate(L.event.translate).scale(L.event.scale))});this.svg=L.select(this.refs.svg.getDOMNode()).append("svg").call(n).append("g"),this.svg.append("defs").selectAll("marker").data(["left","right","p"]).enter().append("marker").attr("id",function(e){return e+"-end"}).attr("viewBox","0 -5 10 10").attr("markerWidth",O).attr("markerHeight",O).attr("orient","auto").append("path").attr("d","M0,-5L10,0L0,5"),this.g=this.svg.append("g").attr("transform",A().translate(100,100).scale(1)),this.ghigh=this.g.append("g").attr("class","high"),this.gbase=this.g.append("g").attr("class","base"),this.gtext=this.g.append("g").attr("class","text"),
w=this.gbase,z=this.gbase.append("g").attr("class","edges"),E=this.gbase.append("g").attr("class","nodes"),_=this.gtext,b=this.ghigh}var w,_,b,E,z,S,C,L=t(4),A=t(8),M={},N=[],D=[],T={},I=[],P=35,U=70,q=15,R=0,B=3,O=2,j=[L.interpolateRgb("white","black"),L.interpolateRgb("white","red")];e.exports={init:x,render:k}}});