webpackJsonpdsa([2],{18:function(e,n,r){function s(t){var e;v(27),e=t.right,v(28),t.right=e.left,v(29),e.left!==L&&(v(30),e.left.p=t),v(32),e.p=t.p,v(33),t.p===L?(v(34),S.root=e):(v(35),t===t.p.left?(v(36),t.p.left=e):(v(38),t.p.right=e)),v(40),e.left=t,v(41),t.p=e}function a(t){var e;v(46),e=t.left,v(47),t.left=e.right,v(48),e.right!==L&&(v(49),e.right.p=t),v(51),e.p=t.p,v(52),t.p===L?(v(53),S.root=e):(v(54),t===t.p.right?(v(55),t.p.right=e):(v(57),t.p.left=e)),v(59),e.right=t,v(60),t.p=e}function i(t){for(var e;v(65),t.p.color===A;)v(66),t.p===t.p.p.left?(v(67),e=t.p.p.right,v(68),e.color===A?(v(69),t.p.color=D,v(70),e.color=D,v(71),t.p.p.color=A,v(72),t=t.p.p):(v(74),t===t.p.right&&(v(75),t=t.p,v(76),s(t)),v(78),t.p.color=D,v(79),t.p.p.color=A,v(80),a(t.p.p))):(v(83),e=t.p.p.left,v(84),e.color===A?(v(85),t.p.color=D,v(86),e.color=D,v(87),t.p.p.color=A,v(88),t=t.p.p):(v(90),t===t.p.left&&(v(91),t=t.p,v(92),a(t)),v(94),t.p.color=D,v(95),t.p.p.color=A,v(96),s(t.p.p)));v(100),S.root.color=D}function o(t){var e,n;for(v(106),n=S.nil,v(107),e=S.root;v(108,1),e!==L;)v(109),n=e,v(110),t.key<e.key?(v(111),e=e.left):(v(113),e=e.right);v(116),t.p=n,v(117),n===S.nil?(v(118),S.root=t):(v(119),t.key<n.key?(v(120),n.left=t):(v(122),n.right=t)),v(124),t.left=L,v(125),t.right=L,v(126),t.color=A,v(127),i(t)}function c(t){var e={};v(132,1),e.id=E++,v(133,1),e.key=t,v(134),o(e)}function l(t,e){v(138),t.p===L?(v(139),S.root=e):(v(140),t===t.p.left?(v(141),t.p.left=e):(v(143),t.p.right=e)),v(145),e.p=t.p}function p(e){for(var n;v(150),e!==S.root&&e.color===D;)v(151),e===e.p.left?(v(152),n=e.p.right,v(153),v(153),n.color===A&&(v(154),n.color=D,v(155),e.p.color=A,v(156),s(e.p),v(157),n=e.p.right),v(159),n.left.color===D&&n.right.color===D?(v(160),n.color=A,v(161),e=e.p):(v(163),n.right.color===D&&(v(164),n.left.color=D,v(165),n.color=A,v(166),a(n),v(167),n=e.p.right),v(169),n.color=e.p.color,v(170),e.p.color=D,v(171),n.right.color=D,v(172),s(e.p),v(173),e=S.root)):(v(176),n=e.p.left,v(177),n.color===A&&(v(178),n.color=D,v(179),e.p.color=A,v(180),a(e.p),v(181),n=e.p.left),v(183),n.right.color===D&&n.left.color===D?(v(184),n.color=A,v(185),e=e.p):(v(187),n.left.color===D&&(v(188),n.right.color=D,v(189),n.color=A,v(190),s(t,n),v(191),n=e.p.left),v(193),n.color=e.p.color,v(194),e.p.color=D,v(195),n.left.color=D,v(196),a(e.p),v(197),e=S.root));v(201),e.color=D}function u(t){for(;v(205),t.left!==L;)v(206),t=t.left;return v(208),t}function f(t){var e,n,r;v(215),n=t,v(216),r=n.color,v(217),t.left===L?(v(218),e=t.right,v(219),l(t,t.right)):(v(220),t.right===L?(v(221),e=t.left,v(222),l(t,t.left)):(v(224),n=u(t.right),v(225),r=n.color,v(226),e=n.right,v(227),n.p===t?(v(228),e.p=n):(v(230),l(n,n.right),v(231),n.right=t.right,v(232),n.right.p=n),v(234),l(t,n),v(235),n.left=t.left,v(236),n.left.p=n,v(237),n.color=t.color)),v(239),r===D&&(v(240),p(e))}function h(t,e){for(;v(245),t!==L&&e!==t.key;)v(246),e<t.key?(v(247),t=t.left):(v(249),t=t.right);return v(252),t}function d(t){return h(S.root,t)}function g(t){var e=h(S.root,t);v(261),e!==L&&(v(262),f(e))}function m(t){v(267),t!==L&&(v(268),m(t.left),v(269),console.log(t.key),v(270),m(t.right))}function y(){m(S.root)}function v(t,e,n){1===e&&(lastStatus=k.clone()),x.push({status:lastStatus,line:t,animation:n,id:b}),b++}function w(){v(x[x.length-1].line,1)}var _=r(4),x=[],b=0,k={},E=0,A=1,D=0,S={nil:{color:D,key:"nil"}};S.root=S.nil,S.nil.left=S.nil.right=S.nil.p=S.nil;var L=S.nil;k.clone=function(){return{tree:_(S)}},k.init=function(t){t&&(S.root=S.nil,S.nil.left=S.nil.right=S.nil.p=S.nil)},lastStatus={},e.exports={getInitialDescriptions:function(){return this.initialize(!0),c(10),c(1),c(2),c(3),c(4),this.run("insert",5)},initialize:function(t){return x=[],b=0,k.init(t),lastStatus=k.clone(),this},insert:c,inorder:y,"delete":g,search:d,run:function(t,e){return this.initialize()[t](isNaN(parseInt(e))?0:parseInt(e)),w(),{frames:x,others:{}}}}},35:function(t,e,n){var r=n(1),s=n(2);t.exports=r.createClass({displayName:"module.exports",getInitialState:function(){return{text:""}},render:function(){return r.createElement("div",{className:"list"},r.createElement("input",{onChange:this._onChange,value:this.state.text,placeholder:"整数"}),r.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"insert"),value:"插入"}),r.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"delete"),value:"删除"}),r.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"search"),value:"查找"}),r.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"inorder"),value:"中序遍历"}))},_onChange:function(t){this.setState({text:t.target.value})},_onClick:function(t){s.runDemo(t,this.state.text)}})},42:function(t,e,n){t.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "./util.h"</span>\n\nvoid* SafeMalloc(size_t size) {\n    void* m;\n    <span class="keyword">if</span> ((m = malloc(size))) {\n        <span class="keyword">return</span> m;\n    } <span class="keyword">else</span> {\n        printf(<span class="string">"memory overflow\\n"</span>);\n        <span class="keyword">exit</span>(-<span class="number">1</span>);\n        <span class="keyword">return</span> <span class="number">0</span>;\n    }\n}\n\n<span class="comment">// FIXME</span>\n<span class="comment">//   stack,queue and other dsa should use dynamically</span>\n<span class="comment">//   allocated memory, which is what util.c provides.</span>\n<span class="comment">//   Also should be included in model-file descripttions.</span>'},43:function(t,e,n){t.exports='<span class="comment">#ifndef UTIL_H</span>\n<span class="comment">#define UTIL_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\nvoid * SafeMalloc(size_t size);\n\n<span class="comment">#endif</span>'},50:function(t,e,n){t.exports="CC=gcc\nCFLAGS=-c -Wall\nLDFLAGS=\nSOURCES=test.c rb-tree.c rb-tree.h ../common/util.c ../common/util.h\nOBJECTS=$(SOURCES:.c=.o)\nEXECUTABLE=a.out\n\nall: $(SOURCES) $(EXECUTABLE)\n\n$(EXECUTABLE): $(OBJECTS)\n    $(CC) $(LDFLAGS) $(OBJECTS) -o $@\n\n.cpp.o:\n    $(CC) $(CFLAGS) $&lt; -o $@\n\nclean:\n    rm -rf *.o a.out"},51:function(t,e,n){t.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "./rb-tree.h"</span>\n<span class="comment">#include "../common/util.h"</span>\n\nint _RED = <span class="number">1</span>;\nint _BLACK = <span class="number">0</span>;\n\nrb_tree * RBTreeCreate() {\n    rb_tree* newTree;\n    rb_tree_node* newNode;\n\n    newTree = (rb_tree*) SafeMalloc(sizeof(rb_tree));\n\n    newTree->nil = newNode = (rb_tree_node*) SafeMalloc(sizeof(rb_tree_node));\n    newNode->left = newNode->right = newNode->p = newNode;\n    newNode->key = <span class="number">0</span>;\n    newNode->color = _BLACK;\n\n    newTree->root = newTree->nil;\n\n    <span class="keyword">return</span> newTree;\n}\n\nvoid _LeftRotate(rb_tree* t, rb_tree_node* x) {\n    rb_tree_node* y;\n    y = x->right;\n    x->right = y->left;\n    <span class="keyword">if</span> (y->left != t->nil) {\n        y->left->p = x;\n    }\n    y->p = x->p;\n    <span class="keyword">if</span> (x->p == t->nil) {\n        t->root = y;\n    } <span class="keyword">else</span> <span class="keyword">if</span> (x == x->p->left) {\n        x->p->left = y;\n    } <span class="keyword">else</span> {\n        x->p->right = y;\n    }\n    y->left = x;\n    x->p = y;\n}\n\nvoid _RightRotate(rb_tree* t, rb_tree_node* y) {\n    rb_tree_node* x;\n    x = y->left;\n    y->left = x->right;\n    <span class="keyword">if</span> (x->right != t->nil) {\n        x->right->p = y;\n    }\n    x->p = y->p;\n    <span class="keyword">if</span> (y->p == t->nil) {\n        t->root = x;\n    } <span class="keyword">else</span> <span class="keyword">if</span> (y == y->p->right) {\n        y->p->right = x;\n    } <span class="keyword">else</span> {\n        y->p->left = x;\n    }\n    x->right = y;\n    y->p = x;\n}\n\nvoid _InsertFixUp(rb_tree* t, rb_tree_node *z) {\n    rb_tree_node *y;\n    <span class="keyword">while</span> (z->p->color == _RED) {\n        <span class="keyword">if</span> (z->p == z->p->p->left) {\n            y = z->p->p->right;\n            <span class="keyword">if</span> (y->color == _RED) {\n                z->p->color = _BLACK;\n                y->color = _BLACK;\n                z->p->p->color = _RED;\n                z = z->p->p;\n            } <span class="keyword">else</span> {\n                <span class="keyword">if</span> (z == z->p->right) {\n                    z= z->p;\n                    _LeftRotate(t, z);\n                }\n                z->p->color = _BLACK;\n                z->p->p->color = _RED;\n                _RightRotate(t, z->p->p);\n            }\n        } <span class="keyword">else</span> {\n            y = z->p->p->left;\n            <span class="keyword">if</span> (y->color == _RED) {\n                z->p->color = _BLACK;\n                y->color = _BLACK;\n                z->p->p->color = _RED;\n                z = z->p->p;\n            } <span class="keyword">else</span> {\n                <span class="keyword">if</span> (z == z->p->left) {\n                    z= z->p;\n                    _RightRotate(t, z);\n                }\n                z->p->color = _BLACK;\n                z->p->p->color = _RED;\n                _LeftRotate(t, z->p->p);\n            }\n        }\n    }\n    t->root->color = _BLACK;\n}\n\nvoid _Insert(rb_tree* t, rb_tree_node* z) {\n    rb_tree_node* x;\n    rb_tree_node* y;\n    y = t->nil;\n    x = t->root;\n    <span class="keyword">while</span> (x != t->nil) {\n        y = x;\n        <span class="keyword">if</span> (z->key &lt; x->key) {\n            x = x->left;\n        } <span class="keyword">else</span> {\n            x = x->right;\n        }\n    }\n    z->p = y;\n    <span class="keyword">if</span> (y == t->nil) {\n        t->root = z;\n    } <span class="keyword">else</span> <span class="keyword">if</span> (z->key &lt; y->key) {\n        y->left = z;\n    } <span class="keyword">else</span> {\n        y->right = z;\n    }\n    z->left = t->nil;\n    z->right = t->nil;\n    z->color = _RED;\n    _InsertFixUp(t, z);\n}\n\nvoid RBTreeInsert(rb_tree* t, int key) {\n    rb_tree_node* newNode;\n    newNode = (rb_tree_node*) SafeMalloc(sizeof(rb_tree_node));\n    newNode->key = key;\n    _Insert(t, newNode);\n}\n\nvoid _Transplant(rb_tree* t, rb_tree_node* u, rb_tree_node* v) {\n    <span class="keyword">if</span> (u->p == t->nil) {\n        t->root = v;\n    } <span class="keyword">else</span> <span class="keyword">if</span> (u == u->p->left) {\n        u->p->left = v;\n    } <span class="keyword">else</span> {\n        u->p->right = v;\n    }\n    v->p = u->p;\n}\n\nvoid _DeleteFixUp(rb_tree* t, rb_tree_node* x) {\n    rb_tree_node* w;\n    <span class="keyword">while</span> (x != t->root &amp;&amp; x->color == _BLACK) {\n        <span class="keyword">if</span> (x == x->p->left) {\n            w = x->p->right;\n            <span class="keyword">if</span> (w->color == _RED) {\n                w->color = _BLACK;\n                x->p->color = _RED;\n                _LeftRotate(t, x->p);\n                w = x->p->right;\n            }\n            <span class="keyword">if</span> (w->left->color == _BLACK &amp;&amp; w->right->color == _BLACK) {\n                w->color = _RED;\n                x = x->p;\n            } <span class="keyword">else</span> {\n                <span class="keyword">if</span> (w->right->color == _BLACK) {\n                    w->left->color = _BLACK;\n                    w->color = _RED;\n                    _RightRotate(t, w);\n                    w = x->p->right;\n                }\n                w->color = x->p->color;\n                x->p->color = _BLACK;\n                w->right->color = _BLACK;\n                _LeftRotate(t, x->p);\n                x = t->root;\n            }\n        } <span class="keyword">else</span> {\n            w = x->p->left;\n            <span class="keyword">if</span> (w->color == _RED) {\n                w->color = _BLACK;\n                x->p->color = _RED;\n                _RightRotate(t, x->p);\n                w = x->p->left;\n            }\n            <span class="keyword">if</span> (w->right->color == _BLACK &amp;&amp; w->left->color == _BLACK) {\n                w->color = _RED;\n                x = x->p;\n            } <span class="keyword">else</span> {\n                <span class="keyword">if</span> (w->left->color == _BLACK) {\n                    w->right->color = _BLACK;\n                    w->color = _RED;\n                    _LeftRotate(t,w);\n                    w = x->p->left;\n                }\n                w->color = x->p->color;\n                x->p->color = _BLACK;\n                w->left->color = _BLACK;\n                _RightRotate(t, x->p);\n                x = t->root;\n            }\n        }\n    }\n    x->color =_BLACK;\n}\n\nrb_tree_node* _Minimum(rb_tree* t, rb_tree_node *z) {\n    <span class="keyword">while</span> (z->left != t->nil) {\n        z = z->left;\n    }\n    <span class="keyword">return</span> z;\n}\n\nvoid _Delete(rb_tree* t, rb_tree_node *z) {\n    rb_tree_node* x;\n    rb_tree_node* y;\n    int y_original_color;\n    y = z;\n    y_original_color = y->color;\n    <span class="keyword">if</span> (z->left == t->nil) {\n        x = z->right;\n        _Transplant(t, z, z->right);\n    } <span class="keyword">else</span> <span class="keyword">if</span> (z->right == t->nil) {\n        x = z->left;\n        _Transplant(t, z, z->left);\n    } <span class="keyword">else</span> {\n        y = _Minimum(t, z->right);\n        y_original_color = y->color;\n        x = y->right;\n        <span class="keyword">if</span> (y->p == z) {\n            x->p = y;\n        } <span class="keyword">else</span> {\n            _Transplant(t, y, y->right);\n            y->right = z->right;\n            y->right->p = y;\n        }\n        _Transplant(t, z, y);\n        y->left = z->left;\n        y->left->p = y;\n        y->color = z->color;\n    }\n    <span class="keyword">if</span> (y_original_color == _BLACK) {\n        _DeleteFixUp(t, x);\n    }\n}\n\nrb_tree_node* _Search(rb_tree* t, rb_tree_node* x, int k) {\n    <span class="keyword">while</span> (x != t->nil &amp;&amp; k != x->key) {\n        <span class="keyword">if</span> (k &lt; x->key) {\n            x = x->left;\n        } <span class="keyword">else</span> {\n            x = x->right;\n        }\n    }\n    <span class="keyword">return</span> x;\n}\n\nrb_tree_node* RBTreeSearch(rb_tree* t, int k) {\n    <span class="keyword">return</span> _Search(t, t->root, k);\n}\n\nvoid RBTreeDelete(rb_tree* t, int key) {\n    rb_tree_node* newNode = _Search(t, t->root, key);\n    <span class="keyword">if</span> (newNode != t->nil) {\n        _Delete(t, newNode);\n    }\n}\n\nvoid _InorderWalk(rb_tree* t, rb_tree_node* x) {\n    <span class="keyword">if</span> (x != t->nil) {\n        _InorderWalk(t, x->left);\n        printf(<span class="string">"%d "</span>, x->key);\n        _InorderWalk(t, x->right);\n    }\n}\n\nvoid RBTreeInorderWalk(rb_tree* t) {\n    _InorderWalk(t, t->root);\n    printf(<span class="string">"\\n"</span>);\n}\n\nvoid _Destroy(rb_tree* t, rb_tree_node* x) {\n    <span class="keyword">if</span> (x != t->nil) {\n        _Destroy(t, x->left);\n        _Destroy(t, x->right);\n        free(x);\n    }\n}\n\nvoid RBTreeDestroy(rb_tree* t) {\n    _Destroy(t, t->root);\n    free(t->nil);\n}'},52:function(t,e,n){t.exports='<span class="comment">#ifndef RB_TREE_H</span>\n<span class="comment">#define RB_TREE_H</span>\n\ntypedef struct rb_tree_node {\n    int key;\n    int color;\n    struct rb_tree_node* left;\n    struct rb_tree_node* right;\n    struct rb_tree_node* p;\n} rb_tree_node;\n\ntypedef struct rb_tree {\n    rb_tree_node* root;\n    rb_tree_node* nil;\n} rb_tree;\n\nrb_tree* RBTreeCreate();\nvoid RBTreeInsert(rb_tree*, int);\nvoid RBTreeDelete(rb_tree*, int);\nvoid RBTreeDestroy(rb_tree*);\nrb_tree_node* RBTreeSearch(rb_tree*, int);\nvoid RBTreeInorderWalk(rb_tree*);\n\n<span class="comment">#endif</span>'},53:function(t,e,n){t.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include "./rb-tree.h"</span>\n\nint main(int argc, char <span class="keyword">const</span> *argv[]) {\n  int i;\n  int k;\n  rb_tree* rbTree = RBTreeCreate();\n  <span class="keyword">while</span> (scanf(<span class="string">"%d"</span>, &amp;i) != EOF) {\n    scanf(<span class="string">"%d"</span>, &amp;k);\n    <span class="keyword">switch</span> (i) {\n      <span class="keyword">case</span> <span class="number">0</span>:\n        RBTreeInsert(rbTree, k);\n        <span class="keyword">break</span>;\n      <span class="keyword">case</span> <span class="number">1</span>:\n        RBTreeDelete(rbTree, k);\n        <span class="keyword">break</span>;\n      <span class="keyword">case</span> <span class="number">2</span>:\n        RBTreeSearch(rbTree, k);\n        <span class="keyword">break</span>;\n    }\n    RBTreeInorderWalk(rbTree);\n  }\n  RBTreeDestroy(rbTree);\n  <span class="keyword">return</span> <span class="number">0</span>;\n};'},69:function(t,e,n){function r(t){if(t!==w){b.push({color:t.color,pos:t.pos,id:t.id,v:t.key}),t.p!==w&&k.push({pos1:t.p.pos,pos2:t.pos,type:"p",id:"p"+t.p.id+"-"+t.id});var e;t.left===w?(e={color:S,pos:{x:t.pos.x-E,y:t.pos.y+A},id:"left-nil"+t.id,v:"nil"},b.push(e),k.push({pos1:t.pos,pos2:e.pos,type:"left",id:"left"+t.id+"-"+e.id})):(k.push({pos1:t.pos,pos2:t.left.pos,type:"left",id:"left"+t.id+"-"+t.left.id}),r(t.left)),t.right===w?(e={color:S,pos:{x:t.pos.x+E,y:t.pos.y+A},id:"right-nil"+t.id,v:"nil"},b.push(e),k.push({pos1:t.pos,pos2:e.pos,type:"right",id:"right"+t.id+"-"+e.id})):(k.push({pos1:t.pos,pos2:t.right.pos,type:"right",id:"right"+t.id+"-"+t.right.id}),r(t.right))}}function s(){b=[],k=[],a(v.left,0,0,-E),a(v.right,0,0,E);var t={color:S,pos:{x:0,y:-A},id:"-nil",v:"nil"};b.push(t),v!==w&&(v.pos={x:0,y:0},k.push({pos1:t.pos,pos2:v.pos,type:"p",id:"p"+t.id+"-"+v.id})),r(v)}function a(t,e,n,r){if(t!==w&&void 0===t.pos){t.pos={y:e+A};var s,i;return 0>r?(s="right",i="left"):(s="left",i="right"),t[s]===w?t.pos.x=n+2*r:t.pos.x=a(t[s],t.pos.y,n,r)+r,t[i]===w?t.pos.x+r:a(t[i],t.pos.y,t.pos.x,r)}}function i(){g.selectAll("circle.node").data(b,function(t){return t.id}).enter().append("circle").attr("class","node").attr("cx",function(t){return t.pos.x}).attr("cy",function(t){return t.pos.y}).attr("r",D).style("fill",function(t){return t.color?"red":"black"}),g.selectAll("circle.node").data(b,function(t){return t.id}).attr("cx",function(t){return t.pos.x}).attr("cy",function(t){return t.pos.y}).style("fill",function(t){return t.color?"red":"black"}),g.selectAll("circle.node").data(b,function(t){return t.id}).exit().remove()}function o(){m.selectAll("line.edge").data(k,function(t){return t.id}).enter().append("line").attr("class","edge").attr("x1",function(t){return t.pos1.x}).attr("y1",function(t){return t.pos1.y}).attr("x2",function(t){return t.pos1.x}).attr("y2",function(t){return t.pos1.y}).classed("parent",function(t){return"p"===t.type?!0:!1}),m.selectAll("line.edge").data(k,function(t){return t.id}).attr("x1",function(t){return t.pos1.x}).attr("y1",function(t){return t.pos1.y}).attr("x2",function(t){return t.pos2.x}).attr("y2",function(t){return t.pos2.y}),m.selectAll("line.edge").data(k,function(t){return t.id}).exit().remove()}function c(){h.selectAll("text.node").data(b,function(t){return t.id}).enter().append("text").attr("class","node").attr("x",function(t){return t.pos.x}).attr("y",function(t){return t.pos.y}).attr("dy",5).text(function(t){return t.v}),h.selectAll("text.node").data(b,function(t){return t.id}).attr("x",function(t){return t.pos.x}).attr("y",function(t){return t.pos.y}),h.selectAll("text.node").data(b,function(t){return t.id}).exit().remove()}function l(t,e){v=t.tree.root,w=t.tree.nil,y=e}function p(t,e){l(t,e),s(),o(),i(),c()}function u(){var t=this,e=_.behavior.zoom().scaleExtent([.1,10]).on("zoom",function(){t.svg.attr("transform",x().translate(_.event.translate).scale(_.event.scale))});this.svg=_.select(this.refs.svg.getDOMNode()).append("svg").call(e).append("g"),this.g=this.svg.append("g").attr("transform",x().translate(300,50).scale(1)),this.gbase=this.g.append("g").attr("class","base"),this.ghigh=this.g.append("g").attr("class","high"),this.gtext=this.g.append("g").attr("class","text"),f=this.gbase,m=this.gbase.append("g").attr("class","edges"),g=this.gbase.append("g").attr("class","nodes"),h=this.gtext,d=this.ghigh}var f,h,d,g,m,y,v,w,_=n(3),x=n(5),b=[],k=[],E=40,A=40,D=15,S=0;t.exports={init:u,render:p}}});