webpackJsonpdsa([1],{2:function(e,t,n){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "./util.h"</span>\n\nvoid* SafeMalloc(size_t size) {\n    void* m;\n    <span class="keyword">if</span> ((m = malloc(size))) {\n        <span class="keyword">return</span> m;\n    } <span class="keyword">else</span> {\n        printf(<span class="string">"memory overflow\\n"</span>);\n        <span class="keyword">exit</span>(-<span class="number">1</span>);\n        <span class="keyword">return</span> <span class="number">0</span>;\n    }\n}\n\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">// }</span>\n    memcpy(a, b, size);\n}\n\nvoid MemorySwap(void *a, void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// char t;</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     t = *(char *)a;</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">//     *((char *)b + i) = t;</span>\n    <span class="comment">// }</span>\n    void *t = SafeMalloc(size);\n    memcpy(t, a, size);\n    memcpy(a, b, size);\n    memcpy(b, t, size);\n}\n\nvoid MemoryClear(void *a, size_t size) {\n    memset(a, <span class="number">0</span>, size);\n}\n\nvoid *MemoryAddress(void *a, int i, size_t size) {\n    <span class="keyword">return</span> (char *)a + i*size;\n}'},3:function(e,t,n){e.exports='<span class="comment">#ifndef UTIL_H</span>\n<span class="comment">#define UTIL_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\nvoid * SafeMalloc(size_t size);\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size);\nvoid MemorySwap(void *a, void *b, size_t size);\nvoid MemoryClear(void *a, size_t size);\n\n<span class="comment">#endif</span>'},10:function(e,t,n){t=e.exports=n(5)(),t.push([e.id,"circle.node{fill:#ccc;stroke:#000;stroke-width:1.5px}circle.node.painter-selected{fill:#000}circle.node.highlighted{stroke-dasharray:10 2;-webkit-animation:dash .4s linear infinite;animation:dash .4s linear infinite}text.edge,text.node{fill:#000;font:20px sans-serif;pointer-events:none;text-anchor:middle;text-shadow:0 1px 0 #fff,1px 0 0 #fff,0 -1px 0 #fff,-1px 0 0 #fff}path.drag,path.edge{fill:none;stroke:#000;stroke-width:4px}path.edge.painter-selected{stroke-dasharray:10 2;-webkit-animation:dash .4s linear infinite;animation:dash .4s linear infinite}path.edge.painter-selected.rev-dir{-webkit-animation-direction:reverse;animation-direction:reverse}path.edge.painter-selected.rev-dir.sam-dir{-webkit-animation-direction:alternate;animation-direction:alternate}@-webkit-keyframes dash{from{stroke-dashoffset:12}to{stroke-dashoffset:0}}@keyframes dash{from{stroke-dashoffset:12}to{stroke-dashoffset:0}}",""])},11:function(e,t,n){var r=n(1);e.exports=r.createClass({displayName:"module.exports",render:function(){var e={display:this.props.show?"block":"none"},t='<use xlink:href="#cursor">',n='<use xlink:href="#cross">',a=12,s=6,i=Math.sqrt(3),o="M"+[[0,0],[0,a],[i*a/6,-a/6],[s/2,s/2*i],[i*a/6,-a/6],[-s/2,-s/2*i],[i*a/6,-a/6]].map(function(e){return e.toString()}).join("l")+"z";return r.createElement("svg",{className:"legend",width:"210",height:"230",style:e},r.createElement("defs",null,r.createElement("path",{id:"cursor",d:o,stroke:"black",strokeWidth:"1.2",fill:"white"}),r.createElement("g",{id:"cross"},r.createElement("path",{d:"M-6,-6L6,6",stroke:"gray",strokeWidth:"2"}),r.createElement("path",{d:"M-6,6L6,-6",stroke:"gray",strokeWidth:"2"}))),r.createElement("rect",{className:"outline",stroke:"black",x:"0",y:"0",width:"200",height:"210"}),r.createElement("g",{transform:"translate(15,20)"},r.createElement("g",{transform:"translate(8,0)"},r.createElement("path",{d:"M2,0L8,0",markerEnd:"url(#arrow-end)",strokeWidth:"2",stroke:"black"}),r.createElement("path",{d:"M-2,0L-8,0",markerEnd:"url(#arrow-end)",strokeWidth:"2",stroke:"black"}),r.createElement("path",{d:"M0,2L0,8",markerEnd:"url(#arrow-end)",strokeWidth:"2",stroke:"black"}),r.createElement("path",{d:"M0,-2L0,-8",markerEnd:"url(#arrow-end)",strokeWidth:"2",stroke:"black"})),r.createElement("g",{transform:"translate(6,25)"},r.createElement("line",{x1:"0",y1:"0",x2:"10",y2:"10",stroke:"black",strokeWidth:"3"}),r.createElement("circle",{cx:"0",cy:"0",r:"6",fill:"white",stroke:"black",strokeWidth:"2"})),r.createElement("g",{transform:"translate(6,50)"},r.createElement("circle",{cx:"0",cy:"0",r:"6",className:"node"}),r.createElement("g",{transform:"translate(2,-2)",dangerouslySetInnerHTML:{__html:t}})),r.createElement("g",{transform:"translate(6,75)"},r.createElement("circle",{cx:"0",cy:"0",r:"6",className:"node",style:{opacity:"0.33"}}),r.createElement("circle",{cx:"6",cy:"0",r:"6",className:"node",style:{opacity:"0.67"}}),r.createElement("circle",{cx:"12",cy:"0",r:"6",className:"node",style:{opacity:"1"}}),r.createElement("g",{transform:"translate(12,-2)",dangerouslySetInnerHTML:{__html:t}})),r.createElement("g",{transform:"translate(6,100)"},r.createElement("circle",{cx:"0",cy:"0",r:"6",className:"node painter-selected",style:{opacity:"1"}}),r.createElement("g",{transform:"translate(0,0)",dangerouslySetInnerHTML:{__html:n}})),r.createElement("g",{transform:"translate(6,125)"},r.createElement("path",{d:"M0,0L20,0",markerEnd:"url(#arrow-end)",stroke:"black",strokeWidth:"2"}),r.createElement("circle",{r:"6",className:"node"})),r.createElement("g",{transform:"translate(0,150)"},r.createElement("g",{transform:"scale(0.5)"},r.createElement("path",{d:"M0,0L40,0",className:"edge painter-selected",markerEnd:"url(#arrow-end)",stroke:"black",strokeWidth:"2"})),r.createElement("g",{transform:"translate(10,0)",dangerouslySetInnerHTML:{__html:n}})),r.createElement("g",{transform:"translate(0,175)"},r.createElement("g",{transform:"scale(0.5)"},r.createElement("path",{d:"M0,0L40,0",className:"edge painter-selected",markerEnd:"url(#arrow-end)",stroke:"black",strokeWidth:"2"})),r.createElement("text",{x:"3",y:"5"},"a")),r.createElement("g",{transform:"translate(0,5)"},r.createElement("text",{x:"40",y:"0"},"拖动空白区平移"),r.createElement("text",{x:"40",y:"25"},"滚动鼠标轴缩放"),r.createElement("text",{x:"40",y:"50"},"双击添加结点"),r.createElement("text",{x:"40",y:"75"},"shift键拖动结点"),r.createElement("text",{x:"40",y:"100"},"退格键删除结点"),r.createElement("text",{x:"40",y:"125"},"结点上拖动添加边"),r.createElement("text",{x:"40",y:"150"},"退格键删除边"),r.createElement("text",{x:"40",y:"175"},"回车键输入权值"))))}})},12:function(e,t,n){e.exports='<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./graph.h"</span>\n\ngraph* GraphCreate(int n, size_t w_size) {\n    int i;\n    <span class="keyword">if</span> (n == <span class="number">0</span>) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    graph *g = SafeMalloc(sizeof(graph));\n    g->n = n;\n    g->w_size = w_size;\n    g->adja = SafeMalloc(n*(sizeof(graph_edge *)));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) {\n        g->adja[i] = SafeMalloc(sizeof(graph_edge));\n        g->adja[i]->next = <span class="keyword">NULL</span>;\n        g->adja[i]->w = <span class="keyword">NULL</span>;\n    }\n    <span class="keyword">return</span> g;\n}\n\nvoid GraphDestroy(graph *g) {\n    int i;\n    graph_edge *p, *e;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        e = g->adja[i];\n        <span class="keyword">while</span> (e != <span class="keyword">NULL</span>) {\n            p = e->next;\n            <span class="keyword">if</span> (e->w != <span class="keyword">NULL</span>) {\n                free(e->w);\n            }\n            free(e);\n            e = p;\n        }\n    }\n    free(g->adja);\n    free(g);\n}\n\nint GraphNodeValid(graph *g, int u) {\n    <span class="keyword">return</span> <span class="number">0</span> &lt;= u &amp;&amp; u &lt; g->n ? <span class="number">1</span> : <span class="number">0</span>;\n}\n\ngraph_edge* _GraphNewEdge(int u, int v, void *w, size_t w_size) {\n    graph_edge *e = SafeMalloc(sizeof(graph_edge));\n    e->u = u;\n    e->v = v;\n    e->w = SafeMalloc(w_size);\n    MemoryCopy(e->w, w, w_size);\n    <span class="keyword">return</span> e;\n}\n\ngraph_edge* GraphInsert(graph *g, int u, int v, void *w) {\n    graph_edge *e;\n    <span class="keyword">if</span> (!GraphNodeValid(g,u) || !GraphNodeValid(g,v)) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    e = _GraphNewEdge(u,v,w,g->w_size);\n    e->next = g->adja[u]->next;\n    g->adja[u]->next = e;\n    <span class="keyword">return</span> e;\n}'},13:function(e,t,n){e.exports='<span class="comment">#ifndef GRAPH_H</span>\n<span class="comment">#define GRAPH_H</span>\n<span class="comment">#include &lt;stddef.h></span>\n\ntypedef struct graph_edge {\n  int u;\n  int v;\n  void *w;\n  struct graph_edge *next;\n} graph_edge;\n\ntypedef struct graph {\n  int n;\n  size_t w_size;\n  graph_edge **adja;\n} graph;\n\ngraph* GraphCreate(int n, size_t w_size);\nvoid GraphDestroy(graph *g);\ngraph_edge* GraphInsert(graph *g, int u, int v, void *w);\ngraph_edge* GraphDelete(graph *g, int u, int v);\nint GraphNodeValid(graph *g, int u);\n\n<span class="comment">#endif</span>'},16:function(e,t,n){e.exports='<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./queue.h"</span>\n\nint QueueIsEmpty(queue *q) {\n  <span class="keyword">return</span> q->front != q->tail ? <span class="number">0</span> : <span class="number">1</span>;\n}\n\nint QueueIsFull(queue *q) {\n  <span class="keyword">return</span> (q->tail+<span class="number">1</span>) % q->capacity != q->front ? <span class="number">0</span> : <span class="number">1</span>;\n}\n\nvoid *QueuePop(queue *q) {\n  void *item = <span class="keyword">NULL</span>;\n  <span class="keyword">if</span> (!QueueIsEmpty(q)) {\n    item = (char *)q->items + q->front*q->item_size;\n    q->front = (q->front+<span class="number">1</span>) % q->capacity;\n  }\n  <span class="keyword">return</span> item;\n}\n\nvoid *QueuePeak(queue *q) {\n  void *item = <span class="keyword">NULL</span>;\n  <span class="keyword">if</span> (!QueueIsEmpty(q)) {\n    item = (char *)q->items + q->front*q->item_size;\n  }\n  <span class="keyword">return</span> item;\n}\n\nvoid *QueuePush(queue *q, void *x) {\n  <span class="keyword">if</span> (!QueueIsFull(q)) {\n    MemoryCopy((char *)q->items + q->tail*q->item_size, x, q->item_size);\n    q->tail = (q->tail+<span class="number">1</span>) % q->capacity;\n    <span class="keyword">return</span> x;\n  }\n  <span class="keyword">return</span> <span class="keyword">NULL</span>;\n}\n\nqueue *QueueCreate(int n, size_t item_size) {\n  n = n+<span class="number">1</span>;  <span class="comment">// 1 for front-tail</span>\n  queue *q = SafeMalloc(sizeof(queue));\n  q->capacity = n;\n  q->front = q->tail = <span class="number">0</span>;\n  q->items = SafeMalloc(item_size*n);\n  q->item_size = item_size;\n  <span class="keyword">return</span> q;\n}\n\nvoid QueueDestroy(queue *q) {\n  free(q->items);\n  free(q);\n}'},17:function(e,t,n){e.exports='<span class="comment">#ifndef QUEUE_H</span>\n<span class="comment">#define QUEUE_H</span>\n<span class="comment">#include &lt;stddef.h></span>\ntypedef struct queue {\n  int front;\n  int tail;\n  int capacity;\n  size_t item_size;\n  void *items;\n} queue;\n\nqueue *QueueCreate(int n, size_t item_size);\nvoid QueueDestroy(queue *q);\nint QueueIsEmpty(queue *q);\nint QueueIsFull(queue *q);\nvoid *QueuePop(queue *q);\nvoid *QueuePeak(queue *q);\nvoid *QueuePush(queue *q, void *x);\n\n<span class="comment">#endif</span>'},18:function(e,t,n){e.exports='<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./stack.h"</span>\n\nint StackIsEmpty(stack *s) {\n  <span class="keyword">return</span> s->top > <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;\n}\n\nint StackIsFull(stack *s) {\n  <span class="keyword">return</span> s->top &lt; s->capacity ? <span class="number">0</span> : <span class="number">1</span>;\n}\n\nvoid* StackPop(stack *s) {\n  void *item = <span class="keyword">NULL</span>;\n  <span class="keyword">if</span> (!StackIsEmpty(s)) {\n    item = (char *)s->items + (s->top-<span class="number">1</span>)*s->item_size;\n    s->top--;\n  }\n  <span class="keyword">return</span> item;\n}\n\nvoid* StackPeak(stack *s) {\n  void *item = <span class="keyword">NULL</span>;\n  <span class="keyword">if</span> (!StackIsEmpty(s)) {\n    item = (char *)s->items + (s->top-<span class="number">1</span>)*s->item_size;\n  }\n  <span class="keyword">return</span> item;\n}\n\nvoid* StackPush(stack *s, void *x) {\n  <span class="keyword">if</span> (!StackIsFull(s)) {\n    MemoryCopy((char *)s->items + s->top*s->item_size, x, s->item_size);\n    s->top++;\n    <span class="keyword">return</span> x;\n  }\n  <span class="keyword">return</span> <span class="keyword">NULL</span>;\n}\n\nstack *StackCreate(int n, size_t item_size) {\n  stack *s = SafeMalloc(sizeof(stack));\n  s->capacity = n;\n  s->item_size = item_size;\n  s->top = <span class="number">0</span>;\n  s->items = SafeMalloc(item_size*n);\n  <span class="keyword">return</span> s;\n}\n\nvoid StackDestroy(stack *s) {\n  free(s->items);\n  free(s);\n}'},19:function(e,t,n){e.exports='<span class="comment">#ifndef STACK_H</span>\n<span class="comment">#define STACK_H</span>\n<span class="comment">#include &lt;stddef.h></span>\n\ntypedef struct stack {\n  int top;\n  int capacity;\n  size_t item_size;\n  void *items;\n} stack;\n\nstack *StackCreate(int n, size_t item_size);\nvoid StackDestroy(stack *s);\nint StackIsEmpty(stack *s);\nint StackIsFull(stack *s);\nvoid* StackPop(stack *s);\nvoid* StackPeak(stack *s);\nvoid* StackPush(stack *s, void *x);\n\n<span class="comment">#endif</span>'},20:function(e,t,n){var r=n(10);"string"==typeof r&&(r=[[e.id,r,""]]);n(6)(r,{})},22:function(e,t,n){function r(e){ce=!1,H=e.container||document.body,U=C.select(e.container).append("svg").node(),N=e.weighted||!1,R=e.directional||!1,z=e.width||U.clientWidth||e.container.clientWidth,O=e.height||U.clientHeight||e.container.clientHeight,oe=e.offsetLeft||0,ie=e.offsetTop||0,W.nodes=e.nodes||C.range(e.n||5).map(function(){return{}}),W.edges=(e.edges||C.range(5).map(function(e){return{u:e,v:(e+1)%5}})).map(function(e){return{source:W.nodes[e.u],target:W.nodes[e.v],val:e.w,reflexive:e.reflexive}}),B=void 0,j=e._onSelected||void 0,_onLoad=e._onLoad||void 0,ae=void 0,se=!1,C.select(U).call(re).on("dblclick.zoom",null).on("dblclick.svg",A);var t=C.select(U).append("defs");return t.append("marker").attr("id","arrow-end").attr("viewBox","0 -5 10 10").attr("refX",7).attr("refY",0).attr("markerWidth",ee).attr("markerHeight",ee).attr("orient","auto").append("path").attr("d","M0,-5L10,0L0,5"),t.append("marker").attr("id","arrow-start").attr("viewBox","0 -5 10 10").attr("refX",3).attr("refY",0).attr("markerWidth",ee).attr("markerHeight",ee).attr("orient","auto").append("path").attr("d","M10,-5L0,0L10,5"),F=C.select(U).append("g").attr("class","svg-entry"),Y=F.append("g").attr("class","base"),$=Y.append("g").attr("class","edges").classed("directional",R).classed("weighted",N),G=Y.append("g").attr("class","nodes"),Q=F.append("g").attr("class","text").attr("transform","translate(0,7)"),$.append("path").attr("class","drag").attr("marker-end","url(#arrow-end)").style("display","none"),C.select(window).on("keydown.window",E),te.nodes(W.nodes).links(W.edges).size([z,O]),d(),M(!1),te.on("end",function(){M(),te.on("end",null),_onLoad&&_onLoad()}),e.nowait&&(u(),te.on("end")()),this}function a(e,t){var n=e.x-t.x,r=e.y-t.y;return K*K>=n*n+r*r}function s(e,t){var n=Math.PI*t/180;return{x:e.x*Math.cos(n)+e.y*Math.sin(n),y:e.x*-Math.sin(n)+e.y*Math.cos(n)}}function i(e){return"translate("+e.x+","+e.y+")"}function o(e){return{x:-e.x,y:-e.y}}function c(e,t){return{x:e.x-t.x,y:e.y-t.y}}function l(e){return void 0===e.val?"":e.val}function p(e){var t=e.target.x-e.source.x,n=e.target.y-e.source.y,r=Math.sqrt(t*t+n*n),i=C.interpolate(e.source,e.target)(K/r),l=C.interpolate(e.target,e.source)(K/r),p=C.interpolate(30,0)(K/r);if(R&&N){var u=W.edges.filter(function(t){return t.target===e.source&&(t.source===e.target||a(e.target,t.source))});return u.length>0?(e.curve=!0,i=c(s(c(i,e.source),p),o(e.source)),l=c(s(c(l,e.target),-p),o(e.target)),"M"+i.x+","+i.y+"A"+r+","+r+" 0 0,1 "+l.x+","+l.y):(e.curve=!1,"M"+i.x+","+i.y+"L"+l.x+","+l.y)}return e.curve=!1,"M"+i.x+","+i.y+"L"+l.x+","+l.y}function u(){G.selectAll(".node").data(W.nodes).classed("painter-selected",function(e){return e===B}).attr("transform",i),Q.selectAll(".node").data(W.nodes).attr("transform",i).text(function(e,t){return t}),$.selectAll(".edge").data(W.edges).classed("painter-selected",function(e){return e===B}).attr("marker-end",R?"url(#arrow-end)":null).attr("marker-start",R&&N===!1?function(e){return e.reflexive?"url(#arrow-start)":null}:null).attr("d",p),N&&($.selectAll(".edge").each(function(e){var t=this.getPointAtLength(this.getTotalLength()/2);e.x=t.x,e.y=t.y}),Q.selectAll(".edge").data(W.edges).attr("transform",i).text(l))}function d(){G.selectAll(".node").data(W.nodes).enter().append("circle").attr("class","node").attr("r",K).on("dblclick.node",f).call(ne).on("click.select",w).on("mousedown.node",y).on("mouseup.node",x),G.selectAll(".node").data(W.nodes).exit().remove(),Q.selectAll(".node").data(W.nodes).enter().append("text").attr("class","node"),Q.selectAll(".node").data(W.nodes).exit().remove(),$.selectAll(".edge").data(W.edges).enter().append("path").attr("class","edge").on("click.select",w),$.selectAll(".edge").data(W.edges).exit().remove(),N?(Q.selectAll(".edge").data(W.edges).enter().append("text").attr("class","edge"),Q.selectAll(".edge").data(W.edges).exit().remove()):Q.selectAll(".edge").remove(),te.start()}function h(){z=U.clientWidth||H.clientWidth,O=U.clientHeight||H.clientHeight,te.size([z,O]).resume()}function f(e){C.event.stopPropagation(),C.select(this).classed("fixed",e.fixed=!1),te.resume()}function m(e){e.fixed|=2}function g(e){ae&&(se?(C.select(this).classed("fixed",e.fixed=!0),e.px=C.event.x||C.event.clientX,e.py=C.event.y||C.event.clientY,te.resume()):a(C.event,e)===!1?$.select("path.drag").datum({source:e,target:{x:C.event.x||C.event.clientX,y:C.event.y||C.event.clientY}}).attr("d",p).style("display",null):$.select("path.drag").style("display","none"))}function v(e){e.fixed&=-7,$.select("path.drag").style("display","none")}function y(e){(C.event.ctrlKey===!1||void 0===C.event.ctrlKey)&&(C.event.stopPropagation(),ae=e,se=C.event.shiftKey?!0:!1)}function x(e){if(ae&&ae!==e){var t={source:ae,target:e};k(t),d()}ae=void 0,se=!1}function w(e,t){B=B===e?void 0:e,t===!0&&(B=e),B&&j&&j(),te.resume()}function k(e){var t;R===!1?(t=W.edges.filter(function(t){return t.source===e.source&&t.target===e.target||t.target===e.source&&t.source===e.target}),t.length>0?e=t[0]:W.edges.push(e)):N?(t=W.edges.filter(function(t){return t.source===e.source&&t.target===e.target}),t.length>0?e=t[0]:W.edges.push(e)):(t=W.edges.filter(function(t){return t.source===e.source&&t.target===e.target||t.target===e.source&&t.source===e.target}),t.length>0?(t[0].source===e.target&&(t[0].reflexive=!0),e=t[0]):W.edges.push(e)),w(e,!0)}function b(){var e=void 0===B||void 0===B.val?"数字":B.val;return prompt("权值",e)}function _(e){var t=e();return""===t?void delete B.val:(t=parseFloat(t),isNaN(t)||B.val===t?void 0:(B.val=t,d(),this))}function E(){B&&(8===C.event.keyCode?(C.event.preventDefault(),S()):13===C.event.keyCode&&N&&_(b))}function S(){var e=W.nodes.indexOf(B);return-1!==e?(W.nodes.splice(e,1),W.edges.filter(function(e){return e.source===B||e.target===B}).forEach(function(e){W.edges.splice(W.edges.indexOf(e),1)})):(e=W.edges.indexOf(B),-1!=e&&W.edges.splice(W.edges.indexOf(B),1)),B=void 0,d(),this}function L(){X=C.event.translate,J=C.event.scale,F.attr("transform","translate("+C.event.translate+")scale("+C.event.scale+")")}function D(){var e=document.documentElement;return{left:(window.pageXOffset||e.scrollLeft)-(e.clientLeft||0),top:(window.pageYOffset||e.scrollTop)-(e.clientTop||0)}}function A(){if(C.event.target===this){var e=C.event.x||C.event.clientX||C.event.clientX,t=C.event.y||C.event.clientY||C.event.clientY,n=D();e+=n.left-oe,t+=n.top-ie;var r={x:(e-X[0])/J,y:(t-X[1])/J};W.nodes.push(r),w(r),d()}}function M(e){return B&&($.select(".painter-selected").classed("painter-selected",!1),G.select(".painter-selected").classed("painter-selected",!1),B=void 0),N&&(W.edges.forEach(function(e){void 0===e.val&&(e.val=1)}),u()),e!==!1&&te.stop(),C.select(window).on("resize",null).on("keydown.window",null),C.select(U).on("dblclick.svg",null),G.selectAll("circle.node").on("dblclick.node",null).on("dragstart",null).on("drag",null).on("dragend",null).on("click.select",null).on("mousedown.node",null).on("mouseup.node",null),$.selectAll("path.edge").on("click.select",null),this}function P(e,t){function n(e,t){return e.source===t.target&&e.target===t.source}if(R!==e||N!==t){pd=R,R=e,N=t;var r=[];return W.edges.forEach(function(e){R?N?((pd===!1||e.reflexive)&&r.push({source:e.target,target:e.source,val:e.val}),delete e.reflexive,r.push(e)):(delete e.reflexive,r.some(function(t){return n(e,t)})===!1&&((pd===!1||W.edges.some(function(t){return n(e,t)})===!0)&&(e.reflexive=!0),r.push(e))):r.some(function(t){return n(e,t)})===!1&&(delete e.reflexive,r.push(e))}),W.edges=r,$.classed("directional",R).classed("weighted",N),d(),this}}function T(){te.start(),C.select(window).on("resize",h).on("keydown.window",E),C.select(U).on("dblclick.svg",A),G.selectAll("circle.node").on("dblclick.node",f).call(ne).on("click.select",w).on("mousedown.node",y).on("mouseup.node",x),$.selectAll("path.edge").on("click.select",w)}function I(){W.nodes.length=0,W.edges.length=0,d()}function q(){}var C=n(4);n(20);var U,N,R,z,O,B,j,F,Y,$,G,Q,H,W={},X=[0,0],J=1,K=15,V=150,Z=-600,ee=3,te=C.layout.force().linkDistance(V).charge(Z).on("tick",u),ne=C.behavior.drag().origin(function(e){return e}).on("dragstart",m).on("drag",g).on("dragend",v),re=C.behavior.zoom().scaleExtent([.1,10]).on("zoom",L),ae=void 0,se=!1,ie=0,oe=0,ce=!1;e.exports={stop:M,convert:P,weighSelected:_,deleteSelected:S,init:r,restart:T,clear:I,random:q,directional:function(){return R},weighted:function(){return N},raw:function(){return W},data:function(){var e=W.edges.map(function(e){return{u:e.source.index,v:e.target.index,w:e.val}});return R||(e=e.concat(W.edges.map(function(e){return{u:e.target.index,v:e.source.index,w:e.val}}))),R&&!N&&(e=e.concat(W.edges.filter(function(e){return e.reflexive}).map(function(e){return{u:e.target.index,v:e.source.index,w:e.val}}))),{weighted:N,directional:R,n:W.nodes.length,e:e}}}},27:function(e,t,n){function r(e){if(y=!0,m(12,1),!(0>e||e>=q.n)){var t=[];T.inq=t;var n=[],r=[];T.vis=r;var a,s=[];for(a=e,m(24,1),t.push(a),m(25,1),n[a]=1;m(26,1),t.length>0;){m(27),u=t[0],m(28,1),t.splice(0,1),m(29,1),r[u]=1,m(30,1),n[u]=0,m(31),s.push(u);for(var i=0;m(32,1),d(),i<q.e[u].length;i++){var o=q.e[u][i];m(33,1),d(o),r[o.v]||n[o.v]||(m(34,1),t.push(o.v),p(o),m(35,1),n[o.v]=1)}}return m(42,1),s}}function a(e){if(y=!1,m(51,1),!(0>e||e>=q.n)){var t=[];T.inq=t;var n=[],r=[],a=[];T.vis=a;var s,i,o=[];for(s=e,m(64,1),t.push(s),n.push(0),m(66,1),o[s]=1;m(67,1),t.length>0;){for(m(68),i=t[t.length-1],ei=n[n.length-1];m(70,1),d(),ei<q.e[i].length;ei++){var c=q.e[i][ei];if(m(71,1),d(c),!a[c.v]&&!o[c.v]){n.pop(),n.push(ei+1),m(74,1),t.push(c.v),p(c),n.push(0),m(76,1),o[c.v]=1,m(77,1);break}}m(80,1),ei>=q.e[i].length&&(m(81,1),t.pop(),n.pop(),m(83,1),a[i]=1,m(84,1),o[i]=0,m(85,1),r.push(i))}return m(92,1),r}}function s(){var e=[];T.inq=e;var t=[],n=[];T.arr=n;var r=[];r.length=q.n,T.vis=r;var a,s,i,o=[],c=0;for(s=0;m(108,1),f(s),s<q.n&&!c;++s)if(m(109,1),r[s])m(110);else for(m(112),e.push(s),t.push(0),o[s]=1;m(115,1),e.length&&!c;){for(i=e[e.length-1],a=t[t.length-1];m(118),d(),a<q.e[i].length;a++){var l=q.e[i][a];if(m(119,1),d(l),!r[l.v]&&!o[l.v]){t.pop(),t.push(a+1),m(122,1),e.push(l.v),p(l),t.push(0),o[l.v]=1;break}if(m(126,1),o[l.v]){m(127,1),c=1,h(l.v),m(128,1);break}}m(131),a>=q.e[i].length&&(m(132),e.pop(),t.pop(),m(134,1),r[i]=1,o[i]=0,m(136,1),n.push(i))}return m(144,1),f(),c?void m(146,1):(m(148,1),n)}function i(e){f(e);var t,n;for(m(166,1),b[e]=x++,m(167,1),_[e]=b[e],m(168,1),S.push(e),E[e]=1,n=0;m(170,1),d(),n<q.e[e].length;n++){var r=q.e[e][n];m(171,1),d(r),void 0!==b[r.v]||E[r.v]?(m(174,1),E[r.v]&&(m(175,1),_[e]>b[r.v]&&(L[e]=r),_[e]=Math.min(_[e],b[r.v]))):(p(r),D[r.v]=r,m(172,1),d(),i(r.v),f(e),m(173,1),_[e]>_[r.v]&&(L[e]=void 0),_[e]=Math.min(_[e],_[r.v]))}if(T.vis[e]=1,t=S[S.length-1],m(178,1),_[e]===b[e]){c(e);do t=S[S.length-1],m(181,1),S.pop(),E[t]=0,m(183,1),k[t]=w;while(m(184,1),t!==e);m(185,1),w++,d()}}function o(){var e;for(x=0,w=0,k=[],T.col=k,b=[],T.ind=b,_=[],T.low=_,E=[],S=[],T.inq=S,T.vis=[],L=[],D=[],e=0;m(202,1),f(e),e<q.n;++e)m(203),void 0===b[e]&&(m(204),i(e));return m(211),f(),k}function c(e){for(var t=S.length-1;S[t]!=e;--t){var n=S[t];D[n]&&d(D[n]),L[n]&&d(L[n])}}function l(e){q.n=e.n,q.e=[];for(var t=0;t<q.n;++t)q.e.push([]);e.e.forEach(function(e){q.e[e.u].push(e)})}function p(e){void 0===e?T.ine.pop():T.ine.push(e)}function d(e){void 0===e?T.se=[]:T.se.push(e)}function h(e,t){for(var n=T.ine,r=n.length-1;r>=0&&(d(n[r]),n[r].u!==e);--r);}function f(e){T.hl=e}function m(e,t,n){1===t&&(lastStatus=T.clone()),M.push({status:lastStatus,line:e,animation:n,id:P}),P++}function g(){0===M.length?0:M[M.length-1].line;m(316,1)}function v(e){return e=parseInt(e),isNaN(e)?0:e}var y,x,w,k,b,_,E,S,L,D,A=n(8),M=[],P=0,T={},I=0,q={};T.clone=function(){var e=A(this.inq)||[];return{inq:y?e.reverse():e,ine:A(this.ine)||[],vis:A(this.vis)||[],se:A(this.se)||[],arr:A(this.arr)||[],hl:T.hl,col:A(T.col)||[],low:A(T.low)||[],ind:A(T.ind)||[]}},T.init=function(e){this.se=[],this.inq=[],this.ine=[],this.vis=[],this.arr=[],this.col=[],this.low=[],this.ind=[],this.hl=void 0},lastStatus={},e.exports={initialize:function(e){return M=[],P=0,e&&(I=0),T.init(e),lastStatus=T.clone(),this},dfs:a,bfs:r,topo:s,scctarjan:o,run:function(e,t){return l(t.g),this.initialize()[e](v(t.x)),g(),{frames:M,others:{}}}}},42:function(e,t,n){t=e.exports=n(5)(),t.push([e.id,"path.ine{stroke-width:20px;stroke:#00bfff;fill:none;stroke-opacity:.5}.node.visited{fill:#00bfff}path.scc{stroke:#ccc;fill:#ccc;stroke-width:30px;stroke-linejoin:round;opacity:.5}",""])},59:function(e,t,n){var r=n(1);e.exports=r.createClass({displayName:"module.exports",render:function(){var e={display:this.props.show?"block":"none"};return r.createElement("svg",{className:"legend",width:"210",height:"200",style:e},r.createElement("rect",{className:"outline",stroke:"black",x:"0",y:"0",width:"200",height:"190"}),r.createElement("g",{transform:"translate(15,20)"},r.createElement("g",{transform:"translate(0,0)"},r.createElement("g",{transform:"scale(0.5)"},r.createElement("path",{d:"M0,0L50,0",className:"edge painter-selected",markerEnd:"url(#arrow-end)"}))),r.createElement("g",{transform:"translate(0,25)"},r.createElement("g",{transform:"scale(0.5)"},r.createElement("path",{d:"M0,0L50,0",className:"ine"}))),r.createElement("g",{transform:"translate(6,50)"},r.createElement("circle",{cx:"0",cy:"0",r:"6",className:"node highlighted"})),r.createElement("g",{transform:"translate(6,75)"},r.createElement("circle",{cx:"0",cy:"0",r:"6",className:"node visited"})),r.createElement("g",{transform:"translate(6,100)"},r.createElement("circle",{r:"6",className:"node"}),r.createElement("path",{d:"M0,0L0,-6A6,6 0 0,1 5.19,3Z",className:"inq"})),r.createElement("g",{transform:"translate(6,125)"},r.createElement("circle",{r:"6",className:"node"}),r.createElement("text",{x:"2",y:"-2",fontSize:"10px"},"[a]")),r.createElement("g",{transform:"translate(6,150)"},r.createElement("circle",{r:"6",className:"node"}),r.createElement("text",{x:"2",y:"-2",fontSize:"10px"},"(a,b)")),r.createElement("g",{transform:"translate(0,5)"},r.createElement("text",{x:"40",y:"0"},"当前边"),r.createElement("text",{x:"40",y:"25"},"遍历边"),r.createElement("text",{x:"40",y:"50"},"当前结点"),r.createElement("text",{x:"40",y:"75"},"已访问的结点"),r.createElement("text",{x:"40",y:"100"},"访问中的结点"),r.createElement("text",{x:"40",y:"125"},"结点拓扑序号"),r.createElement("text",{x:"40",y:"150"},"时间戳和最远结点"))))}})},60:function(e,t,n){n(134);var r=n(1),a=n(7),s=n(22),i=n(146),o=n(59),c=n(11);e.exports=r.createClass({displayName:"module.exports",getInitialState:function(){return{painting:!1,loaded:!1,text:"",graphType:"有向图",demo:"",help:!0}},componentDidMount:function(){s.init({container:this.refs.svg.getDOMNode(),offsetTop:document.querySelector(".dsa-app").offsetTop+55,offsetLeft:document.querySelector(".dsa-app").offsetLeft+80,_onLoad:this._onLoad,nodes:[{x:50,y:150,fixed:!0},{x:50,y:300,fixed:!0},{x:200,y:150,fixed:!0},{x:200,y:300,fixed:!0},{x:350,y:300,fixed:!0},{x:350,y:150,fixed:!0},{x:500,y:150,fixed:!0},{x:500,y:300,fixed:!0}],edges:[{u:0,v:1},{u:1,v:2},{u:2,v:0},{u:3,v:1},{u:3,v:2},{u:3,v:4,reflexive:!0},{u:4,v:5},{u:5,v:2},{u:5,v:6,reflexive:!0},{u:7,v:6},{u:7,v:4}],directional:!0,nowait:!0}),i.init(s.raw())},componentDidUpdate:function(e){this.props!==e&&void 0!==this.props.frame&&this.props.frame&&i.render(this.props.frame.status,this.props.delay,this.props.others)},render:function(){var e=this.state.painting?r.createElement(c,{show:this.state.help}):r.createElement(o,{show:this.state.help});return r.createElement("div",{className:"wrapper-code"},r.createElement("div",{className:"list"},this.getInputList()),r.createElement("div",{ref:"svg",className:"scene"}),e)},_onLoad:function(){this.setState({loaded:!0})},_onPainting:function(){this.state.painting?s.stop():(i.clear(),a.pauseDemo(),a.waitDemo(),s.restart()),this.setState({painting:!this.state.painting,demo:""})},_onChange:function(e,t){var n={};n[e]=t.target.value,this.setState(n)},_onClick:function(e){this.setState({demo:e}),i.clear(),i.init(s.raw()),a.runDemo(e,{g:s.data(),x:this.state.text})},_onConvert:function(e,t){this.setState({graphType:e?"有向图":"无向图"}),s.convert(e,t)},_onHelp:function(){this.setState({help:!this.state.help})},getInputList:function(){if(this.state.loaded===!1)return r.createElement("input",{className:"input-button",readOnly:!0,value:"加载中",title:"加载中"});var e=this;if(this.state.painting){var t=[{onClick:this._onConvert.bind(this,!1,!1),value:"无向图"},{onClick:this._onConvert.bind(this,!0,!1),value:"有向图"},{onClick:s.clear,value:"清空"},{onClick:this._onPainting,value:"完成"},{help:this.state.help,onClick:this._onHelp,value:"帮助"}];return r.createElement("div",null,t.map(function(t,n){var a="input-group"+(t.value===e.state.graphType||t.help?" input-current":"");return r.createElement("div",{key:n,className:a},r.createElement("input",{className:"input-button",readOnly:!0,onClick:t.onClick,value:t.value,title:t.value}))}))}var t=[{button:{demo:"dfs",onClick:this._onClick.bind(this,"dfs"),value:"深度优先搜索"},items:[{onChange:this._onChange.bind(this,"text"),
value:this.state.text,placeholder:"数字"}]},{button:{demo:"bfs",onClick:this._onClick.bind(this,"bfs"),value:"广度优先搜索"},items:[{onChange:this._onChange.bind(this,"text"),value:this.state.text,placeholder:"数字"}]},{button:{demo:"topo",onClick:this._onClick.bind(this,"topo"),value:"拓扑排序"},items:[{onChange:this._onChange.bind(this,"text"),value:this.state.text,placeholder:"数字"}]},{button:{demo:"scctarjan",onClick:this._onClick.bind(this,"scctarjan"),value:"强连通分量"}},{button:{demo:"",onClick:this._onPainting,value:"编辑图"}},{button:{help:this.state.help,onClick:this._onHelp,value:"帮助"}}];return r.createElement("div",null,t.map(function(t,n){var a="input-group"+(t.button.demo===e.state.demo||t.button.help?" input-current":""),s=t.items?t.items:[];return r.createElement("div",{key:n,className:a},r.createElement("input",{className:"input-button",readOnly:!0,onClick:t.button.onClick,value:t.button.value,title:t.button.value}),r.createElement("div",null,s.map(function(e,t){return r.createElement("input",{key:t,className:"input-item",onChange:e.onChange,value:e.value,title:e.value,placeholder:e.placeholder})})))}))}})},87:function(e,t,n){e.exports="CC=gcc\nCFLAGS=-c -Wall\nLDFLAGS=\nSOURCES=test.c ../common/util.c ../common/util.h ./graph.c ./graph.h ./graph-scc-tarjan.c ./graph-scc-tarjan.h ./graph-topo-sort.c ./graph-topo-sort.h ./graph-traverse.c ./graph-traverse.h ../stack/stack.c ../stack/stack.h ../queue/queue.c ../queue/queue.h\nOBJECTS=$(SOURCES:.c=.o)\nEXECUTABLE=a.out\n\nall: $(SOURCES) $(EXECUTABLE)\n\n$(EXECUTABLE): $(OBJECTS)\n    $(CC) $(LDFLAGS) $(OBJECTS) -o $@\n\n.cpp.o:\n    $(CC) $(CFLAGS) $&lt; -o $@\n\nclean:\n    rm -rf *.o a.out"},88:function(e,t,n){e.exports='<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "../queue/queue.h"</span>\n<span class="comment">#include "../stack/stack.h"</span>\n<span class="comment">#include "../common/graph.h"</span>\n\nqueue *GraphBFS(graph *g, int x) {\n    queue *q, *arr;\n    int *vis, *inq;\n    graph_edge *e;\n    int i, u;\n    <span class="keyword">if</span> (!GraphNodeValid(x)) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    q = QueueCreate(g->n, sizeof(int));\n    arr = QueueCreate(g->n, sizeof(int));\n    vis = SafeMalloc(sizeof(int)*g->n);\n    inq = SafeMalloc(sizeof(int)*g->n);\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        vis[i] = <span class="number">0</span>;\n        inq[i] = <span class="number">0</span>;\n    }\n    i = x;\n    QueuePush(q, &amp;i);\n    inq[i] = <span class="number">1</span>;\n    <span class="keyword">while</span> (!QueueIsEmpty(q)) {\n        u = *(int *)QueuePeak(q);\n        QueuePop(q);\n        vis[u] = <span class="number">1</span>;\n        inq[u] = <span class="number">0</span>;\n        QueuePush(arr, &amp;u);\n        <span class="keyword">for</span> (e = g->adja[u]->next; e != <span class="keyword">NULL</span>; e = e->next) {\n            <span class="keyword">if</span> (!vis[e->v] &amp;&amp; !inq[e->v]) {\n                QueuePush(q, &amp;e->v);\n                inq[e->v] = <span class="number">1</span>;\n            }\n        }\n    }\n    QueueDestroy(q);\n    free(vis);\n    free(inq);\n    <span class="keyword">return</span> arr;\n}\n\nqueue *GraphDFS(graph *g, int x) {\n    stack *su, *se;\n    queue *arr;\n    int *vis, *ins;\n    graph_edge *e;\n    int i, u;\n    <span class="keyword">if</span> (!GraphNodeValid(x)) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    su = StackCreate(g->n, sizeof(int));\n    se = StackCreate(g->n, sizeof(graph_edge *));\n    arr = QueueCreate(g->n, sizeof(int));\n    vis = SafeMalloc(sizeof(int)*g->n);\n    ins = SafeMalloc(sizeof(int)*g->n);\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        vis[i] = <span class="number">0</span>;\n        ins[i] = <span class="number">0</span>;\n    }\n    i = x;\n    StackPush(su, &amp;i);\n    StackPush(se, &amp;g->adja[i]->next);\n    ins[i] = <span class="number">1</span>;\n    <span class="keyword">while</span> (!StackIsEmpty(su)) {\n        u = *(int *)StackPeak(su);\n        e = *(graph_edge **)StackPeak(se);\n        <span class="keyword">for</span> (; e != <span class="keyword">NULL</span>; e = e->next) {\n            <span class="keyword">if</span> (!vis[e->v] &amp;&amp; !ins[e->v]) {\n                StackPop(se);\n                StackPush(se, &amp;e->next);\n                StackPush(su, &amp;e->v);\n                StackPush(se, &amp;g->adja[e->v]->next);\n                ins[e->v] = <span class="number">1</span>;\n                <span class="keyword">break</span>;\n            }\n        }\n        <span class="keyword">if</span> (e == <span class="keyword">NULL</span>) {\n            StackPop(su);\n            StackPop(se);\n            vis[u] = <span class="number">1</span>;\n            ins[u] = <span class="number">0</span>;\n            QueuePush(arr, &amp;u);\n        }\n    }\n    StackDestroy(su);\n    StackDestroy(se);\n    free(vis);\n    free(ins);\n    <span class="keyword">return</span> arr;\n}\n\nstack *GraphTopoSort(graph *g) {\n    stack *su = StackCreate(g->n, sizeof(int));\n    stack *se = StackCreate(g->n, sizeof(graph_edge *));\n    stack *arr = StackCreate(g->n, sizeof(int));\n    int *vis = SafeMalloc(sizeof(int)*g->n);\n    int *ins = SafeMalloc(sizeof(int)*g->n);\n    graph_edge *e;\n    int i, u;\n    int circular = <span class="number">0</span>;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        vis[i] = <span class="number">0</span>;\n        ins[i] = <span class="number">0</span>;\n    }\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n &amp;&amp; !circular; ++i) {\n        <span class="keyword">if</span> (vis[i]) {\n            <span class="keyword">continue</span>;\n        }\n        StackPush(su, &amp;i);\n        StackPush(se, &amp;g->adja[i]->next);\n        ins[i] = <span class="number">1</span>;\n        <span class="keyword">while</span> (!StackIsEmpty(su) &amp;&amp; !circular) {\n            u = *(int *)StackPeak(su);\n            e = *(graph_edge **)StackPeak(se);\n            <span class="keyword">for</span> (; e != <span class="keyword">NULL</span>; e = e->next) {\n                <span class="keyword">if</span> (!vis[e->v] &amp;&amp; !ins[e->v]) {\n                    StackPop(se);\n                    StackPush(se, &amp;e->next);\n                    StackPush(su, &amp;e->v);\n                    StackPush(se, &amp;g->adja[e->v]->next);\n                    ins[e->v] = <span class="number">1</span>;\n                    <span class="keyword">break</span>;\n                } <span class="keyword">else</span> <span class="keyword">if</span> (ins[e->v]) {\n                    circular = <span class="number">1</span>;\n                    <span class="keyword">break</span>;\n                }\n            }\n            <span class="keyword">if</span> (e == <span class="keyword">NULL</span>) {\n                StackPop(su);\n                StackPop(se);\n                vis[u] = <span class="number">1</span>;\n                ins[u] = <span class="number">0</span>;\n                StackPush(arr, &amp;u);\n            }\n        }\n    }\n    StackDestroy(su);\n    StackDestroy(se);\n    free(vis);\n    free(ins);\n    <span class="keyword">if</span> (circular) {\n        StackDestroy(arr);\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    <span class="keyword">return</span> arr;\n}\n\nint _gId;\nint _gColorK;\nint *_gColor;\nint *_gIndex;\nint *_gLowLk;\nint *_gInStk;\nstack *_gStack;\n\nint _GraphSccTarjanMin(int a, int b) {\n    <span class="keyword">return</span> a &lt; b ? a : b;\n}\n\nvoid _GraphSccTarjanColor(graph *g, int u) {\n    int v;\n    graph_edge *e;\n    _gIndex[u] = _gId++;\n    _gLowLk[u] = _gIndex[u];\n    StackPush(_gStack, &amp;u);\n    _gInStk[u] = <span class="number">1</span>;\n    <span class="keyword">for</span> (e = g->adja[u]->next; e != <span class="keyword">NULL</span>; e = e->next) {\n        <span class="keyword">if</span> (_gIndex[e->v] == -<span class="number">1</span> &amp;&amp; !_gInStk[e->v]) {\n            _GraphSccTarjanColor(g, e->v);\n            _gLowLk[u] = _GraphSccTarjanMin(_gLowLk[u], _gLowLk[e->v]);\n        } <span class="keyword">else</span> <span class="keyword">if</span> (_gInStk[e->v]) {\n            _gLowLk[u] = _GraphSccTarjanMin(_gLowLk[u], _gIndex[e->v]);\n        }\n    }\n    <span class="keyword">if</span> (_gLowLk[u] == _gIndex[u]) {\n        <span class="keyword">do</span> {\n            v = *(int *)StackPeak(_gStack);\n            StackPop(_gStack);\n            _gInStk[v] = <span class="number">0</span>;\n            _gColor[v] = _gColorK;\n        } <span class="keyword">while</span> (v != u);\n        _gColorK++;\n    }\n}\n\nint *GraphSccTarjan(graph *g) {\n    int i;\n    _gId = <span class="number">0</span>;\n    _gColorK = <span class="number">0</span>;\n    _gColor = SafeMalloc(g->n*sizeof(int));\n    _gIndex = SafeMalloc(g->n*sizeof(int));\n    _gLowLk = SafeMalloc(g->n*sizeof(int));\n    _gInStk = SafeMalloc(g->n*sizeof(int));\n    _gStack = StackCreate(g->n, sizeof(int));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        _gIndex[i] = -<span class="number">1</span>;\n        _gInStk[i] = <span class="number">0</span>;\n    }\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        <span class="keyword">if</span> (_gIndex[i] == -<span class="number">1</span>) {\n            _GraphSccTarjanColor(g, i);\n        }\n    }\n    free(_gIndex);\n    free(_gLowLk);\n    free(_gInStk);\n    StackDestroy(_gStack);\n    <span class="keyword">return</span> _gColor;\n}'},89:function(e,t,n){e.exports='<span class="comment">#ifndef GRAPH_APP_H</span>\n<span class="comment">#define GRAPH_APP_H</span>\n<span class="comment">#include "../common/graph.h"</span>\n<span class="comment">#include "../queue/queue.h"</span>\n<span class="comment">#include "../stack/stack.h"</span>\n\nint *GraphSccTarjan(graph *g);\nstack *GraphTopoSort(graph *g);\nqueue *GraphBFS(graph *g);\nqueue *GraphDFS(graph *g);\n\n<span class="comment">#endif</span>'},90:function(e,t,n){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/graph.h"</span>\n<span class="comment">#include "./graph-app.h"</span>\n<span class="comment">#include "../queue/queue.h"</span>\n<span class="comment">#include "../stack/stack.h"</span>\n\nint main(int argc, char <span class="keyword">const</span> *argv[])\n{\n  int n, m, i, u, v;\n  int w = <span class="number">1</span>;\n  graph *g;\n  queue *q;\n  stack *s;\n  int *c;\n  <span class="keyword">while</span> (scanf(<span class="string">"%d%d"</span>, &amp;n,&amp;m) != EOF) {\n    g = GraphCreate(n, sizeof(int));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++i) {\n      scanf(<span class="string">"%d%d"</span>, &amp;u, &amp;v);\n      GraphInsert(g, u, v, &amp;w);\n    }\n    q = GraphBFS(g);\n    <span class="keyword">while</span> (!QueueIsEmpty(q)) {\n      printf(<span class="string">"%d "</span>, *(int *)QueuePeak(q));\n      QueuePop(q);\n    }\n    printf(<span class="string">"--bfs\\n"</span>);\n    QueueDestroy(q);\n    q = GraphDFS(g);\n    <span class="keyword">while</span> (!QueueIsEmpty(q)) {\n      printf(<span class="string">"%d "</span>, *(int *)QueuePeak(q));\n      QueuePop(q);\n    }\n    printf(<span class="string">"--dfs\\n"</span>);\n    QueueDestroy(q);\n    s = GraphTopoSort(g);\n    <span class="keyword">if</span> (s == <span class="keyword">NULL</span>) {\n      printf(<span class="string">"circular"</span>);\n    } <span class="keyword">else</span> {\n      <span class="keyword">while</span> (!StackIsEmpty(s)) {\n        printf(<span class="string">"%d "</span>, *(int *)StackPeak(s));\n        StackPop(s);\n      }\n      StackDestroy(s);\n    }\n    printf(<span class="string">"--topoSort\\n"</span>);\n    c = GraphSccTarjan(g);\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n      printf(<span class="string">"%d "</span>, i);\n    }\n    printf(<span class="string">"--sccTarjan\\n"</span>);\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n      printf(<span class="string">"%d "</span>, c[i]);\n    }\n    printf(<span class="string">"--sccTarjan\\n"</span>);\n    free(c);\n\n    GraphDestroy(g);\n  }\n  <span class="keyword">return</span> <span class="number">0</span>;\n}'},134:function(e,t,n){var r=n(42);"string"==typeof r&&(r=[[e.id,r,""]]);n(6)(r,{})},146:function(e,t,n){function r(e){return"translate("+q.nodes[e].x+","+q.nodes[e].y+")"}function a(e,t){return{endAngle:(t+1)/D.inq.length*N}}function s(e){return e}function i(e){return void 0!==D.vis[e.index]}function o(){gnodes.selectAll("path.inq").data(D.inq,s).enter().append("path").attr("class","inq").attr("d",function(e){return R({endAngle:0})}).attr("transform",r).each(function(e){this._current={endAngle:0}}),gnodes.selectAll("path.inq").data(D.inq,s).transition().duration(A).attr("transform",r).attrTween("d",function(e,t){var n=C.interpolate(this._current,a(e,t));return this._current=n(0),function(e){return R(n(e))}}),gnodes.selectAll("path.inq").data(D.inq,s).exit().remove(),gnodes.selectAll("circle.node").classed("visited",i),L.selectAll("text.node").classed("visited",i)}function c(e){return e.u+"-"+e.v}function l(e,t){var n=Math.PI*t/180;return{x:e.x*Math.cos(n)+e.y*Math.sin(n),y:e.x*-Math.sin(n)+e.y*Math.cos(n)}}function p(e){return{x:-e.x,y:-e.y}}function u(e,t){return{x:e.x-t.x,y:e.y-t.y}}function d(e,t,n){var r=gedges.classed("weighted"),a=gedges.classed("directional");if(!r||!a){if(n===!0)return t.u===e.source.index&&t.v===e.target.index;if(n===!1)return t.v===e.source.index&&t.u===e.target.index}return e.reflexive||!a?t.u===e.source.index&&t.v===e.target.index||t.v===e.source.index&&t.u===e.target.index:t.u===e.source.index&&t.v===e.target.index}function h(e){var t=gedges.classed("weighted"),n=gedges.classed("directional"),r=q.edges.filter(function(t){return d(t,e)})[0];return n&&t?r:{source:r.source.index===e.u?r.source:r.target,target:r.target.index===e.v?r.target:r.source}}function f(e){return function(t){var n=h(t),r=n.source.x-n.target.x,a=n.target.y-n.source.y,s=Math.sqrt(r*r+a*a),i="exit"===e?C.interpolate(n.target,n.source):C.interpolate(n.source,n.target),o=n.source;if(n.curve){var c="exit"===e?C.interpolate(0,30):C.interpolate(30,0);return function(e){var t=c(e),n=u(l(u(i(e),o),t),p(o));return"M"+o.x+","+o.y+"A"+s+","+s+" 0 0,1 "+n.x+","+n.y}}return function(e){var t=i(e);return"M"+o.x+","+o.y+"L"+t.x+","+t.y}}}function m(e){return D.se.some(function(t){return d(e,t)})}function g(e){var t=gedges.classed("weighted"),n=gedges.classed("directional");return n&&t?!1:D.se.some(function(t){return d(e,t,!1)})}function v(e){var t=gedges.classed("weighted"),n=gedges.classed("directional");return n&&t?!1:D.se.some(function(t){return d(e,t,!0)})}function y(){gedges.selectAll("path.edge").classed("painter-selected",m).classed("rev-dir",g).classed("sam-dir",v),gedges.selectAll("path.ine").data(D.ine,c).enter().insert("path",":first-child").attr("class","ine").transition().duration(A).attrTween("d",f("update")),gedges.selectAll("path.ine").data(D.ine,c).exit().transition().duration(A).attrTween("d",f("exit")).remove()}function x(){gnodes.selectAll("circle.node").classed("highlighted",function(e,t){return t===D.hl}),P.selectAll("text.topo").data(D.arr,s).enter().append("text").attr("class","topo").attr("transform",r).text(function(e,t){return"["+(D.vis.length-t-1)+"]"}),P.selectAll("text.topo").data(D.arr,s).attr("transform",r).text(function(e,t){return"["+(D.vis.length-t-1)+"]"}),P.selectAll("text.topo").data(D.arr,s).exit().remove()}function w(){function e(e,t){return r(t)}function t(e){return void 0===D.ind[e]?"":"("+D.ind[e]+","+(void 0===D.low[e]?"?":D.low[e])+")"}var n=D.col.reduce(function(e,t,n){return void 0!==t&&(e[t]=(e[t]||[]).concat(C.range(4).map(function(e){return[q.nodes[n].x+z[e][0]*U,q.nodes[n].y+z[e][1]*U]}))),e},[]).map(C.geom.hull);S.selectAll("path.scc").data(n).enter().insert("path",":first-child").attr("class","scc"),S.selectAll("path.scc").data(n).attr("d",function(e){return"M"+e.join("L")+"Z"}),S.selectAll("path.scc").data(n).exit().remove(),T.selectAll("text.low").data(D.low).enter().append("text").attr("class","low"),T.selectAll("text.low").data(D.low).text(function(e,n){return t(n)}).attr("transform",e),T.selectAll("text.low").data(D.low).exit().remove()}function k(e,t,n){D=e,A=t,M=n}function b(e,t,n){k(e,t,n),o(),y(),x(),w()}function _(e){q=e,S=C.select("g.base"),L=C.select("g.text"),gnodes=C.select("g.nodes"),gedges=C.select("g.edges"),C.selectAll("g.topo,g.scclow,g.sccind").remove(),P=L.append("g").attr("class","topo").attr("transform","translate(15,-15)"),T=L.append("g").attr("class","scclow").attr("transform","translate(20,-10)"),I=L.append("g").attr("class","sccind").attr("transform","translate(15,15)")}function E(){S.selectAll("path.scc").remove(),gnodes.selectAll("path.inq").remove(),gedges.selectAll("path.edge").attr("class","edge"),gedges.selectAll("path.ine").remove(),gnodes.selectAll("circle.node").attr("class","node"),L.selectAll("text.node").attr("class","node"),P.remove(),T.remove(),I.remove()}var S,L,D,A,M,P,T,I,q,C=n(4),U=(n(9),15),N=2*Math.PI,R=C.svg.arc().innerRadius(0).outerRadius(U).startAngle(0),z=(C.scale.category10(),[[-1,-1],[-1,1],[1,-1],[1,1]]);e.exports={init:_,render:b,clear:E}}});