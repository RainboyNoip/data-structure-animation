webpackJsonpdsa([1],{6:function(e,t,n){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "./util.h"</span>\n\nvoid* SafeMalloc(size_t size) {\n    void* m;\n    <span class="keyword">if</span> ((m = malloc(size))) {\n        <span class="keyword">return</span> m;\n    } <span class="keyword">else</span> {\n        printf(<span class="string">"memory overflow\\n"</span>);\n        <span class="keyword">exit</span>(-<span class="number">1</span>);\n        <span class="keyword">return</span> <span class="number">0</span>;\n    }\n}\n\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">// }</span>\n    memcpy(a, b, size);\n}\n\nvoid MemorySwap(void *a, void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// char t;</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     t = *(char *)a;</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">//     *((char *)b + i) = t;</span>\n    <span class="comment">// }</span>\n    void *t = SafeMalloc(size);\n    memcpy(t, a, size);\n    memcpy(a, b, size);\n    memcpy(b, t, size);\n}\n\nvoid MemoryClear(void *a, size_t size) {\n    memset(a, <span class="number">0</span>, size);\n}\n\nvoid *MemoryAddress(void *a, int i, size_t size) {\n    <span class="keyword">return</span> (char *)a + i*size;\n}'},7:function(e,t,n){e.exports='<span class="comment">#ifndef UTIL_H</span>\n<span class="comment">#define UTIL_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\nvoid * SafeMalloc(size_t size);\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size);\nvoid MemorySwap(void *a, void *b, size_t size);\nvoid MemoryClear(void *a, size_t size);\n\n<span class="comment">#endif</span>'},10:function(e,t,n){e.exports='<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./queue.h"</span>\n\nint QueueIsEmpty(queue *q) {\n  <span class="keyword">return</span> q->front != q->tail ? <span class="number">0</span> : <span class="number">1</span>;\n}\n\nint QueueIsFull(queue *q) {\n  <span class="keyword">return</span> (q->tail+<span class="number">1</span>) % q->capacity != q->front ? <span class="number">0</span> : <span class="number">1</span>;\n}\n\nvoid *QueuePop(queue *q) {\n  void *item = <span class="keyword">NULL</span>;\n  <span class="keyword">if</span> (!QueueIsEmpty(q)) {\n    item = (char *)q->items + q->front*q->item_size;\n    q->front = (q->front+<span class="number">1</span>) % q->capacity;\n  }\n  <span class="keyword">return</span> item;\n}\n\nvoid *QueuePeak(queue *q) {\n  void *item = <span class="keyword">NULL</span>;\n  <span class="keyword">if</span> (!QueueIsEmpty(q)) {\n    item = (char *)q->items + q->front*q->item_size;\n  }\n  <span class="keyword">return</span> item;\n}\n\nvoid *QueuePush(queue *q, void *x) {\n  <span class="keyword">if</span> (!QueueIsFull(q)) {\n    MemoryCopy((char *)q->items + q->tail*q->item_size, x, q->item_size);\n    q->tail = (q->tail+<span class="number">1</span>) % q->capacity;\n    <span class="keyword">return</span> x;\n  }\n  <span class="keyword">return</span> <span class="keyword">NULL</span>;\n}\n\nqueue *QueueCreate(int n, size_t item_size) {\n  n = n+<span class="number">1</span>;  <span class="comment">// 1 for front-tail</span>\n  queue *q = SafeMalloc(sizeof(queue));\n  q->capacity = n;\n  q->front = q->tail = <span class="number">0</span>;\n  q->items = SafeMalloc(item_size*n);\n  q->item_size = item_size;\n  <span class="keyword">return</span> q;\n}\n\nvoid QueueDestroy(queue *q) {\n  free(q->items);\n  free(q);\n}'},11:function(e,t,n){e.exports='<span class="comment">#ifndef QUEUE_H</span>\n<span class="comment">#define QUEUE_H</span>\n<span class="comment">#include &lt;stddef.h></span>\ntypedef struct queue {\n  int front;\n  int tail;\n  int capacity;\n  size_t item_size;\n  void *items;\n} queue;\n\nqueue *QueueCreate(int n, size_t item_size);\nvoid QueueDestroy(queue *q);\nint QueueIsEmpty(queue *q);\nint QueueIsFull(queue *q);\nvoid *QueuePop(queue *q);\nvoid *QueuePeak(queue *q);\nvoid *QueuePush(queue *q, void *x);\n\n<span class="comment">#endif</span>'},12:function(e,t,n){e.exports='<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./stack.h"</span>\n\nint StackIsEmpty(stack *s) {\n  <span class="keyword">return</span> s->top > <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;\n}\n\nint StackIsFull(stack *s) {\n  <span class="keyword">return</span> s->top &lt; s->capacity ? <span class="number">0</span> : <span class="number">1</span>;\n}\n\nvoid* StackPop(stack *s) {\n  void *item = <span class="keyword">NULL</span>;\n  <span class="keyword">if</span> (!StackIsEmpty(s)) {\n    item = (char *)s->items + (s->top-<span class="number">1</span>)*s->item_size;\n    s->top--;\n  }\n  <span class="keyword">return</span> item;\n}\n\nvoid* StackPeak(stack *s) {\n  void *item = <span class="keyword">NULL</span>;\n  <span class="keyword">if</span> (!StackIsEmpty(s)) {\n    item = (char *)s->items + (s->top-<span class="number">1</span>)*s->item_size;\n  }\n  <span class="keyword">return</span> item;\n}\n\nvoid* StackPush(stack *s, void *x) {\n  <span class="keyword">if</span> (!StackIsFull(s)) {\n    MemoryCopy((char *)s->items + s->top*s->item_size, x, s->item_size);\n    s->top++;\n    <span class="keyword">return</span> x;\n  }\n  <span class="keyword">return</span> <span class="keyword">NULL</span>;\n}\n\nstack *StackCreate(int n, size_t item_size) {\n  stack *s = SafeMalloc(sizeof(stack));\n  s->capacity = n;\n  s->item_size = item_size;\n  s->top = <span class="number">0</span>;\n  s->items = SafeMalloc(item_size*n);\n  <span class="keyword">return</span> s;\n}\n\nvoid StackDestroy(stack *s) {\n  free(s->items);\n  free(s);\n}'},13:function(e,t,n){e.exports='<span class="comment">#ifndef STACK_H</span>\n<span class="comment">#define STACK_H</span>\n<span class="comment">#include &lt;stddef.h></span>\n\ntypedef struct stack {\n  int top;\n  int capacity;\n  size_t item_size;\n  void *items;\n} stack;\n\nstack *StackCreate(int n, size_t item_size);\nvoid StackDestroy(stack *s);\nint StackIsEmpty(stack *s);\nint StackIsFull(stack *s);\nvoid* StackPop(stack *s);\nvoid* StackPeak(stack *s);\nvoid* StackPush(stack *s, void *x);\n\n<span class="comment">#endif</span>'},18:function(e,t,n){function r(e){if(y=!0,g(12,1),!(0>e||e>=q.n)){var t=[];T.inq=t;var n=[],r=[];T.vis=r;var s,a=[];for(s=e,g(24,1),t.push(s),g(25,1),n[s]=1;g(26,1),t.length>0;){g(27),u=t[0],g(28,1),t.splice(0,1),g(29,1),r[u]=1,g(30,1),n[u]=0,g(31),a.push(u);for(var i=0;g(32,1),d(),i<q.e[u].length;i++){var o=q.e[u][i];g(33,1),d(o),r[o.v]||n[o.v]||(g(34,1),t.push(o.v),p(o),g(35,1),n[o.v]=1)}}return g(42,1),a}}function s(e){if(y=!1,g(51,1),!(0>e||e>=q.n)){var t=[];T.inq=t;var n=[],r=[],s=[];T.vis=s;var a,i,o=[];for(a=e,g(64,1),t.push(a),n.push(0),g(66,1),o[a]=1;g(67,1),t.length>0;){for(g(68),i=t[t.length-1],ei=n[n.length-1];g(70,1),d(),ei<q.e[i].length;ei++){var c=q.e[i][ei];if(g(71,1),d(c),!s[c.v]&&!o[c.v]){n.pop(),n.push(ei+1),g(74,1),t.push(c.v),p(c),n.push(0),g(76,1),o[c.v]=1,g(77,1);break}}g(80,1),ei>=q.e[i].length&&(g(81,1),t.pop(),n.pop(),g(83,1),s[i]=1,g(84,1),o[i]=0,g(85,1),r.push(i))}return g(92,1),r}}function a(){var e=[];T.inq=e;var t=[],n=[];T.arr=n;var r=[];r.length=q.n,T.vis=r;var s,a,i,o=[],c=0;for(a=0;g(108,1),h(a),a<q.n&&!c;++a)if(g(109,1),r[a])g(110);else for(g(112),e.push(a),t.push(0),o[a]=1;g(115,1),e.length&&!c;){for(i=e[e.length-1],s=t[t.length-1];g(118),d(),s<q.e[i].length;s++){var l=q.e[i][s];if(g(119,1),d(l),!r[l.v]&&!o[l.v]){t.pop(),t.push(s+1),g(122,1),e.push(l.v),p(l),t.push(0),o[l.v]=1;break}if(g(126,1),o[l.v]){g(127,1),c=1,f(l.v),g(128,1);break}}g(131),s>=q.e[i].length&&(g(132),e.pop(),t.pop(),g(134,1),r[i]=1,o[i]=0,g(136,1),n.push(i))}return g(144,1),h(),c?void g(146,1):(g(148,1),n)}function i(e){h(e);var t,n;for(g(166,1),_[e]=w++,g(167,1),b[e]=_[e],g(168,1),S.push(e),E[e]=1,n=0;g(170,1),d(),n<q.e[e].length;n++){var r=q.e[e][n];g(171,1),d(r),void 0!==_[r.v]||E[r.v]?(g(174,1),E[r.v]&&(g(175,1),b[e]>_[r.v]&&(A[e]=r),b[e]=Math.min(b[e],_[r.v]))):(p(r),L[r.v]=r,g(172,1),d(),i(r.v),h(e),g(173,1),b[e]=Math.min(b[e],b[r.v]))}if(T.vis[e]=1,t=S[S.length-1],g(178,1),b[e]===_[e]){c(e);do t=S[S.length-1],A[t]&&d(A[t]),g(181,1),S.pop(),E[t]=0,g(183,1),k[t]=x;while(g(184,1),t!==e);g(185,1),x++,d()}}function o(){var e;for(w=0,x=0,k=[],T.col=k,_=[],T.ind=_,b=[],T.low=b,E=[],S=[],T.inq=S,T.vis=[],A=[],L=[],e=0;g(202,1),h(e),e<q.n;++e)g(203),void 0===_[e]&&(g(204),i(e));return g(211),h(),k}function c(e){for(var t=S.length-1;S[t]!=e;--t)L[S[t]]&&d(L[S[t]])}function l(e){q.n=e.n,q.e=[];for(var t=0;t<q.n;++t)q.e.push([]);e.e.forEach(function(e){q.e[e.u].push(e)})}function p(e){void 0===e?T.ine.pop():T.ine.push(e)}function d(e){void 0===e?T.se=[]:T.se.push(e)}function f(e,t){for(var n=T.ine,r=n.length-1;r>=0&&(d(n[r]),n[r].u!==e);--r);}function h(e){T.hl=e}function g(e,t,n){1===t&&(lastStatus=T.clone()),P.push({status:lastStatus,line:e,animation:n,id:M}),M++}function m(){0===P.length?0:P[P.length-1].line;g(316,1)}function v(e){return e=parseInt(e),isNaN(e)?0:e}var y,w,x,k,_,b,E,S,A,L,D=n(4),P=[],M=0,T={},I=0,q={};T.clone=function(){var e=D(this.inq)||[];return{inq:y?e.reverse():e,ine:D(this.ine)||[],vis:D(this.vis)||[],se:D(this.se)||[],arr:D(this.arr)||[],hl:T.hl,col:D(T.col)||[],low:D(T.low)||[],ind:D(T.ind)||[]}},T.init=function(e){this.se=[],this.inq=[],this.ine=[],this.vis=[],this.arr=[],this.col=[],this.low=[],this.ind=[],this.hl=void 0},lastStatus={},e.exports={initialize:function(e){return P=[],M=0,e&&(I=0),T.init(e),lastStatus=T.clone(),this},dfs:s,bfs:r,topo:a,scctarjan:o,run:function(e,t){return l(t.g),this.initialize()[e](v(t.x)),m(),{frames:P,others:{}}}}},30:function(e,t,n){t=e.exports=n(8)(),t.push([e.id,"circle.node{fill:#ccc;stroke:#000;stroke-width:1.5px}circle.node.painter-selected{fill:#000}circle.node.highlighted{stroke-dasharray:10 2;-webkit-animation:dash .4s linear infinite;animation:dash .4s linear infinite}text.edge,text.node{fill:#000;font:20px sans-serif;pointer-events:none;text-anchor:middle;text-shadow:0 1px 0 #fff,1px 0 0 #fff,0 -1px 0 #fff,-1px 0 0 #fff}path.drag,path.edge{fill:none;stroke:#000;stroke-width:4px}path.edge.painter-selected{stroke-dasharray:10 2;-webkit-animation:dash .4s linear infinite;animation:dash .4s linear infinite}path.edge.painter-selected.rev-dir{-webkit-animation-direction:reverse;animation-direction:reverse}path.edge.painter-selected.rev-dir.sam-dir{-webkit-animation-direction:alternate;animation-direction:alternate}@-webkit-keyframes dash{from{stroke-dashoffset:12}to{stroke-dashoffset:0}}@keyframes dash{from{stroke-dashoffset:12}to{stroke-dashoffset:0}}",""])},31:function(e,t,n){t=e.exports=n(8)(),t.push([e.id,"path.ine{stroke-width:20px;stroke:#00bfff;fill:none;stroke-opacity:.5}.node.visited{fill:#00bfff}path.scc{stroke:#ccc;fill:#ccc;stroke-width:30px;stroke-linejoin:round;opacity:.5}",""])},44:function(e,t,n){n(101);var r=n(1),s=n(3),a=n(110),i=n(111);e.exports=r.createClass({displayName:"module.exports",getInitialState:function(){return{painting:!1,loaded:!1,text:""}},componentDidMount:function(){a.init({container:this.refs.svg.getDOMNode(),offsetTop:document.querySelector(".dsa-app").offsetTop+55,offsetLeft:document.querySelector(".dsa-app").offsetLeft+80,_onLoad:this._onLoad,nodes:[{x:50,y:150,fixed:!0},{x:50,y:300,fixed:!0},{x:200,y:150,fixed:!0},{x:200,y:300,fixed:!0},{x:350,y:300,fixed:!0},{x:350,y:150,fixed:!0},{x:500,y:150,fixed:!0},{x:500,y:300,fixed:!0}],edges:[{u:0,v:1},{u:1,v:2},{u:2,v:0},{u:3,v:1},{u:3,v:2},{u:3,v:4,reflexive:!0},{u:4,v:5},{u:5,v:2},{u:5,v:6,reflexive:!0},{u:7,v:6},{u:7,v:4}],directional:!0,nowait:!0}),i.init(a.raw())},componentDidUpdate:function(e){this.props!==e&&void 0!==this.props.frame&&this.props.frame&&i.render(this.props.frame.status,this.props.delay,this.props.others)},render:function(){return r.createElement("div",{className:"wrapper-code"},r.createElement("div",{className:"list"},this.getInputList()),r.createElement("div",{ref:"svg",className:"scene"}))},_onLoad:function(){this.setState({loaded:!0})},_onPainting:function(){this.state.painting?a.stop():(i.clear(),s.pauseDemo(),s.waitDemo(),a.restart()),this.setState({painting:!this.state.painting})},_onChange:function(e,t){var n={};n[e]=t.target.value,this.setState(n)},_onClick:function(e){i.clear(),i.init(a.raw()),s.runDemo(e,{g:a.data(),x:this.state.text})},_onConvert:function(e,t){a.convert(e,t)},getInputList:function(){return this.state.loaded===!1?r.createElement("input",{className:"cmd-button",readOnly:!0,value:"加载中",title:"加载中"}):this.state.painting?r.createElement("div",null,r.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onConvert.bind(this,!1,!1),value:"无向图",title:"无向无权图"}),r.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onConvert.bind(this,!0,!1),value:"有向图",title:"有向无权图"}),r.createElement("input",{className:"cmd-button",readOnly:!0,onClick:a.clear,value:"清空",title:"清空"}),r.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onPainting,value:"完成",title:"完成"})):r.createElement("div",null,r.createElement("input",{onChange:this._onChange.bind(this,"text"),value:this.state.text,placeholder:"数字"}),r.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"dfs"),value:"深度优先搜索",title:"深度优先搜索"}),r.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"bfs"),value:"广度优先搜索",title:"广度优先搜索"}),r.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"topo"),value:"拓扑排序",title:"拓扑排序"}),r.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onClick.bind(this,"scctarjan"),value:"强连通分量",title:"强连通分量"}),r.createElement("input",{className:"cmd-button",readOnly:!0,onClick:this._onPainting,value:"编辑图",title:"编辑图"}))}})},58:function(e,t,n){e.exports='<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./graph.h"</span>\n\ngraph* GraphCreate(int n, size_t w_size) {\n    int i;\n    <span class="keyword">if</span> (n == <span class="number">0</span>) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    graph *g = SafeMalloc(sizeof(graph));\n    g->n = n;\n    g->w_size = w_size;\n    g->adja = SafeMalloc(n*(sizeof(graph_edge *)));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) {\n        g->adja[i] = SafeMalloc(sizeof(graph_edge));\n        g->adja[i]->next = <span class="keyword">NULL</span>;\n        g->adja[i]->w = <span class="keyword">NULL</span>;\n    }\n    <span class="keyword">return</span> g;\n}\n\nvoid GraphDestroy(graph *g) {\n    int i;\n    graph_edge *p, *e;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        e = g->adja[i];\n        <span class="keyword">while</span> (e != <span class="keyword">NULL</span>) {\n            p = e->next;\n            <span class="keyword">if</span> (e->w != <span class="keyword">NULL</span>) {\n                free(e->w);\n            }\n            free(e);\n            e = p;\n        }\n    }\n    free(g->adja);\n    free(g);\n}\n\nint GraphNodeValid(graph *g, int u) {\n    <span class="keyword">return</span> <span class="number">0</span> &lt;= u &amp;&amp; u &lt; g->n ? <span class="number">1</span> : <span class="number">0</span>;\n}\n\ngraph_edge* _GraphNewEdge(int u, int v, void *w, size_t w_size) {\n    graph_edge *e = SafeMalloc(sizeof(graph_edge));\n    e->u = u;\n    e->v = v;\n    e->w = SafeMalloc(w_size);\n    MemoryCopy(e->w, w, w_size);\n    <span class="keyword">return</span> e;\n}\n\ngraph_edge* GraphInsert(graph *g, int u, int v, void *w) {\n    graph_edge *e;\n    <span class="keyword">if</span> (!GraphNodeValid(g,u) || !GraphNodeValid(g,v)) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    e = _GraphNewEdge(u,v,w,g->w_size);\n    e->next = g->adja[u]->next;\n    g->adja[u]->next = e;\n    <span class="keyword">return</span> e;\n}'},59:function(e,t,n){e.exports='<span class="comment">#ifndef GRAPH_H</span>\n<span class="comment">#define GRAPH_H</span>\n<span class="comment">#include &lt;stddef.h></span>\n\ntypedef struct graph_edge {\n  int u;\n  int v;\n  void *w;\n  struct graph_edge *next;\n} graph_edge;\n\ntypedef struct graph {\n  int n;\n  size_t w_size;\n  graph_edge **adja;\n} graph;\n\ngraph* GraphCreate(int n, size_t w_size);\nvoid GraphDestroy(graph *g);\ngraph_edge* GraphInsert(graph *g, int u, int v, void *w);\ngraph_edge* GraphDelete(graph *g, int u, int v);\nint GraphNodeValid(graph *g, int u);\n\n<span class="comment">#endif</span>'},60:function(e,t,n){e.exports="CC=gcc\nCFLAGS=-c -Wall\nLDFLAGS=\nSOURCES=test.c ../common/util.c ../common/util.h ./graph.c ./graph.h ./graph-scc-tarjan.c ./graph-scc-tarjan.h ./graph-topo-sort.c ./graph-topo-sort.h ./graph-traverse.c ./graph-traverse.h ../stack/stack.c ../stack/stack.h ../queue/queue.c ../queue/queue.h\nOBJECTS=$(SOURCES:.c=.o)\nEXECUTABLE=a.out\n\nall: $(SOURCES) $(EXECUTABLE)\n\n$(EXECUTABLE): $(OBJECTS)\n    $(CC) $(LDFLAGS) $(OBJECTS) -o $@\n\n.cpp.o:\n    $(CC) $(CFLAGS) $&lt; -o $@\n\nclean:\n    rm -rf *.o a.out"},61:function(e,t,n){e.exports='<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "../queue/queue.h"</span>\n<span class="comment">#include "../stack/stack.h"</span>\n<span class="comment">#include "../common/graph.h"</span>\n\nqueue *GraphBFS(graph *g, int x) {\n    queue *q, *arr;\n    int *vis, *inq;\n    graph_edge *e;\n    int i, u;\n    <span class="keyword">if</span> (!GraphNodeValid(x)) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    q = QueueCreate(g->n, sizeof(int));\n    arr = QueueCreate(g->n, sizeof(int));\n    vis = SafeMalloc(sizeof(int)*g->n);\n    inq = SafeMalloc(sizeof(int)*g->n);\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        vis[i] = <span class="number">0</span>;\n        inq[i] = <span class="number">0</span>;\n    }\n    i = x;\n    QueuePush(q, &amp;i);\n    inq[i] = <span class="number">1</span>;\n    <span class="keyword">while</span> (!QueueIsEmpty(q)) {\n        u = *(int *)QueuePeak(q);\n        QueuePop(q);\n        vis[u] = <span class="number">1</span>;\n        inq[u] = <span class="number">0</span>;\n        QueuePush(arr, &amp;u);\n        <span class="keyword">for</span> (e = g->adja[u]->next; e != <span class="keyword">NULL</span>; e = e->next) {\n            <span class="keyword">if</span> (!vis[e->v] &amp;&amp; !inq[e->v]) {\n                QueuePush(q, &amp;e->v);\n                inq[e->v] = <span class="number">1</span>;\n            }\n        }\n    }\n    QueueDestroy(q);\n    free(vis);\n    free(inq);\n    <span class="keyword">return</span> arr;\n}\n\nqueue *GraphDFS(graph *g, int x) {\n    stack *su, *se;\n    queue *arr;\n    int *vis, *ins;\n    graph_edge *e;\n    int i, u;\n    <span class="keyword">if</span> (!GraphNodeValid(x)) {\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    su = StackCreate(g->n, sizeof(int));\n    se = StackCreate(g->n, sizeof(graph_edge *));\n    arr = QueueCreate(g->n, sizeof(int));\n    vis = SafeMalloc(sizeof(int)*g->n);\n    ins = SafeMalloc(sizeof(int)*g->n);\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        vis[i] = <span class="number">0</span>;\n        ins[i] = <span class="number">0</span>;\n    }\n    i = x;\n    StackPush(su, &amp;i);\n    StackPush(se, &amp;g->adja[i]->next);\n    ins[i] = <span class="number">1</span>;\n    <span class="keyword">while</span> (!StackIsEmpty(su)) {\n        u = *(int *)StackPeak(su);\n        e = *(graph_edge **)StackPeak(se);\n        <span class="keyword">for</span> (; e != <span class="keyword">NULL</span>; e = e->next) {\n            <span class="keyword">if</span> (!vis[e->v] &amp;&amp; !ins[e->v]) {\n                StackPop(se);\n                StackPush(se, &amp;e->next);\n                StackPush(su, &amp;e->v);\n                StackPush(se, &amp;g->adja[e->v]->next);\n                ins[e->v] = <span class="number">1</span>;\n                <span class="keyword">break</span>;\n            }\n        }\n        <span class="keyword">if</span> (e == <span class="keyword">NULL</span>) {\n            StackPop(su);\n            StackPop(se);\n            vis[u] = <span class="number">1</span>;\n            ins[u] = <span class="number">0</span>;\n            QueuePush(arr, &amp;u);\n        }\n    }\n    StackDestroy(su);\n    StackDestroy(se);\n    free(vis);\n    free(ins);\n    <span class="keyword">return</span> arr;\n}\n\nstack *GraphTopoSort(graph *g) {\n    stack *su = StackCreate(g->n, sizeof(int));\n    stack *se = StackCreate(g->n, sizeof(graph_edge *));\n    stack *arr = StackCreate(g->n, sizeof(int));\n    int *vis = SafeMalloc(sizeof(int)*g->n);\n    int *ins = SafeMalloc(sizeof(int)*g->n);\n    graph_edge *e;\n    int i, u;\n    int circular = <span class="number">0</span>;\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        vis[i] = <span class="number">0</span>;\n        ins[i] = <span class="number">0</span>;\n    }\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n &amp;&amp; !circular; ++i) {\n        <span class="keyword">if</span> (vis[i]) {\n            <span class="keyword">continue</span>;\n        }\n        StackPush(su, &amp;i);\n        StackPush(se, &amp;g->adja[i]->next);\n        ins[i] = <span class="number">1</span>;\n        <span class="keyword">while</span> (!StackIsEmpty(su) &amp;&amp; !circular) {\n            u = *(int *)StackPeak(su);\n            e = *(graph_edge **)StackPeak(se);\n            <span class="keyword">for</span> (; e != <span class="keyword">NULL</span>; e = e->next) {\n                <span class="keyword">if</span> (!vis[e->v] &amp;&amp; !ins[e->v]) {\n                    StackPop(se);\n                    StackPush(se, &amp;e->next);\n                    StackPush(su, &amp;e->v);\n                    StackPush(se, &amp;g->adja[e->v]->next);\n                    ins[e->v] = <span class="number">1</span>;\n                    <span class="keyword">break</span>;\n                } <span class="keyword">else</span> <span class="keyword">if</span> (ins[e->v]) {\n                    circular = <span class="number">1</span>;\n                    <span class="keyword">break</span>;\n                }\n            }\n            <span class="keyword">if</span> (e == <span class="keyword">NULL</span>) {\n                StackPop(su);\n                StackPop(se);\n                vis[u] = <span class="number">1</span>;\n                ins[u] = <span class="number">0</span>;\n                StackPush(arr, &amp;u);\n            }\n        }\n    }\n    StackDestroy(su);\n    StackDestroy(se);\n    free(vis);\n    free(ins);\n    <span class="keyword">if</span> (circular) {\n        StackDestroy(arr);\n        <span class="keyword">return</span> <span class="keyword">NULL</span>;\n    }\n    <span class="keyword">return</span> arr;\n}\n\nint _gId;\nint _gColorK;\nint *_gColor;\nint *_gIndex;\nint *_gLowLk;\nint *_gInStk;\nstack *_gStack;\n\nint _GraphSccTarjanMin(int a, int b) {\n    <span class="keyword">return</span> a &lt; b ? a : b;\n}\n\nvoid _GraphSccTarjanColor(graph *g, int u) {\n    int v;\n    graph_edge *e;\n    _gIndex[u] = _gId++;\n    _gLowLk[u] = _gIndex[u];\n    StackPush(_gStack, &amp;u);\n    _gInStk[u] = <span class="number">1</span>;\n    <span class="keyword">for</span> (e = g->adja[u]->next; e != <span class="keyword">NULL</span>; e = e->next) {\n        <span class="keyword">if</span> (_gIndex[e->v] == -<span class="number">1</span> &amp;&amp; !_gInStk[e->v]) {\n            _GraphSccTarjanColor(g, e->v);\n            _gLowLk[u] = _GraphSccTarjanMin(_gLowLk[u], _gLowLk[e->v]);\n        } <span class="keyword">else</span> <span class="keyword">if</span> (_gInStk[e->v]) {\n            _gLowLk[u] = _GraphSccTarjanMin(_gLowLk[u], _gIndex[e->v]);\n        }\n    }\n    <span class="keyword">if</span> (_gLowLk[u] == _gIndex[u]) {\n        <span class="keyword">do</span> {\n            v = *(int *)StackPeak(_gStack);\n            StackPop(_gStack);\n            _gInStk[v] = <span class="number">0</span>;\n            _gColor[v] = _gColorK;\n        } <span class="keyword">while</span> (v != u);\n        _gColorK++;\n    }\n}\n\nint *GraphSccTarjan(graph *g) {\n    int i;\n    _gId = <span class="number">0</span>;\n    _gColorK = <span class="number">0</span>;\n    _gColor = SafeMalloc(g->n*sizeof(int));\n    _gIndex = SafeMalloc(g->n*sizeof(int));\n    _gLowLk = SafeMalloc(g->n*sizeof(int));\n    _gInStk = SafeMalloc(g->n*sizeof(int));\n    _gStack = StackCreate(g->n, sizeof(int));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        _gIndex[i] = -<span class="number">1</span>;\n        _gInStk[i] = <span class="number">0</span>;\n    }\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n        <span class="keyword">if</span> (_gIndex[i] == -<span class="number">1</span>) {\n            _GraphSccTarjanColor(g, i);\n        }\n    }\n    free(_gIndex);\n    free(_gLowLk);\n    free(_gInStk);\n    StackDestroy(_gStack);\n    <span class="keyword">return</span> _gColor;\n}'},62:function(e,t,n){e.exports='<span class="comment">#ifndef GRAPH_APP_H</span>\n<span class="comment">#define GRAPH_APP_H</span>\n<span class="comment">#include "../common/graph.h"</span>\n<span class="comment">#include "../queue/queue.h"</span>\n<span class="comment">#include "../stack/stack.h"</span>\n\nint *GraphSccTarjan(graph *g);\nstack *GraphTopoSort(graph *g);\nqueue *GraphBFS(graph *g);\nqueue *GraphDFS(graph *g);\n\n<span class="comment">#endif</span>'},63:function(e,t,n){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/graph.h"</span>\n<span class="comment">#include "./graph-app.h"</span>\n<span class="comment">#include "../queue/queue.h"</span>\n<span class="comment">#include "../stack/stack.h"</span>\n\nint main(int argc, char <span class="keyword">const</span> *argv[])\n{\n  int n, m, i, u, v;\n  int w = <span class="number">1</span>;\n  graph *g;\n  queue *q;\n  stack *s;\n  int *c;\n  <span class="keyword">while</span> (scanf(<span class="string">"%d%d"</span>, &amp;n,&amp;m) != EOF) {\n    g = GraphCreate(n, sizeof(int));\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++i) {\n      scanf(<span class="string">"%d%d"</span>, &amp;u, &amp;v);\n      GraphInsert(g, u, v, &amp;w);\n    }\n    q = GraphBFS(g);\n    <span class="keyword">while</span> (!QueueIsEmpty(q)) {\n      printf(<span class="string">"%d "</span>, *(int *)QueuePeak(q));\n      QueuePop(q);\n    }\n    printf(<span class="string">"--bfs\\n"</span>);\n    QueueDestroy(q);\n    q = GraphDFS(g);\n    <span class="keyword">while</span> (!QueueIsEmpty(q)) {\n      printf(<span class="string">"%d "</span>, *(int *)QueuePeak(q));\n      QueuePop(q);\n    }\n    printf(<span class="string">"--dfs\\n"</span>);\n    QueueDestroy(q);\n    s = GraphTopoSort(g);\n    <span class="keyword">if</span> (s == <span class="keyword">NULL</span>) {\n      printf(<span class="string">"circular"</span>);\n    } <span class="keyword">else</span> {\n      <span class="keyword">while</span> (!StackIsEmpty(s)) {\n        printf(<span class="string">"%d "</span>, *(int *)StackPeak(s));\n        StackPop(s);\n      }\n      StackDestroy(s);\n    }\n    printf(<span class="string">"--topoSort\\n"</span>);\n    c = GraphSccTarjan(g);\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n      printf(<span class="string">"%d "</span>, i);\n    }\n    printf(<span class="string">"--sccTarjan\\n"</span>);\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g->n; ++i) {\n      printf(<span class="string">"%d "</span>, c[i]);\n    }\n    printf(<span class="string">"--sccTarjan\\n"</span>);\n    free(c);\n\n    GraphDestroy(g);\n  }\n  <span class="keyword">return</span> <span class="number">0</span>;\n}'},100:function(e,t,n){var r=n(30);"string"==typeof r&&(r=[[e.id,r,""]]);n(9)(r,{})},101:function(e,t,n){var r=n(31);"string"==typeof r&&(r=[[e.id,r,""]]);n(9)(r,{})},110:function(e,t,n){function r(e){ce=!1,H=e.container||document.body,U=C.select(e.container).append("svg").node(),R=e.weighted||!1,z=e.directional||!1,N=e.width||U.clientWidth||e.container.clientWidth,O=e.height||U.clientHeight||e.container.clientHeight,oe=e.offsetLeft||0,ie=e.offsetTop||0,W.nodes=e.nodes||C.range(e.n||5).map(function(){return{}}),W.edges=(e.edges||C.range(5).map(function(e){return{u:e,v:(e+1)%5}})).map(function(e){return{source:W.nodes[e.u],target:W.nodes[e.v],val:e.w,reflexive:e.reflexive}}),B=void 0,j=e._onSelected||void 0,_onLoad=e._onLoad||void 0,se=void 0,ae=!1,C.select(U).call(re).on("dblclick.zoom",null).on("dblclick.svg",D);var t=C.select(U).append("defs");return t.append("marker").attr("id","arrow-end").attr("viewBox","0 -5 10 10").attr("refX",7).attr("refY",0).attr("markerWidth",ee).attr("markerHeight",ee).attr("orient","auto").append("path").attr("d","M0,-5L10,0L0,5"),t.append("marker").attr("id","arrow-start").attr("viewBox","0 -5 10 10").attr("refX",3).attr("refY",0).attr("markerWidth",ee).attr("markerHeight",ee).attr("orient","auto").append("path").attr("d","M10,-5L0,0L10,5"),F=C.select(U).append("g").attr("class","svg-entry"),Y=F.append("g").attr("class","base"),$=Y.append("g").attr("class","edges"),G=Y.append("g").attr("class","nodes"),Q=F.append("g").attr("class","text").attr("transform","translate(0,7)"),$.append("path").attr("class","drag").attr("marker-end","url(#arrow-end)").style("display","none"),C.select(window).on("keydown.window",E),te.nodes(W.nodes).links(W.edges).size([N,O]),d(),P(!1),te.on("end",function(){P(),te.on("end",null),_onLoad&&_onLoad()}),e.nowait&&(u(),te.on("end")()),this}function s(e,t){var n=e.x-t.x,r=e.y-t.y;return K*K>=n*n+r*r}function a(e,t){var n=Math.PI*t/180;return{x:e.x*Math.cos(n)+e.y*Math.sin(n),y:e.x*-Math.sin(n)+e.y*Math.cos(n)}}function i(e){return"translate("+e.x+","+e.y+")"}function o(e){return{x:-e.x,y:-e.y}}function c(e,t){return{x:e.x-t.x,y:e.y-t.y}}function l(e){return void 0===e.val?"":e.val}function p(e){var t=e.target.x-e.source.x,n=e.target.y-e.source.y,r=Math.sqrt(t*t+n*n),i=C.interpolate(e.source,e.target)(K/r),l=C.interpolate(e.target,e.source)(K/r),p=C.interpolate(30,0)(K/r);

if(z&&R){var u=W.edges.filter(function(t){return t.target===e.source&&(t.source===e.target||s(e.target,t.source))});return u.length>0?(e.curve=!0,i=c(a(c(i,e.source),p),o(e.source)),l=c(a(c(l,e.target),-p),o(e.target)),"M"+i.x+","+i.y+"A"+r+","+r+" 0 0,1 "+l.x+","+l.y):(e.curve=!1,"M"+i.x+","+i.y+"L"+l.x+","+l.y)}return e.curve=!1,"M"+i.x+","+i.y+"L"+l.x+","+l.y}function u(){G.selectAll(".node").data(W.nodes).classed("painter-selected",function(e){return e===B}).attr("transform",i),Q.selectAll(".node").data(W.nodes).attr("transform",i).text(function(e,t){return t}),$.selectAll(".edge").data(W.edges).classed("painter-selected",function(e){return e===B}).attr("marker-end",z?"url(#arrow-end)":null).attr("marker-start",z&&R===!1?function(e){return e.reflexive?"url(#arrow-start)":null}:null).attr("d",p),R&&($.selectAll(".edge").each(function(e){var t=this.getPointAtLength(this.getTotalLength()/2);e.x=t.x,e.y=t.y}),Q.selectAll(".edge").data(W.edges).attr("transform",i).text(l))}function d(){G.selectAll(".node").data(W.nodes).enter().append("circle").attr("class","node").attr("r",K).on("dblclick.node",h).call(ne).on("click.select",x).on("mousedown.node",y).on("mouseup.node",w),G.selectAll(".node").data(W.nodes).exit().remove(),Q.selectAll(".node").data(W.nodes).enter().append("text").attr("class","node"),Q.selectAll(".node").data(W.nodes).exit().remove(),$.selectAll(".edge").data(W.edges).enter().append("path").attr("class","edge").on("click.select",x),$.selectAll(".edge").data(W.edges).exit().remove(),R?(Q.selectAll(".edge").data(W.edges).enter().append("text").attr("class","edge"),Q.selectAll(".edge").data(W.edges).exit().remove()):Q.selectAll(".edge").remove(),te.start()}function f(){N=U.clientWidth||H.clientWidth,O=U.clientHeight||H.clientHeight,te.size([N,O]).resume()}function h(e){C.event.stopPropagation(),C.select(this).classed("fixed",e.fixed=!1),te.resume()}function g(e){e.fixed|=2}function m(e){se&&(ae?(C.select(this).classed("fixed",e.fixed=!0),e.px=C.event.x||C.event.clientX,e.py=C.event.y||C.event.clientY,te.resume()):s(C.event,e)===!1?$.select("path.drag").datum({source:e,target:{x:C.event.x||C.event.clientX,y:C.event.y||C.event.clientY}}).attr("d",p).style("display",null):$.select("path.drag").style("display","none"))}function v(e){e.fixed&=-7,$.select("path.drag").style("display","none")}function y(e){(C.event.ctrlKey===!1||void 0===C.event.ctrlKey)&&(C.event.stopPropagation(),se=e,ae=C.event.shiftKey?!0:!1)}function w(e){if(se&&se!==e){var t={source:se,target:e};k(t),d()}se=void 0,ae=!1}function x(e,t){B=B===e?void 0:e,t===!0&&(B=e),B&&j&&j(),te.resume()}function k(e){var t;z===!1?(t=W.edges.filter(function(t){return t.source===e.source&&t.target===e.target||t.target===e.source&&t.source===e.target}),t.length>0?e=t[0]:W.edges.push(e)):R?(t=W.edges.filter(function(t){return t.source===e.source&&t.target===e.target}),t.length>0?e=t[0]:W.edges.push(e)):(t=W.edges.filter(function(t){return t.source===e.source&&t.target===e.target||t.target===e.source&&t.source===e.target}),t.length>0?(t[0].source===e.target&&(t[0].reflexive=!0),e=t[0]):W.edges.push(e)),x(e,!0)}function _(){var e=void 0===B||void 0===B.val?"数字":B.val;return prompt("权值",e)}function b(e){var t=e();return""===t?void delete B.val:(t=parseFloat(t),isNaN(t)||B.val===t?void 0:(B.val=t,d(),this))}function E(){B&&(8===C.event.keyCode?(C.event.preventDefault(),S()):13===C.event.keyCode&&R&&b(_))}function S(){var e=W.nodes.indexOf(B);return-1!==e?(W.nodes.splice(e,1),W.edges.filter(function(e){return e.source===B||e.target===B}).forEach(function(e){W.edges.splice(W.edges.indexOf(e),1)})):(e=W.edges.indexOf(B),-1!=e&&W.edges.splice(W.edges.indexOf(B),1)),B=void 0,d(),this}function A(){X=C.event.translate,J=C.event.scale,F.attr("transform","translate("+C.event.translate+")scale("+C.event.scale+")")}function L(){var e=document.documentElement;return{left:(window.pageXOffset||e.scrollLeft)-(e.clientLeft||0),top:(window.pageYOffset||e.scrollTop)-(e.clientTop||0)}}function D(){if(C.event.target===this){var e=C.event.x||C.event.clientX||C.event.clientX,t=C.event.y||C.event.clientY||C.event.clientY,n=L();e+=n.left-oe,t+=n.top-ie;var r={x:(e-X[0])/J,y:(t-X[1])/J};W.nodes.push(r),x(r),d()}}function P(e){return B&&($.select(".painter-selected").classed("painter-selected",!1),G.select(".painter-selected").classed("painter-selected",!1),B=void 0),e!==!1&&te.stop(),C.select(window).on("resize",null).on("keydown.window",null),C.select(U).on("dblclick.svg",null),G.selectAll("circle.node").on("dblclick.node",null).on("dragstart",null).on("drag",null).on("dragend",null).on("click.select",null).on("mousedown.node",null).on("mouseup.node",null),$.selectAll("path.edge").on("click.select",null),this}function M(e,t){function n(e,t){return e.source===t.target&&e.target===t.source}if(z!==e||R!==t){pd=z,z=e,R=t;var r=[];return W.edges.forEach(function(e){z?R?((pd===!1||e.reflexive)&&r.push({source:e.target,target:e.source,val:e.val}),delete e.reflexive,r.push(e)):(delete e.reflexive,r.some(function(t){return n(e,t)})===!1&&((pd===!1||W.edges.some(function(t){return n(e,t)})===!0)&&(e.reflexive=!0),r.push(e))):r.some(function(t){return n(e,t)})===!1&&(delete e.reflexive,r.push(e))}),W.edges=r,$.classed("directional",z).classed("weighted",R),d(),this}}function T(){te.start(),C.select(window).on("resize",f).on("keydown.window",E),C.select(U).on("dblclick.svg",D),G.selectAll("circle.node").on("dblclick.node",h).call(ne).on("click.select",x).on("mousedown.node",y).on("mouseup.node",w),$.selectAll("path.edge").on("click.select",x)}function I(){W.nodes.length=0,W.edges.length=0,d()}function q(){}var C=n(2);n(100);var U,R,z,N,O,B,j,F,Y,$,G,Q,H,W={},X=[0,0],J=1,K=15,V=150,Z=-600,ee=3,te=C.layout.force().linkDistance(V).charge(Z).on("tick",u),ne=C.behavior.drag().origin(function(e){return e}).on("dragstart",g).on("drag",m).on("dragend",v),re=C.behavior.zoom().scaleExtent([.1,10]).on("zoom",A),se=void 0,ae=!1,ie=0,oe=0,ce=!1;e.exports={stop:P,convert:M,weighSelected:b,deleteSelected:S,init:r,restart:T,clear:I,random:q,directional:function(){return z},weighted:function(){return R},raw:function(){return W},data:function(){var e=W.edges.map(function(e){return{u:e.source.index,v:e.target.index,w:e.val}});return z||(e=e.concat(W.edges.map(function(e){return{u:e.target.index,v:e.source.index,w:e.val}}))),z&&!R&&(e=e.concat(W.edges.filter(function(e){return e.reflexive}).map(function(e){return{u:e.target.index,v:e.source.index,w:e.val}}))),{weighted:R,directional:z,n:W.nodes.length,e:e}}}},111:function(e,t,n){function r(e){return"translate("+q.nodes[e].x+","+q.nodes[e].y+")"}function s(e,t){return{endAngle:(t+1)/L.inq.length*R}}function a(e){return e}function i(e){return void 0!==L.vis[e.index]}function o(){gnodes.selectAll("path.inq").data(L.inq,a).enter().append("path").attr("class","inq").attr("d",function(e){return z({endAngle:0})}).attr("transform",r).each(function(e){this._current={endAngle:0}}),gnodes.selectAll("path.inq").data(L.inq,a).transition().duration(D).attr("transform",r).attrTween("d",function(e,t){var n=C.interpolate(this._current,s(e,t));return this._current=n(0),function(e){return z(n(e))}}),gnodes.selectAll("path.inq").data(L.inq,a).exit().remove(),gnodes.selectAll("circle.node").classed("visited",i),A.selectAll("text.node").classed("visited",i)}function c(e){return e.u+"-"+e.v}function l(e,t){var n=Math.PI*t/180;return{x:e.x*Math.cos(n)+e.y*Math.sin(n),y:e.x*-Math.sin(n)+e.y*Math.cos(n)}}function p(e){return{x:-e.x,y:-e.y}}function u(e,t){return{x:e.x-t.x,y:e.y-t.y}}function d(e,t,n){var r=gedges.classed("weighted"),s=gedges.classed("directional");if(!r||!s){if(n===!0)return t.u===e.source.index&&t.v===e.target.index;if(n===!1)return t.v===e.source.index&&t.u===e.target.index}return e.reflexive||!s?t.u===e.source.index&&t.v===e.target.index||t.v===e.source.index&&t.u===e.target.index:t.u===e.source.index&&t.v===e.target.index}function f(e){var t=gedges.classed("weighted"),n=gedges.classed("directional"),r=q.edges.filter(function(t){return d(t,e)})[0];return n&&t?r:{source:r.source.index===e.u?r.source:r.target,target:r.target.index===e.v?r.target:r.source}}function h(e){return function(t){var n=f(t),r=n.source.x-n.target.x,s=n.target.y-n.source.y,a=Math.sqrt(r*r+s*s),i="exit"===e?C.interpolate(n.target,n.source):C.interpolate(n.source,n.target),o=n.source;if(n.curve){var c="exit"===e?C.interpolate(0,30):C.interpolate(30,0);return function(e){var t=c(e),n=u(l(u(i(e),o),t),p(o));return"M"+o.x+","+o.y+"A"+a+","+a+" 0 0,1 "+n.x+","+n.y}}return function(e){var t=i(e);return"M"+o.x+","+o.y+"L"+t.x+","+t.y}}}function g(e){return L.se.some(function(t){return d(e,t)})}function m(e){var t=gedges.classed("weighted"),n=gedges.classed("directional");return n&&t?!1:L.se.some(function(t){return d(e,t,!1)})}function v(e){var t=gedges.classed("weighted"),n=gedges.classed("directional");return n&&t?!1:L.se.some(function(t){return d(e,t,!0)})}function y(){gedges.selectAll("path.edge").classed("painter-selected",g).classed("rev-dir",m).classed("sam-dir",v),gedges.selectAll("path.ine").data(L.ine,c).enter().insert("path",":first-child").attr("class","ine").transition().duration(D).attrTween("d",h("update")),gedges.selectAll("path.ine").data(L.ine,c).exit().transition().duration(D).attrTween("d",h("exit")).remove()}function w(){gnodes.selectAll("circle.node").classed("highlighted",function(e,t){return t===L.hl}),M.selectAll("text.topo").data(L.arr,a).enter().append("text").attr("class","topo").attr("transform",r).text(function(e,t){return"["+(L.vis.length-t-1)+"]"}),M.selectAll("text.topo").data(L.arr,a).attr("transform",r).text(function(e,t){return"["+(L.vis.length-t-1)+"]"}),M.selectAll("text.topo").data(L.arr,a).exit().remove()}function x(){function e(e,t){return r(t)}function t(e){return"undefined"===L.ind[e]?"":"("+L.ind[e]+","+(void 0===L.low[e]?"?":L.low[e])+")"}var n=L.col.reduce(function(e,t,n){return void 0!==t&&(e[t]=(e[t]||[]).concat(C.range(4).map(function(e){return[q.nodes[n].x+N[e][0]*U,q.nodes[n].y+N[e][1]*U]}))),e},[]).map(C.geom.hull);S.selectAll("path.scc").data(n).enter().insert("path",":first-child").attr("class","scc"),S.selectAll("path.scc").data(n).attr("d",function(e){return"M"+e.join("L")+"Z"}),S.selectAll("path.scc").data(n).exit().remove(),T.selectAll("text.low").data(L.low).enter().append("text").attr("class","low"),T.selectAll("text.low").data(L.low).text(function(e,n){return t(n)}).attr("transform",e),T.selectAll("text.low").data(L.low).exit().remove()}function k(e,t,n){L=e,D=t,P=n}function _(e,t,n){k(e,t,n),o(),y(),w(),x()}function b(e){q=e,S=C.select("g.base"),A=C.select("g.text"),gnodes=C.select("g.nodes"),gedges=C.select("g.edges"),C.selectAll("g.topo,g.scclow,g.sccind").remove(),M=A.append("g").attr("class","topo").attr("transform","translate(15,-15)"),T=A.append("g").attr("class","scclow").attr("transform","translate(20,-10)"),I=A.append("g").attr("class","sccind").attr("transform","translate(15,15)")}function E(){S.selectAll("path.scc").remove(),gnodes.selectAll("path.inq").remove(),gedges.selectAll("path.edge").attr("class","edge"),gedges.selectAll("path.ine").remove(),gnodes.selectAll("circle.node").attr("class","node"),A.selectAll("text.node").attr("class","node"),M.remove(),T.remove(),I.remove()}var S,A,L,D,P,M,T,I,q,C=n(2),U=(n(5),15),R=2*Math.PI,z=C.svg.arc().innerRadius(0).outerRadius(U).startAngle(0),N=(C.scale.category10(),[[-1,-1],[-1,1],[1,-1],[1,1]]);e.exports={init:b,render:_,clear:E}}});