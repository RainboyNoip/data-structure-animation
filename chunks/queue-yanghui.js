webpackJsonpdsa([8],{2:function(e,n,t){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include &lt;string.h></span>\n<span class="comment">#include "./util.h"</span>\n\nvoid* SafeMalloc(size_t size) {\n    void* m;\n    <span class="keyword">if</span> ((m = malloc(size))) {\n        <span class="keyword">return</span> m;\n    } <span class="keyword">else</span> {\n        printf(<span class="string">"memory overflow\\n"</span>);\n        <span class="keyword">exit</span>(-<span class="number">1</span>);\n        <span class="keyword">return</span> <span class="number">0</span>;\n    }\n}\n\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">// }</span>\n    memcpy(a, b, size);\n}\n\nvoid MemorySwap(void *a, void *b, size_t size) {\n    <span class="comment">// size_t i;</span>\n    <span class="comment">// size_t n = size / sizeof(char);</span>\n    <span class="comment">// char t;</span>\n    <span class="comment">// for (i = 0; i &lt; n; ++i) {</span>\n    <span class="comment">//     t = *(char *)a;</span>\n    <span class="comment">//     *((char *)a + i) = *((char *)b + i);</span>\n    <span class="comment">//     *((char *)b + i) = t;</span>\n    <span class="comment">// }</span>\n    void *t = SafeMalloc(size);\n    memcpy(t, a, size);\n    memcpy(a, b, size);\n    memcpy(b, t, size);\n}\n\nvoid MemoryClear(void *a, size_t size) {\n    memset(a, <span class="number">0</span>, size);\n}\n\nvoid *MemoryAddress(void *a, int i, size_t size) {\n    <span class="keyword">return</span> (char *)a + i*size;\n}'},3:function(e,n,t){e.exports='<span class="comment">#ifndef UTIL_H</span>\n<span class="comment">#define UTIL_H</span>\n\n<span class="comment">#include &lt;stddef.h></span>\n\nvoid * SafeMalloc(size_t size);\nvoid MemoryCopy(void *a, <span class="keyword">const</span> void *b, size_t size);\nvoid MemorySwap(void *a, void *b, size_t size);\nvoid MemoryClear(void *a, size_t size);\n\n<span class="comment">#endif</span>'},16:function(e,n,t){e.exports='<span class="comment">#include &lt;stddef.h></span>\n<span class="comment">#include &lt;stdlib.h></span>\n<span class="comment">#include "../common/util.h"</span>\n<span class="comment">#include "./queue.h"</span>\n\nint QueueIsEmpty(queue *q) {\n  <span class="keyword">return</span> q->front != q->tail ? <span class="number">0</span> : <span class="number">1</span>;\n}\n\nint QueueIsFull(queue *q) {\n  <span class="keyword">return</span> (q->tail+<span class="number">1</span>) % q->capacity != q->front ? <span class="number">0</span> : <span class="number">1</span>;\n}\n\nvoid *QueuePop(queue *q) {\n  void *item = <span class="keyword">NULL</span>;\n  <span class="keyword">if</span> (!QueueIsEmpty(q)) {\n    item = (char *)q->items + q->front*q->item_size;\n    q->front = (q->front+<span class="number">1</span>) % q->capacity;\n  }\n  <span class="keyword">return</span> item;\n}\n\nvoid *QueuePeak(queue *q) {\n  void *item = <span class="keyword">NULL</span>;\n  <span class="keyword">if</span> (!QueueIsEmpty(q)) {\n    item = (char *)q->items + q->front*q->item_size;\n  }\n  <span class="keyword">return</span> item;\n}\n\nvoid *QueuePush(queue *q, void *x) {\n  <span class="keyword">if</span> (!QueueIsFull(q)) {\n    MemoryCopy((char *)q->items + q->tail*q->item_size, x, q->item_size);\n    q->tail = (q->tail+<span class="number">1</span>) % q->capacity;\n    <span class="keyword">return</span> x;\n  }\n  <span class="keyword">return</span> <span class="keyword">NULL</span>;\n}\n\nqueue *QueueCreate(int n, size_t item_size) {\n  n = n+<span class="number">1</span>;  <span class="comment">// 1 for front-tail</span>\n  queue *q = SafeMalloc(sizeof(queue));\n  q->capacity = n;\n  q->front = q->tail = <span class="number">0</span>;\n  q->items = SafeMalloc(item_size*n);\n  q->item_size = item_size;\n  <span class="keyword">return</span> q;\n}\n\nvoid QueueDestroy(queue *q) {\n  free(q->items);\n  free(q);\n}'},17:function(e,n,t){e.exports='<span class="comment">#ifndef QUEUE_H</span>\n<span class="comment">#define QUEUE_H</span>\n<span class="comment">#include &lt;stddef.h></span>\ntypedef struct queue {\n  int front;\n  int tail;\n  int capacity;\n  size_t item_size;\n  void *items;\n} queue;\n\nqueue *QueueCreate(int n, size_t item_size);\nvoid QueueDestroy(queue *q);\nint QueueIsEmpty(queue *q);\nint QueueIsFull(queue *q);\nvoid *QueuePop(queue *q);\nvoid *QueuePeak(queue *q);\nvoid *QueuePush(queue *q, void *x);\n\n<span class="comment">#endif</span>'},31:function(e,n,t){function a(e,n,t){1===n&&(lastStatus=p.clone()),i.push({status:lastStatus,line:e,animation:t,id:o}),o++}function s(){a(i[i.length-1].line,1)}var r=t(6),i=[],o=0,c=8,l=0,p={},u=function(e){var n,t,s,r;for(a(9),a(10,1),p.push(1,0,0),n=1;a(12,1),e>=n;++n){for(a(13),p.push(1,n,0),t=0;a(14,1),p.front(1),n-1>t;++t)a(15,1),s=p.front(),a(16,1),p.shift(),a(17,1),r=p.front(),a(18,1),p.push(s+r,n,t+1),p.last();a(20,1),p.shift(),a(21,1),p.push(1,n,n)}for(n=0;a(23,1),e+1>n;++n)a(24),s=p.front(),a(25,1),a(26),p.shift();a(28),a(29)};p.init=function(e){l=0,this.nums=[],this.tofront=[],this.yh=[]},p.last=function(){var e=this.nums.length;this.tofront.push(this.yh[this.nums[e-1].i])},p.front=function(e){return e?this.tofront=[]:this.tofront.push(this.yh[this.nums[0].i]),this.nums[0].v},p.push=function(e,n,t){this.nums.push({v:e,i:l}),this.yh.push({v:e,r:n,c:t,i:l}),l++},p.shift=function(){this.nums.shift()},p.clone=function(){return{nums:r(this.nums),tofront:r(this.tofront),yh:r(this.yh)}},lastStatus={},e.exports={getInitialDescriptions:function(){return this.initialize(),this.run("yanghui",6)},initialize:function(){return i=[],o=0,p.init(!0),lastStatus=p.clone(),this},yanghui:u,run:function(e,n){return this.initialize()[e](isNaN(parseInt(n))?0:parseInt(n)),s(),{frames:i,others:{N:c}}}}},65:function(e,n,t){var a=t(1);e.exports=a.createClass({displayName:"module.exports",render:function(){var e={display:this.props.show?"block":"none"};return a.createElement("svg",{className:"legend",width:"210",height:"90",style:e},a.createElement("rect",{className:"outline",stroke:"black",x:"0",y:"0",width:"200",height:"90"}),a.createElement("g",{transform:"translate(15,20)"},a.createElement("g",{transform:"translate(6,0)"},a.createElement("circle",{cx:"0",cy:"0",r:"6",fill:"coral"})),a.createElement("g",{transform:"translate(6,25)"},a.createElement("circle",{cx:"0",cy:"0",r:"6",fill:"deepskyblue"})),a.createElement("g",{transform:"translate(6,50)"},a.createElement("circle",{cx:"0",cy:"0",r:"6",fill:"deepskyblue",stroke:"gray",strokeWidth:"4"})),a.createElement("g",{transform:"translate(0,5)"},a.createElement("text",{x:"40",y:"0"},"已经出队的元素"),a.createElement("text",{x:"40",y:"25"},"队列中的元素"),a.createElement("text",{x:"40",y:"50"},"正在计算的元素"))))}})},66:function(e,n,t){var a=t(1),s=t(5),r=t(147),i=t(65);e.exports=a.createClass({displayName:"module.exports",getInitialState:function(){return{text:"8",demo:"yanghui",help:!0}},componentDidMount:function(){r.init.bind(this)(),s.runDemo("yanghui",8,!1)},componentDidUpdate:function(e){this.props!==e&&void 0!==this.props.frame&&r.render(this.props.frame.status,this.props.delay,this.props.others)},render:function(){var e=[{button:{demo:"yanghui",onClick:this._onClick.bind(this,"yanghui"),value:"计算杨辉三角"},items:[{onChange:this._onChange,value:this.state.text,placeholder:"整数"}]},{button:{help:this.state.help,onClick:this._onHelp,value:"帮助"}}],n=this;return a.createElement("div",{className:"wrapper-code"},a.createElement("div",{className:"list"},e.map(function(e,t){var s="input-group"+(e.button.help||e.button.demo===n.state.demo?" input-current":""),r=e.items?e.items:[];return a.createElement("div",{key:t,className:s},a.createElement("input",{className:"input-button",readOnly:!0,onClick:e.button.onClick,value:e.button.value,title:e.button.value}),a.createElement("div",null,r.map(function(e,n){return a.createElement("input",{key:n,className:"input-item",onChange:e.onChange,value:e.value,title:e.value,placeholder:e.placeholder})})))})),a.createElement("div",{ref:"svg",className:"scene"}),a.createElement(i,{show:this.state.help}))},_onChange:function(e){this.setState({text:e.target.value})},_onClick:function(e){s.runDemo(e,this.state.text)},_onHelp:function(){this.setState({help:!this.state.help})}})},101:function(e,n,t){e.exports="CC=gcc\nCFLAGS=-c -Wall\nLDFLAGS=\nSOURCES=test.c queue-yanghui.c ../queue/queue.c ../common/util.c\nOBJECTS=$(SOURCES:.c=.o)\nEXECUTABLE=a.out\n\nall: $(SOURCES) $(EXECUTABLE)\n\n$(EXECUTABLE): $(OBJECTS)\n    $(CC) $(LDFLAGS) $(OBJECTS) -o $@\n\n.cpp.o:\n    $(CC) $(CFLAGS) $&lt; -o $@\n\nclean:\n    rm -rf *.o a.out"},102:function(e,n,t){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include "../queue/queue.h"</span>\n\nvoid yanghui(n) {\n    int i;\n    int j;\n    int a;\n    int one = <span class="number">1</span>;\n    queue *nums = QueueCreate(n+<span class="number">1</span>, sizeof(int));\n    QueuePush(nums, &amp;one);\n    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) {\n        QueuePush(nums, &amp;one);\n        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i-<span class="number">1</span>; ++j) {\n            a = *(int *)QueuePeak(nums);\n            QueuePop(nums);\n            a += *(int *)QueuePeak(nums);\n            QueuePush(nums, &amp;a);\n        }\n        QueuePop(nums);\n        QueuePush(nums, &amp;one);\n    }\n    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n+<span class="number">1</span>; ++i) {\n        a = *(int *)QueuePeak(nums);\n        printf(<span class="string">"%d "</span>, a);\n        QueuePop(nums);\n    }\n    printf(<span class="string">"\\n"</span>);\n    QueueDestroy(nums);\n    <span class="keyword">return</span>;\n}'},103:function(e,n,t){e.exports="void yanghui(int n);"},104:function(e,n,t){e.exports='<span class="comment">#include &lt;stdio.h></span>\n<span class="comment">#include "./queue-yanghui.h"</span>\n\nint main(int argc, char <span class="keyword">const</span> *argv[]) {\n  int n;\n  <span class="keyword">while</span> (scanf(<span class="string">"%d"</span>, &amp;n) != EOF) {\n    yanghui(n);\n  }\n  <span class="keyword">return</span> <span class="number">0</span>;\n}'},147:function(e,n,t){function a(){var e=u.yh.map(function(e,n){return{cy:e.r*f*Math.sqrt(3),cx:(e.c-(e.r+1)/2)*f*2,v:e.v}});c.selectAll("circle").data(e).enter().append("circle").attr("r",f).attr("cx",function(e){return e.cx}).attr("cy",function(e){return e.cy}).style("fill","coral").style("opacity",0).transition().duration(d).style("opacity",1),c.selectAll("circle").data(e).style("opacity",1).transition().duration(d).style("fill",function(e,n){return u.nums.some(function(e){return e.i===n})?g:"coral"}),c.selectAll("circle").data(e).exit().style("opacity",1).transition().duration(d).style("opacity",0).remove(),l.selectAll("text").data(e).enter().append("text").attr("x",function(e){return e.cx}).attr("y",function(e){return e.cy}).attr("dy",5).text(function(e){return e.v}).style("opacity",0).transition().duration(d).style("opacity",1),l.selectAll("text").data(e).transition().duration(d).style("opacity",1),l.selectAll("text").data(e).exit().style("opacity",1).transition().duration(d).style("opacity",0).remove()}function s(){var e=u.tofront.map(function(e,n){return{cy:e.r*f*Math.sqrt(3),cx:(e.c-(e.r+1)/2)*f*2,v:e.v}});p.selectAll("circle").data(e).enter().append("circle").attr("r",f).attr("cx",function(e){return e.cx}).attr("cy",function(e){return e.cy}).style("fill","transparent").style("stroke","gray").style("stroke-width",5).style("opacity",0).transition().duration(d).style("opacity",1),p.selectAll("circle").data(e).transition().duration(d).attr("cx",function(e){return e.cx}).attr("cy",function(e){return e.cy}).style("opacity",1),p.selectAll("circle").data(e).exit().style("opacity",1).transition().duration(d).style("opacity",0).remove()}function r(e,n){u=e,d=n}function i(e,n){r(e,n),a(),s()}function o(){var e=this,n=m.behavior.zoom().scaleExtent([.1,10]).on("zoom",function(){e.svg.attr("transform",h().translate(m.event.translate).scale(m.event.scale))});this.svg=m.select(this.refs.svg.getDOMNode()).append("svg").call(n).append("g"),this.g=this.svg.append("g").attr("transform",h().translate(300,50).scale(1)),this.gbase=this.g.append("g").attr("class","base"),this.ghigh=this.g.append("g").attr("class","high"),this.gtext=this.g.append("g").attr("class","text"),c=this.gbase,l=this.gtext,p=this.ghigh}var c,l,p,u,d,u,d,m=t(4),h=t(8),f=30,g="deepskyblue";e.exports={init:o,render:i}}});